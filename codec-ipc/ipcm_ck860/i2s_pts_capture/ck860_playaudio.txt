
ck860_play_audio:     file format elf32-csky-little


Disassembly of section .init:

00009a80 <_init>:
    9a80:	1422      	subi      	sp, sp, 8
    9a82:	ddee2000 	st.w      	r15, (sp, 0)
    9a86:	e0000045 	bsr      	0x9b10	// 9b10 <call_weak_fn>
    9a8a:	c4004820 	lsli      	r0, r0, 0
    9a8e:	0409      	br      	0x9aa0	// 9aa0 <_init+0x20>
    9a90:	00009b10 	.long	0x00009b10
	...
    9aa0:	e000009e 	bsr      	0x9bdc	// 9bdc <frame_dummy>
    9aa4:	c4004820 	lsli      	r0, r0, 0
    9aa8:	0404      	br      	0x9ab0	// 9ab0 <_init+0x30>
    9aaa:	0000      	.short	0x0000
    9aac:	00009bdc 	.long	0x00009bdc
    9ab0:	e0001d16 	bsr      	0xd4dc	// d4dc <__do_global_ctors_aux>
    9ab4:	c4004820 	lsli      	r0, r0, 0
    9ab8:	0404      	br      	0x9ac0	// 9ac0 <_init+0x40>
    9aba:	0000      	.short	0x0000
    9abc:	0000d4dc 	.long	0x0000d4dc
    9ac0:	d9ee2000 	ld.w      	r15, (sp, 0)
    9ac4:	1402      	addi      	sp, sp, 8
    9ac6:	783c      	rts

Disassembly of section .text:

00009ad0 <_start>:
    9ad0:	1422      	subi      	sp, sp, 8
    9ad2:	ea0f0000 	movi      	r15, 0
    9ad6:	9822      	ld.w      	r1, (sp, 0x8)
    9ad8:	1a03      	addi      	r2, sp, 12
    9ada:	b842      	st.w      	r2, (sp, 0x8)
    9adc:	b801      	st.w      	r0, (sp, 0x4)
    9ade:	1007      	lrw      	r0, 0xd4c8	// 9af8 <_start+0x28>
    9ae0:	b800      	st.w      	r0, (sp, 0)
    9ae2:	1007      	lrw      	r0, 0xb7ac	// 9afc <_start+0x2c>
    9ae4:	1067      	lrw      	r3, 0xd480	// 9b00 <_start+0x30>
    9ae6:	eae00008 	jsri      	0x0	// from address pool at 0x9b04
    9aea:	c4004820 	lsli      	r0, r0, 0
    9aee:	eae00007 	jsri      	0x0	// from address pool at 0x9b08
    9af2:	c4004820 	lsli      	r0, r0, 0
    9af6:	0000      	.short	0x0000
    9af8:	0000d4c8 	.long	0x0000d4c8
    9afc:	0000b7ac 	.long	0x0000b7ac
    9b00:	0000d480 	.long	0x0000d480
	...

00009b10 <call_weak_fn>:
    9b10:	1421      	subi      	sp, sp, 4
    9b12:	ddee2000 	st.w      	r15, (sp, 0)
    9b16:	1047      	lrw      	r2, 0	// 9b30 <call_weak_fn+0x20>
    9b18:	3a40      	cmpnei      	r2, 0
    9b1a:	0c02      	bf      	0x9b1e	// 9b1e <call_weak_fn+0xe>
    9b1c:	7bc9      	jsr      	r2
    9b1e:	d9ee2000 	ld.w      	r15, (sp, 0)
    9b22:	1401      	addi      	sp, sp, 4
    9b24:	783c      	rts
	...

00009b34 <deregister_tm_clones>:
    9b34:	14d0      	push      	r15
    9b36:	104f      	lrw      	r2, 0x10018	// 9b70 <register_tm_clones+0x20>
    9b38:	106f      	lrw      	r3, 0x1001b	// 9b74 <register_tm_clones+0x24>
    9b3a:	60ca      	subu      	r3, r2
    9b3c:	3206      	movi      	r2, 6
    9b3e:	64c8      	cmphs      	r2, r3
    9b40:	0806      	bt      	0x9b4c	// 9b4c <deregister_tm_clones+0x18>
    9b42:	106e      	lrw      	r3, 0	// 9b78 <register_tm_clones+0x28>
    9b44:	e9030004 	bez      	r3, 0x9b4c	// 9b4c <deregister_tm_clones+0x18>
    9b48:	100a      	lrw      	r0, 0x10018	// 9b70 <register_tm_clones+0x20>
    9b4a:	7bcd      	jsr      	r3
    9b4c:	1490      	pop      	r15
	...

00009b50 <register_tm_clones>:
    9b50:	14d0      	push      	r15
    9b52:	1068      	lrw      	r3, 0x10018	// 9b70 <register_tm_clones+0x20>
    9b54:	102a      	lrw      	r1, 0x10018	// 9b7c <register_tm_clones+0x2c>
    9b56:	604e      	subu      	r1, r3
    9b58:	5122      	asri      	r1, r1, 2
    9b5a:	497f      	lsri      	r3, r1, 31
    9b5c:	604c      	addu      	r1, r3
    9b5e:	5121      	asri      	r1, r1, 1
    9b60:	e9010007 	bez      	r1, 0x9b6e	// 9b6e <register_tm_clones+0x1e>
    9b64:	1067      	lrw      	r3, 0	// 9b80 <register_tm_clones+0x30>
    9b66:	e9030004 	bez      	r3, 0x9b6e	// 9b6e <register_tm_clones+0x1e>
    9b6a:	1002      	lrw      	r0, 0x10018	// 9b70 <register_tm_clones+0x20>
    9b6c:	7bcd      	jsr      	r3
    9b6e:	1490      	pop      	r15
    9b70:	00010018 	.long	0x00010018
    9b74:	0001001b 	.long	0x0001001b
    9b78:	00000000 	.long	0x00000000
    9b7c:	00010018 	.long	0x00010018
    9b80:	00000000 	.long	0x00000000

00009b84 <__do_global_dtors_aux>:
    9b84:	14d4      	push      	r4-r7, r15
    9b86:	10f0      	lrw      	r7, 0x10018	// 9bc4 <call___do_global_dtors_aux+0x4>
    9b88:	8760      	ld.b      	r3, (r7, 0)
    9b8a:	e923001a 	bnez      	r3, 0x9bbe	// 9bbe <__do_global_dtors_aux+0x3a>
    9b8e:	106f      	lrw      	r3, 0xff14	// 9bc8 <call___do_global_dtors_aux+0x8>
    9b90:	10af      	lrw      	r5, 0xff18	// 9bcc <call___do_global_dtors_aux+0xc>
    9b92:	614e      	subu      	r5, r3
    9b94:	55a2      	asri      	r5, r5, 2
    9b96:	108f      	lrw      	r4, 0x1001c	// 9bd0 <call___do_global_dtors_aux+0x10>
    9b98:	6d8f      	mov      	r6, r3
    9b9a:	2d00      	subi      	r5, 1
    9b9c:	9460      	ld.w      	r3, (r4, 0)
    9b9e:	654c      	cmphs      	r3, r5
    9ba0:	0809      	bt      	0x9bb2	// 9bb2 <__do_global_dtors_aux+0x2e>
    9ba2:	2300      	addi      	r3, 1
    9ba4:	b460      	st.w      	r3, (r4, 0)
    9ba6:	d0660883 	ldr.w      	r3, (r6, r3 << 2)
    9baa:	7bcd      	jsr      	r3
    9bac:	9460      	ld.w      	r3, (r4, 0)
    9bae:	654c      	cmphs      	r3, r5
    9bb0:	0ff9      	bf      	0x9ba2	// 9ba2 <__do_global_dtors_aux+0x1e>
    9bb2:	e3ffffc1 	bsr      	0x9b34	// 9b34 <deregister_tm_clones>
    9bb6:	c4004820 	lsli      	r0, r0, 0
    9bba:	3301      	movi      	r3, 1
    9bbc:	a760      	st.b      	r3, (r7, 0)
    9bbe:	1494      	pop      	r4-r7, r15

00009bc0 <call___do_global_dtors_aux>:
    9bc0:	14d0      	push      	r15
    9bc2:	0000      	.short	0x0000
    9bc4:	00010018 	.long	0x00010018
    9bc8:	0000ff14 	.long	0x0000ff14
    9bcc:	0000ff18 	.long	0x0000ff18
    9bd0:	0001001c 	.long	0x0001001c
    9bd4:	00009b34 	.long	0x00009b34
    9bd8:	1490      	pop      	r15
	...

00009bdc <frame_dummy>:
    9bdc:	14d0      	push      	r15
    9bde:	1009      	lrw      	r0, 0xff1c	// 9c00 <call_frame_dummy+0x4>
    9be0:	9060      	ld.w      	r3, (r0, 0)
    9be2:	e9230007 	bnez      	r3, 0x9bf0	// 9bf0 <frame_dummy+0x14>
    9be6:	e3ffffb5 	bsr      	0x9b50	// 9b50 <register_tm_clones>
    9bea:	c4004820 	lsli      	r0, r0, 0
    9bee:	1490      	pop      	r15
    9bf0:	1066      	lrw      	r3, 0	// 9c08 <call_frame_dummy+0xc>
    9bf2:	e903fffa 	bez      	r3, 0x9be6	// 9be6 <frame_dummy+0xa>
    9bf6:	7bcd      	jsr      	r3
    9bf8:	07f7      	br      	0x9be6	// 9be6 <frame_dummy+0xa>
	...

00009bfc <call_frame_dummy>:
    9bfc:	14d0      	push      	r15
    9bfe:	0000      	.short	0x0000
    9c00:	0000ff1c 	.long	0x0000ff1c
    9c04:	00009b50 	.long	0x00009b50
    9c08:	00000000 	.long	0x00000000
    9c0c:	1490      	pop      	r15
	...

00009c10 <SNDWAV_P_GetFormat>:
#include "asoundlib.h"
 
#include "sndwav_common.h"
 
int SNDWAV_P_GetFormat(WAVContainer_t *wav, snd_pcm_format_t *snd_format)
{	
    9c10:	1421      	subi      	sp, sp, 4
    9c12:	dd0e2000 	st.w      	r8, (sp, 0)
    9c16:	6e3b      	mov      	r8, sp
    9c18:	1422      	subi      	sp, sp, 8
    9c1a:	e4681003 	subi      	r3, r8, 4
    9c1e:	b300      	st.w      	r0, (r3, 0)
    9c20:	e4681007 	subi      	r3, r8, 8
    9c24:	b320      	st.w      	r1, (r3, 0)
	if (LE_SHORT(wav->format.format) != WAV_FMT_PCM)
    9c26:	e4681003 	subi      	r3, r8, 4
    9c2a:	9360      	ld.w      	r3, (r3, 0)
    9c2c:	8b6a      	ld.h      	r3, (r3, 0x14)
    9c2e:	74cd      	zexth      	r3, r3
    9c30:	3b41      	cmpnei      	r3, 1
    9c32:	0c04      	bf      	0x9c3a	// 9c3a <SNDWAV_P_GetFormat+0x2a>
		return -1;
    9c34:	3300      	movi      	r3, 0
    9c36:	2b00      	subi      	r3, 1
    9c38:	041e      	br      	0x9c74	// 9c74 <SNDWAV_P_GetFormat+0x64>
	
	switch (LE_SHORT(wav->format.sample_length)) {
    9c3a:	e4681003 	subi      	r3, r8, 4
    9c3e:	9360      	ld.w      	r3, (r3, 0)
    9c40:	8b71      	ld.h      	r3, (r3, 0x22)
    9c42:	74cd      	zexth      	r3, r3
    9c44:	3b48      	cmpnei      	r3, 8
    9c46:	0c09      	bf      	0x9c58	// 9c58 <SNDWAV_P_GetFormat+0x48>
    9c48:	3b50      	cmpnei      	r3, 16
    9c4a:	080d      	bt      	0x9c64	// 9c64 <SNDWAV_P_GetFormat+0x54>
	case 16:
		*snd_format = SND_PCM_FORMAT_S16_LE;
    9c4c:	e4681007 	subi      	r3, r8, 8
    9c50:	9360      	ld.w      	r3, (r3, 0)
    9c52:	3202      	movi      	r2, 2
    9c54:	b340      	st.w      	r2, (r3, 0)
		break;
    9c56:	040e      	br      	0x9c72	// 9c72 <SNDWAV_P_GetFormat+0x62>
	case 8:
		*snd_format = SND_PCM_FORMAT_U8;
    9c58:	e4681007 	subi      	r3, r8, 8
    9c5c:	9360      	ld.w      	r3, (r3, 0)
    9c5e:	3201      	movi      	r2, 1
    9c60:	b340      	st.w      	r2, (r3, 0)
		break;
    9c62:	0408      	br      	0x9c72	// 9c72 <SNDWAV_P_GetFormat+0x62>
	default:
		*snd_format = SND_PCM_FORMAT_UNKNOWN;
    9c64:	e4681007 	subi      	r3, r8, 8
    9c68:	9340      	ld.w      	r2, (r3, 0)
    9c6a:	3300      	movi      	r3, 0
    9c6c:	2b00      	subi      	r3, 1
    9c6e:	b260      	st.w      	r3, (r2, 0)
		break;
    9c70:	6c00      	or      	r0, r0
	}
 
	return 0;
    9c72:	3300      	movi      	r3, 0
}
    9c74:	6c0f      	mov      	r0, r3
    9c76:	6fa3      	mov      	sp, r8
    9c78:	d90e2000 	ld.w      	r8, (sp, 0)
    9c7c:	1401      	addi      	sp, sp, 4
    9c7e:	783c      	rts

00009c80 <SNDWAV_ReadPcm>:
 
ssize_t SNDWAV_ReadPcm(SNDPCMContainer_t *sndpcm, size_t rcount)
{
    9c80:	1423      	subi      	sp, sp, 12
    9c82:	b880      	st.w      	r4, (sp, 0)
    9c84:	dd0e2001 	st.w      	r8, (sp, 0x4)
    9c88:	ddee2002 	st.w      	r15, (sp, 0x8)
    9c8c:	6e3b      	mov      	r8, sp
    9c8e:	1426      	subi      	sp, sp, 24
    9c90:	e4681013 	subi      	r3, r8, 20
    9c94:	b300      	st.w      	r0, (r3, 0)
    9c96:	e4681017 	subi      	r3, r8, 24
    9c9a:	b320      	st.w      	r1, (r3, 0)
	ssize_t r;
	size_t result = 0;
    9c9c:	e4681003 	subi      	r3, r8, 4
    9ca0:	3200      	movi      	r2, 0
    9ca2:	b340      	st.w      	r2, (r3, 0)
	size_t count = rcount;
    9ca4:	e4681007 	subi      	r3, r8, 8
    9ca8:	e4481017 	subi      	r2, r8, 24
    9cac:	9240      	ld.w      	r2, (r2, 0)
    9cae:	b340      	st.w      	r2, (r3, 0)
	uint8_t *data = sndpcm->data_buf;
    9cb0:	e468100b 	subi      	r3, r8, 12
    9cb4:	e4481013 	subi      	r2, r8, 20
    9cb8:	9240      	ld.w      	r2, (r2, 0)
    9cba:	9249      	ld.w      	r2, (r2, 0x24)
    9cbc:	b340      	st.w      	r2, (r3, 0)
 
	if (count != sndpcm->chunk_size) {
    9cbe:	e4681013 	subi      	r3, r8, 20
    9cc2:	9360      	ld.w      	r3, (r3, 0)
    9cc4:	9342      	ld.w      	r2, (r3, 0x8)
    9cc6:	e4681007 	subi      	r3, r8, 8
    9cca:	9360      	ld.w      	r3, (r3, 0)
    9ccc:	64ca      	cmpne      	r2, r3
    9cce:	0cbc      	bf      	0x9e46	// 9e46 <SNDWAV_ReadPcm+0x1c6>
		count = sndpcm->chunk_size;
    9cd0:	e4681007 	subi      	r3, r8, 8
    9cd4:	e4481013 	subi      	r2, r8, 20
    9cd8:	9240      	ld.w      	r2, (r2, 0)
    9cda:	9242      	ld.w      	r2, (r2, 0x8)
    9cdc:	b340      	st.w      	r2, (r3, 0)
	}
 
	while (count > 0) {
    9cde:	04b4      	br      	0x9e46	// 9e46 <SNDWAV_ReadPcm+0x1c6>
		r = snd_pcm_readi(sndpcm->handle, data, count);
    9ce0:	e4681013 	subi      	r3, r8, 20
    9ce4:	9360      	ld.w      	r3, (r3, 0)
    9ce6:	9300      	ld.w      	r0, (r3, 0)
    9ce8:	e488100f 	subi      	r4, r8, 16
    9cec:	e4481007 	subi      	r2, r8, 8
    9cf0:	e468100b 	subi      	r3, r8, 12
    9cf4:	9240      	ld.w      	r2, (r2, 0)
    9cf6:	9320      	ld.w      	r1, (r3, 0)
    9cf8:	eae0005c 	jsri      	0x0	// from address pool at 0x9e68
    9cfc:	c4004820 	lsli      	r0, r0, 0
    9d00:	b400      	st.w      	r0, (r4, 0)
		
		if (r == -EAGAIN || (r >= 0 && (size_t)r < count)) {
    9d02:	e468100f 	subi      	r3, r8, 16
    9d06:	9340      	ld.w      	r2, (r3, 0)
    9d08:	3300      	movi      	r3, 0
    9d0a:	2b0a      	subi      	r3, 11
    9d0c:	64ca      	cmpne      	r2, r3
    9d0e:	0c0e      	bf      	0x9d2a	// 9d2a <SNDWAV_ReadPcm+0xaa>
    9d10:	e468100f 	subi      	r3, r8, 16
    9d14:	9360      	ld.w      	r3, (r3, 0)
    9d16:	e9830016 	blz      	r3, 0x9d42	// 9d42 <SNDWAV_ReadPcm+0xc2>
    9d1a:	e468100f 	subi      	r3, r8, 16
    9d1e:	9340      	ld.w      	r2, (r3, 0)
    9d20:	e4681007 	subi      	r3, r8, 8
    9d24:	9360      	ld.w      	r3, (r3, 0)
    9d26:	64c8      	cmphs      	r2, r3
    9d28:	080d      	bt      	0x9d42	// 9d42 <SNDWAV_ReadPcm+0xc2>
			snd_pcm_wait(sndpcm->handle, 1000);
    9d2a:	e4681013 	subi      	r3, r8, 20
    9d2e:	9360      	ld.w      	r3, (r3, 0)
    9d30:	9360      	ld.w      	r3, (r3, 0)
    9d32:	ea0103e8 	movi      	r1, 1000
    9d36:	6c0f      	mov      	r0, r3
    9d38:	eae0004d 	jsri      	0x0	// from address pool at 0x9e6c
    9d3c:	c4004820 	lsli      	r0, r0, 0
    9d40:	0448      	br      	0x9dd0	// 9dd0 <SNDWAV_ReadPcm+0x150>
		} else if (r == -EPIPE) {
    9d42:	e468100f 	subi      	r3, r8, 16
    9d46:	9340      	ld.w      	r2, (r3, 0)
    9d48:	3300      	movi      	r3, 0
    9d4a:	2b1f      	subi      	r3, 32
    9d4c:	64ca      	cmpne      	r2, r3
    9d4e:	0814      	bt      	0x9d76	// 9d76 <SNDWAV_ReadPcm+0xf6>
			snd_pcm_prepare(sndpcm->handle);
    9d50:	e4681013 	subi      	r3, r8, 20
    9d54:	9360      	ld.w      	r3, (r3, 0)
    9d56:	9360      	ld.w      	r3, (r3, 0)
    9d58:	6c0f      	mov      	r0, r3
    9d5a:	eae00046 	jsri      	0x0	// from address pool at 0x9e70
    9d5e:	c4004820 	lsli      	r0, r0, 0
			fprintf(stderr, "<<<<<<<<<<<<<<< Buffer Underrun >>>>>>>>>>>>>>>/n");
    9d62:	1265      	lrw      	r3, 0	// 9e74 <SNDWAV_ReadPcm+0x1f4>
    9d64:	9360      	ld.w      	r3, (r3, 0)
    9d66:	3231      	movi      	r2, 49
    9d68:	3101      	movi      	r1, 1
    9d6a:	1204      	lrw      	r0, 0xd53c	// 9e78 <SNDWAV_ReadPcm+0x1f8>
    9d6c:	eae00044 	jsri      	0x0	// from address pool at 0x9e7c
    9d70:	c4004820 	lsli      	r0, r0, 0
    9d74:	042e      	br      	0x9dd0	// 9dd0 <SNDWAV_ReadPcm+0x150>
		} else if (r == -ESTRPIPE) {
    9d76:	e468100f 	subi      	r3, r8, 16
    9d7a:	9340      	ld.w      	r2, (r3, 0)
    9d7c:	3300      	movi      	r3, 0
    9d7e:	2b55      	subi      	r3, 86
    9d80:	64ca      	cmpne      	r2, r3
    9d82:	080b      	bt      	0x9d98	// 9d98 <SNDWAV_ReadPcm+0x118>
			fprintf(stderr, "<<<<<<<<<<<<<<< Need suspend >>>>>>>>>>>>>>>/n");
    9d84:	117c      	lrw      	r3, 0	// 9e74 <SNDWAV_ReadPcm+0x1f4>
    9d86:	9360      	ld.w      	r3, (r3, 0)
    9d88:	322e      	movi      	r2, 46
    9d8a:	3101      	movi      	r1, 1
    9d8c:	111d      	lrw      	r0, 0xd570	// 9e80 <SNDWAV_ReadPcm+0x200>
    9d8e:	eae0003c 	jsri      	0x0	// from address pool at 0x9e7c
    9d92:	c4004820 	lsli      	r0, r0, 0
    9d96:	041d      	br      	0x9dd0	// 9dd0 <SNDWAV_ReadPcm+0x150>
		} else if (r < 0) {
    9d98:	e468100f 	subi      	r3, r8, 16
    9d9c:	9360      	ld.w      	r3, (r3, 0)
    9d9e:	e9a30019 	bhsz      	r3, 0x9dd0	// 9dd0 <SNDWAV_ReadPcm+0x150>
			fprintf(stderr, "Error snd_pcm_writei: [%s]", snd_strerror(r));
    9da2:	1175      	lrw      	r3, 0	// 9e74 <SNDWAV_ReadPcm+0x1f4>
    9da4:	9380      	ld.w      	r4, (r3, 0)
    9da6:	e468100f 	subi      	r3, r8, 16
    9daa:	9300      	ld.w      	r0, (r3, 0)
    9dac:	eae00036 	jsri      	0x0	// from address pool at 0x9e84
    9db0:	c4004820 	lsli      	r0, r0, 0
    9db4:	6cc3      	mov      	r3, r0
    9db6:	6c8f      	mov      	r2, r3
    9db8:	1134      	lrw      	r1, 0xd5a0	// 9e88 <SNDWAV_ReadPcm+0x208>
    9dba:	6c13      	mov      	r0, r4
    9dbc:	eae00034 	jsri      	0x0	// from address pool at 0x9e8c
    9dc0:	c4004820 	lsli      	r0, r0, 0
			exit(-1);
    9dc4:	3000      	movi      	r0, 0
    9dc6:	2800      	subi      	r0, 1
    9dc8:	eae00032 	jsri      	0x0	// from address pool at 0x9e90
    9dcc:	c4004820 	lsli      	r0, r0, 0
    9dd0:	e4681003 	subi      	r3, r8, 4
    9dd4:	e4481003 	subi      	r2, r8, 4
    9dd8:	9240      	ld.w      	r2, (r2, 0)
    9dda:	b340      	st.w      	r2, (r3, 0)
    9ddc:	e4681007 	subi      	r3, r8, 8
    9de0:	e4481007 	subi      	r2, r8, 8
    9de4:	9240      	ld.w      	r2, (r2, 0)
    9de6:	b340      	st.w      	r2, (r3, 0)
    9de8:	e468100b 	subi      	r3, r8, 12
    9dec:	e448100b 	subi      	r2, r8, 12
    9df0:	9240      	ld.w      	r2, (r2, 0)
    9df2:	b340      	st.w      	r2, (r3, 0)
		}
		
		if (r > 0) {
    9df4:	e468100f 	subi      	r3, r8, 16
    9df8:	9360      	ld.w      	r3, (r3, 0)
    9dfa:	e9630026 	blsz      	r3, 0x9e46	// 9e46 <SNDWAV_ReadPcm+0x1c6>
			result += r;
    9dfe:	e468100f 	subi      	r3, r8, 16
    9e02:	9340      	ld.w      	r2, (r3, 0)
    9e04:	e4681003 	subi      	r3, r8, 4
    9e08:	e4281003 	subi      	r1, r8, 4
    9e0c:	9120      	ld.w      	r1, (r1, 0)
    9e0e:	6084      	addu      	r2, r1
    9e10:	b340      	st.w      	r2, (r3, 0)
			count -= r;
    9e12:	e468100f 	subi      	r3, r8, 16
    9e16:	9340      	ld.w      	r2, (r3, 0)
    9e18:	e4681007 	subi      	r3, r8, 8
    9e1c:	e4281007 	subi      	r1, r8, 8
    9e20:	9120      	ld.w      	r1, (r1, 0)
    9e22:	5949      	subu      	r2, r1, r2
    9e24:	b340      	st.w      	r2, (r3, 0)
			data += r * sndpcm->bits_per_frame / 8;
    9e26:	e4681013 	subi      	r3, r8, 20
    9e2a:	9360      	ld.w      	r3, (r3, 0)
    9e2c:	9348      	ld.w      	r2, (r3, 0x20)
    9e2e:	e468100f 	subi      	r3, r8, 16
    9e32:	9360      	ld.w      	r3, (r3, 0)
    9e34:	7cc8      	mult      	r3, r2
    9e36:	4b43      	lsri      	r2, r3, 3
    9e38:	e468100b 	subi      	r3, r8, 12
    9e3c:	e428100b 	subi      	r1, r8, 12
    9e40:	9120      	ld.w      	r1, (r1, 0)
    9e42:	6084      	addu      	r2, r1
    9e44:	b340      	st.w      	r2, (r3, 0)
	while (count > 0) {
    9e46:	e4681007 	subi      	r3, r8, 8
    9e4a:	9360      	ld.w      	r3, (r3, 0)
    9e4c:	e923ff4a 	bnez      	r3, 0x9ce0	// 9ce0 <SNDWAV_ReadPcm+0x60>
		}
	}
	return rcount;
    9e50:	e4681017 	subi      	r3, r8, 24
    9e54:	9360      	ld.w      	r3, (r3, 0)
}
    9e56:	6c0f      	mov      	r0, r3
    9e58:	6fa3      	mov      	sp, r8
    9e5a:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    9e5e:	d90e2001 	ld.w      	r8, (sp, 0x4)
    9e62:	9880      	ld.w      	r4, (sp, 0)
    9e64:	1403      	addi      	sp, sp, 12
    9e66:	783c      	rts
	...
    9e78:	0000d53c 	.long	0x0000d53c
    9e7c:	00000000 	.long	0x00000000
    9e80:	0000d570 	.long	0x0000d570
    9e84:	00000000 	.long	0x00000000
    9e88:	0000d5a0 	.long	0x0000d5a0
	...

00009e94 <SNDWAV_WritePcm>:
 
ssize_t SNDWAV_WritePcm(SNDPCMContainer_t *sndpcm, size_t wcount)
{
    9e94:	1423      	subi      	sp, sp, 12
    9e96:	b880      	st.w      	r4, (sp, 0)
    9e98:	dd0e2001 	st.w      	r8, (sp, 0x4)
    9e9c:	ddee2002 	st.w      	r15, (sp, 0x8)
    9ea0:	6e3b      	mov      	r8, sp
    9ea2:	1425      	subi      	sp, sp, 20
    9ea4:	e468100f 	subi      	r3, r8, 16
    9ea8:	b300      	st.w      	r0, (r3, 0)
    9eaa:	e4681013 	subi      	r3, r8, 20
    9eae:	b320      	st.w      	r1, (r3, 0)
	ssize_t r;
	ssize_t result = 0;
    9eb0:	e4681003 	subi      	r3, r8, 4
    9eb4:	3200      	movi      	r2, 0
    9eb6:	b340      	st.w      	r2, (r3, 0)
	uint8_t *data = sndpcm->data_buf;
    9eb8:	e4681007 	subi      	r3, r8, 8
    9ebc:	e448100f 	subi      	r2, r8, 16
    9ec0:	9240      	ld.w      	r2, (r2, 0)
    9ec2:	9249      	ld.w      	r2, (r2, 0x24)
    9ec4:	b340      	st.w      	r2, (r3, 0)
 
	if (wcount < sndpcm->chunk_size) {
    9ec6:	e468100f 	subi      	r3, r8, 16
    9eca:	9360      	ld.w      	r3, (r3, 0)
    9ecc:	9342      	ld.w      	r2, (r3, 0x8)
    9ece:	e4681013 	subi      	r3, r8, 20
    9ed2:	9360      	ld.w      	r3, (r3, 0)
    9ed4:	648c      	cmphs      	r3, r2
    9ed6:	08e0      	bt      	0xa096	// a096 <SNDWAV_WritePcm+0x202>
		snd_pcm_format_set_silence(sndpcm->format, 
    9ed8:	e468100f 	subi      	r3, r8, 16
    9edc:	9360      	ld.w      	r3, (r3, 0)
    9ede:	9304      	ld.w      	r0, (r3, 0x10)
			data + wcount * sndpcm->bits_per_frame / 8, 
    9ee0:	e468100f 	subi      	r3, r8, 16
    9ee4:	9360      	ld.w      	r3, (r3, 0)
    9ee6:	9348      	ld.w      	r2, (r3, 0x20)
    9ee8:	e4681013 	subi      	r3, r8, 20
    9eec:	9360      	ld.w      	r3, (r3, 0)
    9eee:	7cc8      	mult      	r3, r2
    9ef0:	4b63      	lsri      	r3, r3, 3
    9ef2:	e4481007 	subi      	r2, r8, 8
    9ef6:	9240      	ld.w      	r2, (r2, 0)
    9ef8:	5a2c      	addu      	r1, r2, r3
			(sndpcm->chunk_size - wcount) * sndpcm->channels);
    9efa:	e468100f 	subi      	r3, r8, 16
    9efe:	9360      	ld.w      	r3, (r3, 0)
    9f00:	9342      	ld.w      	r2, (r3, 0x8)
    9f02:	e4681013 	subi      	r3, r8, 20
    9f06:	9360      	ld.w      	r3, (r3, 0)
    9f08:	5a6d      	subu      	r3, r2, r3
    9f0a:	e448100f 	subi      	r2, r8, 16
    9f0e:	9240      	ld.w      	r2, (r2, 0)
    9f10:	8a4a      	ld.h      	r2, (r2, 0x14)
    9f12:	7489      	zexth      	r2, r2
    9f14:	7cc8      	mult      	r3, r2
		snd_pcm_format_set_silence(sndpcm->format, 
    9f16:	6c8f      	mov      	r2, r3
    9f18:	eae00068 	jsri      	0x0	// from address pool at 0xa0b8
    9f1c:	c4004820 	lsli      	r0, r0, 0
		wcount = sndpcm->chunk_size;
    9f20:	e4681013 	subi      	r3, r8, 20
    9f24:	e448100f 	subi      	r2, r8, 16
    9f28:	9240      	ld.w      	r2, (r2, 0)
    9f2a:	9242      	ld.w      	r2, (r2, 0x8)
    9f2c:	b340      	st.w      	r2, (r3, 0)
	}
	while (wcount > 0) {
    9f2e:	04b4      	br      	0xa096	// a096 <SNDWAV_WritePcm+0x202>
		r = snd_pcm_writei(sndpcm->handle, data, wcount);
    9f30:	e468100f 	subi      	r3, r8, 16
    9f34:	9360      	ld.w      	r3, (r3, 0)
    9f36:	9300      	ld.w      	r0, (r3, 0)
    9f38:	e488100b 	subi      	r4, r8, 12
    9f3c:	e4481013 	subi      	r2, r8, 20
    9f40:	e4681007 	subi      	r3, r8, 8
    9f44:	9240      	ld.w      	r2, (r2, 0)
    9f46:	9320      	ld.w      	r1, (r3, 0)
    9f48:	eae0005d 	jsri      	0x0	// from address pool at 0xa0bc
    9f4c:	c4004820 	lsli      	r0, r0, 0
    9f50:	b400      	st.w      	r0, (r4, 0)
		if (r == -EAGAIN || (r >= 0 && (size_t)r < wcount)) {
    9f52:	e468100b 	subi      	r3, r8, 12
    9f56:	9340      	ld.w      	r2, (r3, 0)
    9f58:	3300      	movi      	r3, 0
    9f5a:	2b0a      	subi      	r3, 11
    9f5c:	64ca      	cmpne      	r2, r3
    9f5e:	0c0e      	bf      	0x9f7a	// 9f7a <SNDWAV_WritePcm+0xe6>
    9f60:	e468100b 	subi      	r3, r8, 12
    9f64:	9360      	ld.w      	r3, (r3, 0)
    9f66:	e9830016 	blz      	r3, 0x9f92	// 9f92 <SNDWAV_WritePcm+0xfe>
    9f6a:	e468100b 	subi      	r3, r8, 12
    9f6e:	9340      	ld.w      	r2, (r3, 0)
    9f70:	e4681013 	subi      	r3, r8, 20
    9f74:	9360      	ld.w      	r3, (r3, 0)
    9f76:	64c8      	cmphs      	r2, r3
    9f78:	080d      	bt      	0x9f92	// 9f92 <SNDWAV_WritePcm+0xfe>
			snd_pcm_wait(sndpcm->handle, 1000);
    9f7a:	e468100f 	subi      	r3, r8, 16
    9f7e:	9360      	ld.w      	r3, (r3, 0)
    9f80:	9360      	ld.w      	r3, (r3, 0)
    9f82:	ea0103e8 	movi      	r1, 1000
    9f86:	6c0f      	mov      	r0, r3
    9f88:	eae0004e 	jsri      	0x0	// from address pool at 0xa0c0
    9f8c:	c4004820 	lsli      	r0, r0, 0
    9f90:	0448      	br      	0xa020	// a020 <SNDWAV_WritePcm+0x18c>
		} else if (r == -EPIPE) {
    9f92:	e468100b 	subi      	r3, r8, 12
    9f96:	9340      	ld.w      	r2, (r3, 0)
    9f98:	3300      	movi      	r3, 0
    9f9a:	2b1f      	subi      	r3, 32
    9f9c:	64ca      	cmpne      	r2, r3
    9f9e:	0814      	bt      	0x9fc6	// 9fc6 <SNDWAV_WritePcm+0x132>
			snd_pcm_prepare(sndpcm->handle);
    9fa0:	e468100f 	subi      	r3, r8, 16
    9fa4:	9360      	ld.w      	r3, (r3, 0)
    9fa6:	9360      	ld.w      	r3, (r3, 0)
    9fa8:	6c0f      	mov      	r0, r3
    9faa:	eae00047 	jsri      	0x0	// from address pool at 0xa0c4
    9fae:	c4004820 	lsli      	r0, r0, 0
			fprintf(stderr, "<<<<<<<<<<<<<<< Buffer Underrun >>>>>>>>>>>>>>>/n");
    9fb2:	1266      	lrw      	r3, 0	// a0c8 <SNDWAV_WritePcm+0x234>
    9fb4:	9360      	ld.w      	r3, (r3, 0)
    9fb6:	3231      	movi      	r2, 49
    9fb8:	3101      	movi      	r1, 1
    9fba:	1205      	lrw      	r0, 0xd53c	// a0cc <SNDWAV_WritePcm+0x238>
    9fbc:	eae00045 	jsri      	0x0	// from address pool at 0xa0d0
    9fc0:	c4004820 	lsli      	r0, r0, 0
    9fc4:	042e      	br      	0xa020	// a020 <SNDWAV_WritePcm+0x18c>
		} else if (r == -ESTRPIPE) {			
    9fc6:	e468100b 	subi      	r3, r8, 12
    9fca:	9340      	ld.w      	r2, (r3, 0)
    9fcc:	3300      	movi      	r3, 0
    9fce:	2b55      	subi      	r3, 86
    9fd0:	64ca      	cmpne      	r2, r3
    9fd2:	080b      	bt      	0x9fe8	// 9fe8 <SNDWAV_WritePcm+0x154>
			fprintf(stderr, "<<<<<<<<<<<<<<< Need suspend >>>>>>>>>>>>>>>/n");		
    9fd4:	117d      	lrw      	r3, 0	// a0c8 <SNDWAV_WritePcm+0x234>
    9fd6:	9360      	ld.w      	r3, (r3, 0)
    9fd8:	322e      	movi      	r2, 46
    9fda:	3101      	movi      	r1, 1
    9fdc:	111e      	lrw      	r0, 0xd570	// a0d4 <SNDWAV_WritePcm+0x240>
    9fde:	eae0003d 	jsri      	0x0	// from address pool at 0xa0d0
    9fe2:	c4004820 	lsli      	r0, r0, 0
    9fe6:	041d      	br      	0xa020	// a020 <SNDWAV_WritePcm+0x18c>
		} else if (r < 0) {
    9fe8:	e468100b 	subi      	r3, r8, 12
    9fec:	9360      	ld.w      	r3, (r3, 0)
    9fee:	e9a30019 	bhsz      	r3, 0xa020	// a020 <SNDWAV_WritePcm+0x18c>
			fprintf(stderr, "Error snd_pcm_writei: [%s]", snd_strerror(r));
    9ff2:	1176      	lrw      	r3, 0	// a0c8 <SNDWAV_WritePcm+0x234>
    9ff4:	9380      	ld.w      	r4, (r3, 0)
    9ff6:	e468100b 	subi      	r3, r8, 12
    9ffa:	9300      	ld.w      	r0, (r3, 0)
    9ffc:	eae00037 	jsri      	0x0	// from address pool at 0xa0d8
    a000:	c4004820 	lsli      	r0, r0, 0
    a004:	6cc3      	mov      	r3, r0
    a006:	6c8f      	mov      	r2, r3
    a008:	1135      	lrw      	r1, 0xd5a0	// a0dc <SNDWAV_WritePcm+0x248>
    a00a:	6c13      	mov      	r0, r4
    a00c:	eae00035 	jsri      	0x0	// from address pool at 0xa0e0
    a010:	c4004820 	lsli      	r0, r0, 0
			exit(-1);
    a014:	3000      	movi      	r0, 0
    a016:	2800      	subi      	r0, 1
    a018:	eae00033 	jsri      	0x0	// from address pool at 0xa0e4
    a01c:	c4004820 	lsli      	r0, r0, 0
    a020:	e4681013 	subi      	r3, r8, 20
    a024:	e4481013 	subi      	r2, r8, 20
    a028:	9240      	ld.w      	r2, (r2, 0)
    a02a:	b340      	st.w      	r2, (r3, 0)
    a02c:	e4681003 	subi      	r3, r8, 4
    a030:	e4481003 	subi      	r2, r8, 4
    a034:	9240      	ld.w      	r2, (r2, 0)
    a036:	b340      	st.w      	r2, (r3, 0)
    a038:	e4681007 	subi      	r3, r8, 8
    a03c:	e4481007 	subi      	r2, r8, 8
    a040:	9240      	ld.w      	r2, (r2, 0)
    a042:	b340      	st.w      	r2, (r3, 0)
		}
		if (r > 0) {
    a044:	e468100b 	subi      	r3, r8, 12
    a048:	9360      	ld.w      	r3, (r3, 0)
    a04a:	e9630026 	blsz      	r3, 0xa096	// a096 <SNDWAV_WritePcm+0x202>
			result += r;
    a04e:	e4681003 	subi      	r3, r8, 4
    a052:	e4281003 	subi      	r1, r8, 4
    a056:	e448100b 	subi      	r2, r8, 12
    a05a:	9120      	ld.w      	r1, (r1, 0)
    a05c:	9240      	ld.w      	r2, (r2, 0)
    a05e:	6084      	addu      	r2, r1
    a060:	b340      	st.w      	r2, (r3, 0)
			wcount -= r;
    a062:	e468100b 	subi      	r3, r8, 12
    a066:	9340      	ld.w      	r2, (r3, 0)
    a068:	e4681013 	subi      	r3, r8, 20
    a06c:	e4281013 	subi      	r1, r8, 20
    a070:	9120      	ld.w      	r1, (r1, 0)
    a072:	5949      	subu      	r2, r1, r2
    a074:	b340      	st.w      	r2, (r3, 0)
			data += r * sndpcm->bits_per_frame / 8;
    a076:	e468100f 	subi      	r3, r8, 16
    a07a:	9360      	ld.w      	r3, (r3, 0)
    a07c:	9348      	ld.w      	r2, (r3, 0x20)
    a07e:	e468100b 	subi      	r3, r8, 12
    a082:	9360      	ld.w      	r3, (r3, 0)
    a084:	7cc8      	mult      	r3, r2
    a086:	4b43      	lsri      	r2, r3, 3
    a088:	e4681007 	subi      	r3, r8, 8
    a08c:	e4281007 	subi      	r1, r8, 8
    a090:	9120      	ld.w      	r1, (r1, 0)
    a092:	6084      	addu      	r2, r1
    a094:	b340      	st.w      	r2, (r3, 0)
	while (wcount > 0) {
    a096:	e4681013 	subi      	r3, r8, 20
    a09a:	9360      	ld.w      	r3, (r3, 0)
    a09c:	e923ff4a 	bnez      	r3, 0x9f30	// 9f30 <SNDWAV_WritePcm+0x9c>
		}
	}
	return result;
    a0a0:	e4681003 	subi      	r3, r8, 4
    a0a4:	9360      	ld.w      	r3, (r3, 0)
}
    a0a6:	6c0f      	mov      	r0, r3
    a0a8:	6fa3      	mov      	sp, r8
    a0aa:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    a0ae:	d90e2001 	ld.w      	r8, (sp, 0x4)
    a0b2:	9880      	ld.w      	r4, (sp, 0)
    a0b4:	1403      	addi      	sp, sp, 12
    a0b6:	783c      	rts
	...
    a0cc:	0000d53c 	.long	0x0000d53c
    a0d0:	00000000 	.long	0x00000000
    a0d4:	0000d570 	.long	0x0000d570
    a0d8:	00000000 	.long	0x00000000
    a0dc:	0000d5a0 	.long	0x0000d5a0
	...

0000a0e8 <SNDWAV_SetParams>:
* 采样率(rate)：每秒钟采样次数，该次数是针对桢而言。
* 周期(period)：音频设备一次处理所需要的桢数，对于音频设备的数据访问以及音频数据的存储，都是以此为单位。
*/

int SNDWAV_SetParams(SNDPCMContainer_t *sndpcm, WAVContainer_t *wav)
{
    a0e8:	1423      	subi      	sp, sp, 12
    a0ea:	b880      	st.w      	r4, (sp, 0)
    a0ec:	dd0e2001 	st.w      	r8, (sp, 0x4)
    a0f0:	ddee2002 	st.w      	r15, (sp, 0x8)
    a0f4:	6e3b      	mov      	r8, sp
    a0f6:	1427      	subi      	sp, sp, 28
    a0f8:	e4681017 	subi      	r3, r8, 24
    a0fc:	b300      	st.w      	r0, (r3, 0)
    a0fe:	e468101b 	subi      	r3, r8, 28
    a102:	b320      	st.w      	r1, (r3, 0)
	snd_pcm_format_t format;
	uint32_t exact_rate;
	uint32_t buffer_time, period_time;
 
	/* Allocate the snd_pcm_hw_params_t structure on the stack. */
	snd_pcm_hw_params_alloca(&hwparams);
    a104:	eae00071 	jsri      	0x0	// from address pool at 0xa2c8
    a108:	c4004820 	lsli      	r0, r0, 0
    a10c:	6cc3      	mov      	r3, r0
    a10e:	2302      	addi      	r3, 3
    a110:	2302      	addi      	r3, 3
    a112:	4b62      	lsri      	r3, r3, 2
    a114:	4362      	lsli      	r3, r3, 2
    a116:	ea021000 	movi      	r2, 4096
    a11a:	64c8      	cmphs      	r2, r3
    a11c:	0807      	bt      	0xa12a	// a12a <SNDWAV_SetParams+0x42>
    a11e:	638a      	subu      	sp, r2
    a120:	ddce2000 	st.w      	sp, (sp, 0)
    a124:	60ca      	subu      	r3, r2
    a126:	64c8      	cmphs      	r2, r3
    a128:	0ffb      	bf      	0xa11e	// a11e <SNDWAV_SetParams+0x36>
    a12a:	638e      	subu      	sp, r3
    a12c:	6cfb      	mov      	r3, sp
    a12e:	2302      	addi      	r3, 3
    a130:	4b62      	lsri      	r3, r3, 2
    a132:	4362      	lsli      	r3, r3, 2
    a134:	6c8f      	mov      	r2, r3
    a136:	e4681003 	subi      	r3, r8, 4
    a13a:	b340      	st.w      	r2, (r3, 0)
    a13c:	e4681003 	subi      	r3, r8, 4
    a140:	9380      	ld.w      	r4, (r3, 0)
    a142:	eae00062 	jsri      	0x0	// from address pool at 0xa2c8
    a146:	c4004820 	lsli      	r0, r0, 0
    a14a:	6cc3      	mov      	r3, r0
    a14c:	6c8f      	mov      	r2, r3
    a14e:	3100      	movi      	r1, 0
    a150:	6c13      	mov      	r0, r4
    a152:	eae0005f 	jsri      	0x0	// from address pool at 0xa2cc
    a156:	c4004820 	lsli      	r0, r0, 0
	
	/* Init hwparams with full configuration space */
	if (snd_pcm_hw_params_any(sndpcm->handle, hwparams) < 0) {
    a15a:	e4681017 	subi      	r3, r8, 24
    a15e:	9360      	ld.w      	r3, (r3, 0)
    a160:	9340      	ld.w      	r2, (r3, 0)
    a162:	e4681003 	subi      	r3, r8, 4
    a166:	9360      	ld.w      	r3, (r3, 0)
    a168:	6c4f      	mov      	r1, r3
    a16a:	6c0b      	mov      	r0, r2
    a16c:	eae00059 	jsri      	0x0	// from address pool at 0xa2d0
    a170:	c4004820 	lsli      	r0, r0, 0
    a174:	6cc3      	mov      	r3, r0
    a176:	e9a3000c 	bhsz      	r3, 0xa18e	// a18e <SNDWAV_SetParams+0xa6>
		fprintf(stderr, "Error snd_pcm_hw_params_any/n");
    a17a:	1277      	lrw      	r3, 0	// a2d4 <SNDWAV_SetParams+0x1ec>
    a17c:	9360      	ld.w      	r3, (r3, 0)
    a17e:	321d      	movi      	r2, 29
    a180:	3101      	movi      	r1, 1
    a182:	1216      	lrw      	r0, 0xd5bc	// a2d8 <SNDWAV_SetParams+0x1f0>
    a184:	eae00056 	jsri      	0x0	// from address pool at 0xa2dc
    a188:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a18c:	05fa      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
 
	if (snd_pcm_hw_params_set_access(sndpcm->handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
    a18e:	e4681017 	subi      	r3, r8, 24
    a192:	9360      	ld.w      	r3, (r3, 0)
    a194:	9300      	ld.w      	r0, (r3, 0)
    a196:	e4681003 	subi      	r3, r8, 4
    a19a:	9360      	ld.w      	r3, (r3, 0)
    a19c:	3203      	movi      	r2, 3
    a19e:	6c4f      	mov      	r1, r3
    a1a0:	eae00050 	jsri      	0x0	// from address pool at 0xa2e0
    a1a4:	c4004820 	lsli      	r0, r0, 0
    a1a8:	6cc3      	mov      	r3, r0
    a1aa:	e9a3000c 	bhsz      	r3, 0xa1c2	// a1c2 <SNDWAV_SetParams+0xda>
		fprintf(stderr, "Error snd_pcm_hw_params_set_access/n");
    a1ae:	126a      	lrw      	r3, 0	// a2d4 <SNDWAV_SetParams+0x1ec>
    a1b0:	9360      	ld.w      	r3, (r3, 0)
    a1b2:	3224      	movi      	r2, 36
    a1b4:	3101      	movi      	r1, 1
    a1b6:	120c      	lrw      	r0, 0xd5dc	// a2e4 <SNDWAV_SetParams+0x1fc>
    a1b8:	eae00049 	jsri      	0x0	// from address pool at 0xa2dc
    a1bc:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a1c0:	05e0      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
 
	/* Set sample format */
	if (SNDWAV_P_GetFormat(wav, &format) < 0) {
    a1c2:	e4481007 	subi      	r2, r8, 8
    a1c6:	e468101b 	subi      	r3, r8, 28
    a1ca:	6c4b      	mov      	r1, r2
    a1cc:	9300      	ld.w      	r0, (r3, 0)
    a1ce:	e3fffd21 	bsr      	0x9c10	// 9c10 <SNDWAV_P_GetFormat>
    a1d2:	c4004820 	lsli      	r0, r0, 0
    a1d6:	6cc3      	mov      	r3, r0
    a1d8:	e9a3000c 	bhsz      	r3, 0xa1f0	// a1f0 <SNDWAV_SetParams+0x108>
		fprintf(stderr, "Error get_snd_pcm_format/n");
    a1dc:	117e      	lrw      	r3, 0	// a2d4 <SNDWAV_SetParams+0x1ec>
    a1de:	9360      	ld.w      	r3, (r3, 0)
    a1e0:	321a      	movi      	r2, 26
    a1e2:	3101      	movi      	r1, 1
    a1e4:	1202      	lrw      	r0, 0xd604	// a2ec <SNDWAV_SetParams+0x204>
    a1e6:	eae0003e 	jsri      	0x0	// from address pool at 0xa2dc
    a1ea:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a1ee:	05c9      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
	if (snd_pcm_hw_params_set_format(sndpcm->handle, hwparams, format) < 0) {
    a1f0:	e4681017 	subi      	r3, r8, 24
    a1f4:	9360      	ld.w      	r3, (r3, 0)
    a1f6:	9300      	ld.w      	r0, (r3, 0)
    a1f8:	e4681003 	subi      	r3, r8, 4
    a1fc:	9320      	ld.w      	r1, (r3, 0)
    a1fe:	e4681007 	subi      	r3, r8, 8
    a202:	9360      	ld.w      	r3, (r3, 0)
    a204:	6c8f      	mov      	r2, r3
    a206:	eae0003b 	jsri      	0x0	// from address pool at 0xa2f0
    a20a:	c4004820 	lsli      	r0, r0, 0
    a20e:	6cc3      	mov      	r3, r0
    a210:	e9a3000c 	bhsz      	r3, 0xa228	// a228 <SNDWAV_SetParams+0x140>
		fprintf(stderr, "Error snd_pcm_hw_params_set_format/n");
    a214:	1170      	lrw      	r3, 0	// a2d4 <SNDWAV_SetParams+0x1ec>
    a216:	9360      	ld.w      	r3, (r3, 0)
    a218:	3224      	movi      	r2, 36
    a21a:	3101      	movi      	r1, 1
    a21c:	1116      	lrw      	r0, 0xd620	// a2f4 <SNDWAV_SetParams+0x20c>
    a21e:	eae00030 	jsri      	0x0	// from address pool at 0xa2dc
    a222:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a226:	05ad      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
	sndpcm->format = format;
    a228:	e4681007 	subi      	r3, r8, 8
    a22c:	9340      	ld.w      	r2, (r3, 0)
    a22e:	e4681017 	subi      	r3, r8, 24
    a232:	9360      	ld.w      	r3, (r3, 0)
    a234:	b344      	st.w      	r2, (r3, 0x10)
 
	/* Set number of channels */
	if (snd_pcm_hw_params_set_channels(sndpcm->handle, hwparams, LE_SHORT(wav->format.channels)) < 0) {
    a236:	e4681017 	subi      	r3, r8, 24
    a23a:	9360      	ld.w      	r3, (r3, 0)
    a23c:	9300      	ld.w      	r0, (r3, 0)
    a23e:	e4681003 	subi      	r3, r8, 4
    a242:	9320      	ld.w      	r1, (r3, 0)
    a244:	e468101b 	subi      	r3, r8, 28
    a248:	9360      	ld.w      	r3, (r3, 0)
    a24a:	8b6b      	ld.h      	r3, (r3, 0x16)
    a24c:	74cd      	zexth      	r3, r3
    a24e:	6c8f      	mov      	r2, r3
    a250:	eae0002a 	jsri      	0x0	// from address pool at 0xa2f8
    a254:	c4004820 	lsli      	r0, r0, 0
    a258:	6cc3      	mov      	r3, r0
    a25a:	e9a3000c 	bhsz      	r3, 0xa272	// a272 <SNDWAV_SetParams+0x18a>
		fprintf(stderr, "Error snd_pcm_hw_params_set_channels/n");
    a25e:	107e      	lrw      	r3, 0	// a2d4 <SNDWAV_SetParams+0x1ec>
    a260:	9360      	ld.w      	r3, (r3, 0)
    a262:	3226      	movi      	r2, 38
    a264:	3101      	movi      	r1, 1
    a266:	1106      	lrw      	r0, 0xd648	// a2fc <SNDWAV_SetParams+0x214>
    a268:	eae0001d 	jsri      	0x0	// from address pool at 0xa2dc
    a26c:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a270:	0588      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
	sndpcm->channels = LE_SHORT(wav->format.channels);
    a272:	e468101b 	subi      	r3, r8, 28
    a276:	9360      	ld.w      	r3, (r3, 0)
    a278:	8b6b      	ld.h      	r3, (r3, 0x16)
    a27a:	748d      	zexth      	r2, r3
    a27c:	e4681017 	subi      	r3, r8, 24
    a280:	9360      	ld.w      	r3, (r3, 0)
    a282:	ab4a      	st.h      	r2, (r3, 0x14)
 
	/* Set sample rate. If the exact rate is not supported */
	/* by the hardware, use nearest possible rate.         */ 
	exact_rate = LE_INT(wav->format.sample_rate);
    a284:	e468101b 	subi      	r3, r8, 28
    a288:	9360      	ld.w      	r3, (r3, 0)
    a28a:	9346      	ld.w      	r2, (r3, 0x18)
    a28c:	e468100b 	subi      	r3, r8, 12
    a290:	b340      	st.w      	r2, (r3, 0)
	if (snd_pcm_hw_params_set_rate_near(sndpcm->handle, hwparams, &exact_rate, 0) < 0) {
    a292:	e4681017 	subi      	r3, r8, 24
    a296:	9360      	ld.w      	r3, (r3, 0)
    a298:	9300      	ld.w      	r0, (r3, 0)
    a29a:	e4681003 	subi      	r3, r8, 4
    a29e:	9320      	ld.w      	r1, (r3, 0)
    a2a0:	e448100b 	subi      	r2, r8, 12
    a2a4:	3300      	movi      	r3, 0
    a2a6:	eae00017 	jsri      	0x0	// from address pool at 0xa300
    a2aa:	c4004820 	lsli      	r0, r0, 0
    a2ae:	6cc3      	mov      	r3, r0
    a2b0:	e9a3002c 	bhsz      	r3, 0xa308	// a308 <SNDWAV_SetParams+0x220>
		fprintf(stderr, "Error snd_pcm_hw_params_set_rate_near/n");
    a2b4:	1068      	lrw      	r3, 0	// a2d4 <SNDWAV_SetParams+0x1ec>
    a2b6:	9360      	ld.w      	r3, (r3, 0)
    a2b8:	3227      	movi      	r2, 39
    a2ba:	3101      	movi      	r1, 1
    a2bc:	1012      	lrw      	r0, 0xd670	// a304 <SNDWAV_SetParams+0x21c>
    a2be:	eae00008 	jsri      	0x0	// from address pool at 0xa2dc
    a2c2:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a2c6:	055d      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	...
    a2d8:	0000d5bc 	.long	0x0000d5bc
	...
    a2e4:	0000d5dc 	.long	0x0000d5dc
    a2e8:	00009c10 	.long	0x00009c10
    a2ec:	0000d604 	.long	0x0000d604
    a2f0:	00000000 	.long	0x00000000
    a2f4:	0000d620 	.long	0x0000d620
    a2f8:	00000000 	.long	0x00000000
    a2fc:	0000d648 	.long	0x0000d648
    a300:	00000000 	.long	0x00000000
    a304:	0000d670 	.long	0x0000d670
	}
	if (LE_INT(wav->format.sample_rate) != exact_rate) {
    a308:	e468101b 	subi      	r3, r8, 28
    a30c:	9360      	ld.w      	r3, (r3, 0)
    a30e:	9346      	ld.w      	r2, (r3, 0x18)
    a310:	e468100b 	subi      	r3, r8, 12
    a314:	9360      	ld.w      	r3, (r3, 0)
    a316:	64ca      	cmpne      	r2, r3
    a318:	0c11      	bf      	0xa33a	// a33a <SNDWAV_SetParams+0x252>
		fprintf(stderr, "The rate %d Hz is not supported by your hardware./n ==> Using %d Hz instead./n", 
    a31a:	ea830087 	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a31e:	9300      	ld.w      	r0, (r3, 0)
    a320:	e468101b 	subi      	r3, r8, 28
    a324:	9360      	ld.w      	r3, (r3, 0)
    a326:	9346      	ld.w      	r2, (r3, 0x18)
    a328:	e468100b 	subi      	r3, r8, 12
    a32c:	9360      	ld.w      	r3, (r3, 0)
    a32e:	ea810083 	lrw      	r1, 0xd698	// a538 <SNDWAV_SetParams+0x450>
    a332:	eae00083 	jsri      	0x0	// from address pool at 0xa53c
    a336:	c4004820 	lsli      	r0, r0, 0
			LE_INT(wav->format.sample_rate), exact_rate);
	}
 
	if (snd_pcm_hw_params_get_buffer_time_max(hwparams, &buffer_time, 0) < 0) {
    a33a:	e4681003 	subi      	r3, r8, 4
    a33e:	9360      	ld.w      	r3, (r3, 0)
    a340:	e428100f 	subi      	r1, r8, 16
    a344:	3200      	movi      	r2, 0
    a346:	6c0f      	mov      	r0, r3
    a348:	eae0007e 	jsri      	0x0	// from address pool at 0xa540
    a34c:	c4004820 	lsli      	r0, r0, 0
    a350:	6cc3      	mov      	r3, r0
    a352:	e9a3000c 	bhsz      	r3, 0xa36a	// a36a <SNDWAV_SetParams+0x282>
		fprintf(stderr, "Error snd_pcm_hw_params_get_buffer_time_max/n");
    a356:	1378      	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a358:	9360      	ld.w      	r3, (r3, 0)
    a35a:	322d      	movi      	r2, 45
    a35c:	3101      	movi      	r1, 1
    a35e:	131a      	lrw      	r0, 0xd6e8	// a544 <SNDWAV_SetParams+0x45c>
    a360:	eae0007a 	jsri      	0x0	// from address pool at 0xa548
    a364:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a368:	050c      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
	if (buffer_time > 500000) buffer_time = 500000;
    a36a:	e468100f 	subi      	r3, r8, 16
    a36e:	9340      	ld.w      	r2, (r3, 0)
    a370:	ea03f424 	movi      	r3, 62500
    a374:	c4634903 	rotli      	r3, r3, 3
    a378:	648c      	cmphs      	r3, r2
    a37a:	0808      	bt      	0xa38a	// a38a <SNDWAV_SetParams+0x2a2>
    a37c:	e468100f 	subi      	r3, r8, 16
    a380:	ea02f424 	movi      	r2, 62500
    a384:	c4624902 	rotli      	r2, r2, 3
    a388:	b340      	st.w      	r2, (r3, 0)
	period_time = buffer_time / 4;
    a38a:	e468100f 	subi      	r3, r8, 16
    a38e:	9360      	ld.w      	r3, (r3, 0)
    a390:	4b42      	lsri      	r2, r3, 2
    a392:	e4681013 	subi      	r3, r8, 20
    a396:	b340      	st.w      	r2, (r3, 0)
 
	if (snd_pcm_hw_params_set_buffer_time_near(sndpcm->handle, hwparams, &buffer_time, 0) < 0) {
    a398:	e4681017 	subi      	r3, r8, 24
    a39c:	9360      	ld.w      	r3, (r3, 0)
    a39e:	9300      	ld.w      	r0, (r3, 0)
    a3a0:	e4681003 	subi      	r3, r8, 4
    a3a4:	9320      	ld.w      	r1, (r3, 0)
    a3a6:	e448100f 	subi      	r2, r8, 16
    a3aa:	3300      	movi      	r3, 0
    a3ac:	eae00068 	jsri      	0x0	// from address pool at 0xa54c
    a3b0:	c4004820 	lsli      	r0, r0, 0
    a3b4:	6cc3      	mov      	r3, r0
    a3b6:	e9a3000c 	bhsz      	r3, 0xa3ce	// a3ce <SNDWAV_SetParams+0x2e6>
		fprintf(stderr, "Error snd_pcm_hw_params_set_buffer_time_near/n");
    a3ba:	127f      	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a3bc:	9360      	ld.w      	r3, (r3, 0)
    a3be:	322e      	movi      	r2, 46
    a3c0:	3101      	movi      	r1, 1
    a3c2:	1304      	lrw      	r0, 0xd718	// a550 <SNDWAV_SetParams+0x468>
    a3c4:	eae00061 	jsri      	0x0	// from address pool at 0xa548
    a3c8:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a3cc:	04da      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
 
	if (snd_pcm_hw_params_set_period_time_near(sndpcm->handle, hwparams, &period_time, 0) < 0) {
    a3ce:	e4681017 	subi      	r3, r8, 24
    a3d2:	9360      	ld.w      	r3, (r3, 0)
    a3d4:	9300      	ld.w      	r0, (r3, 0)
    a3d6:	e4681003 	subi      	r3, r8, 4
    a3da:	9320      	ld.w      	r1, (r3, 0)
    a3dc:	e4481013 	subi      	r2, r8, 20
    a3e0:	3300      	movi      	r3, 0
    a3e2:	eae0005d 	jsri      	0x0	// from address pool at 0xa554
    a3e6:	c4004820 	lsli      	r0, r0, 0
    a3ea:	6cc3      	mov      	r3, r0
    a3ec:	e9a3000c 	bhsz      	r3, 0xa404	// a404 <SNDWAV_SetParams+0x31c>
		fprintf(stderr, "Error snd_pcm_hw_params_set_period_time_near/n");
    a3f0:	1271      	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a3f2:	9360      	ld.w      	r3, (r3, 0)
    a3f4:	322e      	movi      	r2, 46
    a3f6:	3101      	movi      	r1, 1
    a3f8:	1218      	lrw      	r0, 0xd748	// a558 <SNDWAV_SetParams+0x470>
    a3fa:	eae00054 	jsri      	0x0	// from address pool at 0xa548
    a3fe:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a402:	04bf      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
 
	/* Set hw params */
	if (snd_pcm_hw_params(sndpcm->handle, hwparams) < 0) {
    a404:	e4681017 	subi      	r3, r8, 24
    a408:	9360      	ld.w      	r3, (r3, 0)
    a40a:	9340      	ld.w      	r2, (r3, 0)
    a40c:	e4681003 	subi      	r3, r8, 4
    a410:	9360      	ld.w      	r3, (r3, 0)
    a412:	6c4f      	mov      	r1, r3
    a414:	6c0b      	mov      	r0, r2
    a416:	eae00052 	jsri      	0x0	// from address pool at 0xa55c
    a41a:	c4004820 	lsli      	r0, r0, 0
    a41e:	6cc3      	mov      	r3, r0
    a420:	e9a3000c 	bhsz      	r3, 0xa438	// a438 <SNDWAV_SetParams+0x350>
		fprintf(stderr, "Error snd_pcm_hw_params(handle, params)/n");
    a424:	1264      	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a426:	9360      	ld.w      	r3, (r3, 0)
    a428:	3229      	movi      	r2, 41
    a42a:	3101      	movi      	r1, 1
    a42c:	120d      	lrw      	r0, 0xd778	// a560 <SNDWAV_SetParams+0x478>
    a42e:	eae00047 	jsri      	0x0	// from address pool at 0xa548
    a432:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a436:	04a5      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
 
	snd_pcm_hw_params_get_period_size(hwparams, &sndpcm->chunk_size, 0);	
    a438:	e4681003 	subi      	r3, r8, 4
    a43c:	9300      	ld.w      	r0, (r3, 0)
    a43e:	e4681017 	subi      	r3, r8, 24
    a442:	9360      	ld.w      	r3, (r3, 0)
    a444:	2307      	addi      	r3, 8
    a446:	3200      	movi      	r2, 0
    a448:	6c4f      	mov      	r1, r3
    a44a:	eae00047 	jsri      	0x0	// from address pool at 0xa564
    a44e:	c4004820 	lsli      	r0, r0, 0
	snd_pcm_hw_params_get_buffer_size(hwparams, &sndpcm->buffer_size);
    a452:	e4681003 	subi      	r3, r8, 4
    a456:	9340      	ld.w      	r2, (r3, 0)
    a458:	e4681017 	subi      	r3, r8, 24
    a45c:	9360      	ld.w      	r3, (r3, 0)
    a45e:	230b      	addi      	r3, 12
    a460:	6c4f      	mov      	r1, r3
    a462:	6c0b      	mov      	r0, r2
    a464:	eae00041 	jsri      	0x0	// from address pool at 0xa568
    a468:	c4004820 	lsli      	r0, r0, 0
	if (sndpcm->chunk_size == sndpcm->buffer_size) {		
    a46c:	e4681017 	subi      	r3, r8, 24
    a470:	9360      	ld.w      	r3, (r3, 0)
    a472:	9342      	ld.w      	r2, (r3, 0x8)
    a474:	e4681017 	subi      	r3, r8, 24
    a478:	9360      	ld.w      	r3, (r3, 0)
    a47a:	9363      	ld.w      	r3, (r3, 0xc)
    a47c:	64ca      	cmpne      	r2, r3
    a47e:	0811      	bt      	0xa4a0	// a4a0 <SNDWAV_SetParams+0x3b8>
		fprintf(stderr, ("Can't use period equal to buffer size (%lu == %lu)/n"), sndpcm->chunk_size, sndpcm->buffer_size);		
    a480:	116d      	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a482:	9300      	ld.w      	r0, (r3, 0)
    a484:	e4681017 	subi      	r3, r8, 24
    a488:	9360      	ld.w      	r3, (r3, 0)
    a48a:	9342      	ld.w      	r2, (r3, 0x8)
    a48c:	e4681017 	subi      	r3, r8, 24
    a490:	9360      	ld.w      	r3, (r3, 0)
    a492:	9363      	ld.w      	r3, (r3, 0xc)
    a494:	1136      	lrw      	r1, 0xd7a4	// a56c <SNDWAV_SetParams+0x484>
    a496:	eae0002a 	jsri      	0x0	// from address pool at 0xa53c
    a49a:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a49e:	0471      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
	}
 
	sndpcm->bits_per_sample = snd_pcm_format_physical_width(format);
    a4a0:	e4681007 	subi      	r3, r8, 8
    a4a4:	9360      	ld.w      	r3, (r3, 0)
    a4a6:	6c0f      	mov      	r0, r3
    a4a8:	eae00032 	jsri      	0x0	// from address pool at 0xa570
    a4ac:	c4004820 	lsli      	r0, r0, 0
    a4b0:	6cc3      	mov      	r3, r0
    a4b2:	6c8f      	mov      	r2, r3
    a4b4:	e4681017 	subi      	r3, r8, 24
    a4b8:	9360      	ld.w      	r3, (r3, 0)
    a4ba:	b347      	st.w      	r2, (r3, 0x1c)
	sndpcm->bits_per_frame = sndpcm->bits_per_sample * LE_SHORT(wav->format.channels);
    a4bc:	e4681017 	subi      	r3, r8, 24
    a4c0:	9360      	ld.w      	r3, (r3, 0)
    a4c2:	9367      	ld.w      	r3, (r3, 0x1c)
    a4c4:	e448101b 	subi      	r2, r8, 28
    a4c8:	9240      	ld.w      	r2, (r2, 0)
    a4ca:	8a4b      	ld.h      	r2, (r2, 0x16)
    a4cc:	7489      	zexth      	r2, r2
    a4ce:	7c8c      	mult      	r2, r3
    a4d0:	e4681017 	subi      	r3, r8, 24
    a4d4:	9360      	ld.w      	r3, (r3, 0)
    a4d6:	b348      	st.w      	r2, (r3, 0x20)
	
	sndpcm->chunk_bytes = sndpcm->chunk_size * sndpcm->bits_per_frame / 8;
    a4d8:	e4681017 	subi      	r3, r8, 24
    a4dc:	9360      	ld.w      	r3, (r3, 0)
    a4de:	9342      	ld.w      	r2, (r3, 0x8)
    a4e0:	e4681017 	subi      	r3, r8, 24
    a4e4:	9360      	ld.w      	r3, (r3, 0)
    a4e6:	9368      	ld.w      	r3, (r3, 0x20)
    a4e8:	7cc8      	mult      	r3, r2
    a4ea:	4b43      	lsri      	r2, r3, 3
    a4ec:	e4681017 	subi      	r3, r8, 24
    a4f0:	9360      	ld.w      	r3, (r3, 0)
    a4f2:	b346      	st.w      	r2, (r3, 0x18)
 
	/* Allocate audio data buffer */
	sndpcm->data_buf = (uint8_t *)malloc(sndpcm->chunk_bytes);
    a4f4:	e4681017 	subi      	r3, r8, 24
    a4f8:	9360      	ld.w      	r3, (r3, 0)
    a4fa:	9366      	ld.w      	r3, (r3, 0x18)
    a4fc:	6c0f      	mov      	r0, r3
    a4fe:	eae0001e 	jsri      	0x0	// from address pool at 0xa574
    a502:	c4004820 	lsli      	r0, r0, 0
    a506:	6cc3      	mov      	r3, r0
    a508:	6c8f      	mov      	r2, r3
    a50a:	e4681017 	subi      	r3, r8, 24
    a50e:	9360      	ld.w      	r3, (r3, 0)
    a510:	b349      	st.w      	r2, (r3, 0x24)
	if (!sndpcm->data_buf) {
    a512:	e4681017 	subi      	r3, r8, 24
    a516:	9360      	ld.w      	r3, (r3, 0)
    a518:	9369      	ld.w      	r3, (r3, 0x24)
    a51a:	e9230031 	bnez      	r3, 0xa57c	// a57c <SNDWAV_SetParams+0x494>
		fprintf(stderr, "Error malloc: [data_buf]/n");
    a51e:	1066      	lrw      	r3, 0	// a534 <SNDWAV_SetParams+0x44c>
    a520:	9360      	ld.w      	r3, (r3, 0)
    a522:	321a      	movi      	r2, 26
    a524:	3101      	movi      	r1, 1
    a526:	1015      	lrw      	r0, 0xd7dc	// a578 <SNDWAV_SetParams+0x490>
    a528:	eae00008 	jsri      	0x0	// from address pool at 0xa548
    a52c:	c4004820 	lsli      	r0, r0, 0
		goto ERR_SET_PARAMS;
    a530:	0428      	br      	0xa580	// a580 <SNDWAV_SetParams+0x498>
    a532:	0000      	.short	0x0000
    a534:	00000000 	.long	0x00000000
    a538:	0000d698 	.long	0x0000d698
	...
    a544:	0000d6e8 	.long	0x0000d6e8
	...
    a550:	0000d718 	.long	0x0000d718
    a554:	00000000 	.long	0x00000000
    a558:	0000d748 	.long	0x0000d748
    a55c:	00000000 	.long	0x00000000
    a560:	0000d778 	.long	0x0000d778
	...
    a56c:	0000d7a4 	.long	0x0000d7a4
	...
    a578:	0000d7dc 	.long	0x0000d7dc
	}
 
	return 0;
    a57c:	3300      	movi      	r3, 0
    a57e:	0403      	br      	0xa584	// a584 <SNDWAV_SetParams+0x49c>
 
ERR_SET_PARAMS:
	return -1;
    a580:	3300      	movi      	r3, 0
    a582:	2b00      	subi      	r3, 1
}
    a584:	6c0f      	mov      	r0, r3
    a586:	6fa3      	mov      	sp, r8
    a588:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    a58c:	d90e2001 	ld.w      	r8, (sp, 0x4)
    a590:	9880      	ld.w      	r4, (sp, 0)
    a592:	1403      	addi      	sp, sp, 12
    a594:	783c      	rts
	...

0000a598 <WAV_P_FmtString>:
#include "wav_parser.h"
 
#define WAV_PRINT_MSG
 
char *WAV_P_FmtString(uint16_t fmt)
{
    a598:	1421      	subi      	sp, sp, 4
    a59a:	dd0e2000 	st.w      	r8, (sp, 0)
    a59e:	6e3b      	mov      	r8, sp
    a5a0:	1421      	subi      	sp, sp, 4
    a5a2:	6c83      	mov      	r2, r0
    a5a4:	e4681001 	subi      	r3, r8, 2
    a5a8:	ab40      	st.h      	r2, (r3, 0)
	switch (fmt) {
    a5aa:	e4681001 	subi      	r3, r8, 2
    a5ae:	8b60      	ld.h      	r3, (r3, 0)
    a5b0:	74cd      	zexth      	r3, r3
    a5b2:	3b43      	cmpnei      	r3, 3
    a5b4:	0c0f      	bf      	0xa5d2	// a5d2 <WAV_P_FmtString+0x3a>
    a5b6:	3b23      	cmplti      	r3, 4
    a5b8:	0c04      	bf      	0xa5c0	// a5c0 <WAV_P_FmtString+0x28>
    a5ba:	3b41      	cmpnei      	r3, 1
    a5bc:	0c09      	bf      	0xa5ce	// a5ce <WAV_P_FmtString+0x36>
		break;
	case WAV_FMT_EXTENSIBLE:
		return "EXTENSIBLE";
		break;
	default:
		break;
    a5be:	0410      	br      	0xa5de	// a5de <WAV_P_FmtString+0x46>
	switch (fmt) {
    a5c0:	eb430092 	cmpnei      	r3, 146
    a5c4:	0c09      	bf      	0xa5d6	// a5d6 <WAV_P_FmtString+0x3e>
    a5c6:	eb43fffe 	cmpnei      	r3, 65534
    a5ca:	0c08      	bf      	0xa5da	// a5da <WAV_P_FmtString+0x42>
		break;
    a5cc:	0409      	br      	0xa5de	// a5de <WAV_P_FmtString+0x46>
		return "PCM";
    a5ce:	1068      	lrw      	r3, 0xd7f8	// a5ec <WAV_P_FmtString+0x54>
    a5d0:	0408      	br      	0xa5e0	// a5e0 <WAV_P_FmtString+0x48>
		return "IEEE FLOAT";
    a5d2:	1068      	lrw      	r3, 0xd7fc	// a5f0 <WAV_P_FmtString+0x58>
    a5d4:	0406      	br      	0xa5e0	// a5e0 <WAV_P_FmtString+0x48>
		return "DOLBY AC3 SPDIF";
    a5d6:	1068      	lrw      	r3, 0xd808	// a5f4 <WAV_P_FmtString+0x5c>
    a5d8:	0404      	br      	0xa5e0	// a5e0 <WAV_P_FmtString+0x48>
		return "EXTENSIBLE";
    a5da:	1068      	lrw      	r3, 0xd818	// a5f8 <WAV_P_FmtString+0x60>
    a5dc:	0402      	br      	0xa5e0	// a5e0 <WAV_P_FmtString+0x48>
	}
 
	return "NON Support Fmt";
    a5de:	1068      	lrw      	r3, 0xd824	// a5fc <WAV_P_FmtString+0x64>
}
    a5e0:	6c0f      	mov      	r0, r3
    a5e2:	6fa3      	mov      	sp, r8
    a5e4:	d90e2000 	ld.w      	r8, (sp, 0)
    a5e8:	1401      	addi      	sp, sp, 4
    a5ea:	783c      	rts
    a5ec:	0000d7f8 	.long	0x0000d7f8
    a5f0:	0000d7fc 	.long	0x0000d7fc
    a5f4:	0000d808 	.long	0x0000d808
    a5f8:	0000d818 	.long	0x0000d818
    a5fc:	0000d824 	.long	0x0000d824

0000a600 <WAV_P_PrintHeader>:
 
void WAV_P_PrintHeader(WAVContainer_t *container)
{
    a600:	1422      	subi      	sp, sp, 8
    a602:	dd0e2000 	st.w      	r8, (sp, 0)
    a606:	ddee2001 	st.w      	r15, (sp, 0x4)
    a60a:	6e3b      	mov      	r8, sp
    a60c:	1422      	subi      	sp, sp, 8
    a60e:	e4681003 	subi      	r3, r8, 4
    a612:	b300      	st.w      	r0, (r3, 0)
	printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/n");
    a614:	ea800088 	lrw      	r0, 0xd834	// a834 <WAV_P_PrintHeader+0x234>
    a618:	eae00088 	jsri      	0x0	// from address pool at 0xa838
    a61c:	c4004820 	lsli      	r0, r0, 0
	printf("/n");
    a620:	ea800087 	lrw      	r0, 0xd878	// a83c <WAV_P_PrintHeader+0x23c>
    a624:	eae00085 	jsri      	0x0	// from address pool at 0xa838
    a628:	c4004820 	lsli      	r0, r0, 0
	
	printf("File Magic:         [%c%c%c%c]/n", 
		(char)(container->header.magic), 
    a62c:	e4681003 	subi      	r3, r8, 4
    a630:	9360      	ld.w      	r3, (r3, 0)
    a632:	9360      	ld.w      	r3, (r3, 0)
    a634:	74cc      	zextb      	r3, r3
	printf("File Magic:         [%c%c%c%c]/n", 
    a636:	6c4f      	mov      	r1, r3
		(char)(container->header.magic>>8), 
    a638:	e4681003 	subi      	r3, r8, 4
    a63c:	9360      	ld.w      	r3, (r3, 0)
    a63e:	9360      	ld.w      	r3, (r3, 0)
    a640:	4b68      	lsri      	r3, r3, 8
    a642:	74cc      	zextb      	r3, r3
	printf("File Magic:         [%c%c%c%c]/n", 
    a644:	6c8f      	mov      	r2, r3
		(char)(container->header.magic>>16), 
    a646:	e4681003 	subi      	r3, r8, 4
    a64a:	9360      	ld.w      	r3, (r3, 0)
    a64c:	9360      	ld.w      	r3, (r3, 0)
    a64e:	4b70      	lsri      	r3, r3, 16
    a650:	74cc      	zextb      	r3, r3
	printf("File Magic:         [%c%c%c%c]/n", 
    a652:	6c0f      	mov      	r0, r3
		(char)(container->header.magic>>24));
    a654:	e4681003 	subi      	r3, r8, 4
    a658:	9360      	ld.w      	r3, (r3, 0)
    a65a:	9360      	ld.w      	r3, (r3, 0)
    a65c:	4b78      	lsri      	r3, r3, 24
    a65e:	74cc      	zextb      	r3, r3
	printf("File Magic:         [%c%c%c%c]/n", 
    a660:	b860      	st.w      	r3, (sp, 0)
    a662:	6cc3      	mov      	r3, r0
    a664:	1317      	lrw      	r0, 0xd87c	// a840 <WAV_P_PrintHeader+0x240>
    a666:	eae00075 	jsri      	0x0	// from address pool at 0xa838
    a66a:	c4004820 	lsli      	r0, r0, 0
	printf("File Length:        [%d]/n", container->header.length);
    a66e:	e4681003 	subi      	r3, r8, 4
    a672:	9360      	ld.w      	r3, (r3, 0)
    a674:	9361      	ld.w      	r3, (r3, 0x4)
    a676:	6c4f      	mov      	r1, r3
    a678:	1313      	lrw      	r0, 0xd8a0	// a844 <WAV_P_PrintHeader+0x244>
    a67a:	eae00070 	jsri      	0x0	// from address pool at 0xa838
    a67e:	c4004820 	lsli      	r0, r0, 0
	printf("File Type:          [%c%c%c%c]/n",
		(char)(container->header.type), 
    a682:	e4681003 	subi      	r3, r8, 4
    a686:	9360      	ld.w      	r3, (r3, 0)
    a688:	9362      	ld.w      	r3, (r3, 0x8)
    a68a:	74cc      	zextb      	r3, r3
	printf("File Type:          [%c%c%c%c]/n",
    a68c:	6c4f      	mov      	r1, r3
		(char)(container->header.type>>8), 
    a68e:	e4681003 	subi      	r3, r8, 4
    a692:	9360      	ld.w      	r3, (r3, 0)
    a694:	9362      	ld.w      	r3, (r3, 0x8)
    a696:	4b68      	lsri      	r3, r3, 8
    a698:	74cc      	zextb      	r3, r3
	printf("File Type:          [%c%c%c%c]/n",
    a69a:	6c8f      	mov      	r2, r3
		(char)(container->header.type>>16), 
    a69c:	e4681003 	subi      	r3, r8, 4
    a6a0:	9360      	ld.w      	r3, (r3, 0)
    a6a2:	9362      	ld.w      	r3, (r3, 0x8)
    a6a4:	4b70      	lsri      	r3, r3, 16
    a6a6:	74cc      	zextb      	r3, r3
	printf("File Type:          [%c%c%c%c]/n",
    a6a8:	6c0f      	mov      	r0, r3
		(char)(container->header.type>>24));
    a6aa:	e4681003 	subi      	r3, r8, 4
    a6ae:	9360      	ld.w      	r3, (r3, 0)
    a6b0:	9362      	ld.w      	r3, (r3, 0x8)
    a6b2:	4b78      	lsri      	r3, r3, 24
    a6b4:	74cc      	zextb      	r3, r3
	printf("File Type:          [%c%c%c%c]/n",
    a6b6:	b860      	st.w      	r3, (sp, 0)
    a6b8:	6cc3      	mov      	r3, r0
    a6ba:	1304      	lrw      	r0, 0xd8bc	// a848 <WAV_P_PrintHeader+0x248>
    a6bc:	eae0005f 	jsri      	0x0	// from address pool at 0xa838
    a6c0:	c4004820 	lsli      	r0, r0, 0
		
	printf("/n");
    a6c4:	121e      	lrw      	r0, 0xd878	// a83c <WAV_P_PrintHeader+0x23c>
    a6c6:	eae0005d 	jsri      	0x0	// from address pool at 0xa838
    a6ca:	c4004820 	lsli      	r0, r0, 0
 
	printf("Fmt Magic:          [%c%c%c%c]/n",
		(char)(container->format.magic), 
    a6ce:	e4681003 	subi      	r3, r8, 4
    a6d2:	9360      	ld.w      	r3, (r3, 0)
    a6d4:	9363      	ld.w      	r3, (r3, 0xc)
    a6d6:	74cc      	zextb      	r3, r3
	printf("Fmt Magic:          [%c%c%c%c]/n",
    a6d8:	6c4f      	mov      	r1, r3
		(char)(container->format.magic>>8), 
    a6da:	e4681003 	subi      	r3, r8, 4
    a6de:	9360      	ld.w      	r3, (r3, 0)
    a6e0:	9363      	ld.w      	r3, (r3, 0xc)
    a6e2:	4b68      	lsri      	r3, r3, 8
    a6e4:	74cc      	zextb      	r3, r3
	printf("Fmt Magic:          [%c%c%c%c]/n",
    a6e6:	6c8f      	mov      	r2, r3
		(char)(container->format.magic>>16), 
    a6e8:	e4681003 	subi      	r3, r8, 4
    a6ec:	9360      	ld.w      	r3, (r3, 0)
    a6ee:	9363      	ld.w      	r3, (r3, 0xc)
    a6f0:	4b70      	lsri      	r3, r3, 16
    a6f2:	74cc      	zextb      	r3, r3
	printf("Fmt Magic:          [%c%c%c%c]/n",
    a6f4:	6c0f      	mov      	r0, r3
		(char)(container->format.magic>>24));
    a6f6:	e4681003 	subi      	r3, r8, 4
    a6fa:	9360      	ld.w      	r3, (r3, 0)
    a6fc:	9363      	ld.w      	r3, (r3, 0xc)
    a6fe:	4b78      	lsri      	r3, r3, 24
    a700:	74cc      	zextb      	r3, r3
	printf("Fmt Magic:          [%c%c%c%c]/n",
    a702:	b860      	st.w      	r3, (sp, 0)
    a704:	6cc3      	mov      	r3, r0
    a706:	1212      	lrw      	r0, 0xd8e0	// a84c <WAV_P_PrintHeader+0x24c>
    a708:	eae0004c 	jsri      	0x0	// from address pool at 0xa838
    a70c:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Size:           [%d]/n", container->format.fmt_size);
    a710:	e4681003 	subi      	r3, r8, 4
    a714:	9360      	ld.w      	r3, (r3, 0)
    a716:	9364      	ld.w      	r3, (r3, 0x10)
    a718:	6c4f      	mov      	r1, r3
    a71a:	120e      	lrw      	r0, 0xd904	// a850 <WAV_P_PrintHeader+0x250>
    a71c:	eae00047 	jsri      	0x0	// from address pool at 0xa838
    a720:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Format:         [%s]/n", WAV_P_FmtString(container->format.format));
    a724:	e4681003 	subi      	r3, r8, 4
    a728:	9360      	ld.w      	r3, (r3, 0)
    a72a:	8b6a      	ld.h      	r3, (r3, 0x14)
    a72c:	74cd      	zexth      	r3, r3
    a72e:	6c0f      	mov      	r0, r3
    a730:	e3ffff34 	bsr      	0xa598	// a598 <WAV_P_FmtString>
    a734:	c4004820 	lsli      	r0, r0, 0
    a738:	6cc3      	mov      	r3, r0
    a73a:	6c4f      	mov      	r1, r3
    a73c:	1207      	lrw      	r0, 0xd920	// a858 <WAV_P_PrintHeader+0x258>
    a73e:	eae0003f 	jsri      	0x0	// from address pool at 0xa838
    a742:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Channels:       [%d]/n", container->format.channels);
    a746:	e4681003 	subi      	r3, r8, 4
    a74a:	9360      	ld.w      	r3, (r3, 0)
    a74c:	8b6b      	ld.h      	r3, (r3, 0x16)
    a74e:	74cd      	zexth      	r3, r3
    a750:	6c4f      	mov      	r1, r3
    a752:	1203      	lrw      	r0, 0xd93c	// a85c <WAV_P_PrintHeader+0x25c>
    a754:	eae00039 	jsri      	0x0	// from address pool at 0xa838
    a758:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Sample_rate:    [%d](HZ)/n", container->format.sample_rate);
    a75c:	e4681003 	subi      	r3, r8, 4
    a760:	9360      	ld.w      	r3, (r3, 0)
    a762:	9366      	ld.w      	r3, (r3, 0x18)
    a764:	6c4f      	mov      	r1, r3
    a766:	111f      	lrw      	r0, 0xd958	// a860 <WAV_P_PrintHeader+0x260>
    a768:	eae00034 	jsri      	0x0	// from address pool at 0xa838
    a76c:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Bytes_p_second: [%d]/n", container->format.bytes_p_second);
    a770:	e4681003 	subi      	r3, r8, 4
    a774:	9360      	ld.w      	r3, (r3, 0)
    a776:	9367      	ld.w      	r3, (r3, 0x1c)
    a778:	6c4f      	mov      	r1, r3
    a77a:	111b      	lrw      	r0, 0xd978	// a864 <WAV_P_PrintHeader+0x264>
    a77c:	eae0002f 	jsri      	0x0	// from address pool at 0xa838
    a780:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Blocks_align:   [%d]/n", container->format.blocks_align);
    a784:	e4681003 	subi      	r3, r8, 4
    a788:	9360      	ld.w      	r3, (r3, 0)
    a78a:	8b70      	ld.h      	r3, (r3, 0x20)
    a78c:	74cd      	zexth      	r3, r3
    a78e:	6c4f      	mov      	r1, r3
    a790:	1116      	lrw      	r0, 0xd994	// a868 <WAV_P_PrintHeader+0x268>
    a792:	eae0002a 	jsri      	0x0	// from address pool at 0xa838
    a796:	c4004820 	lsli      	r0, r0, 0
	printf("Fmt Sample_length:  [%d]/n", container->format.sample_length);
    a79a:	e4681003 	subi      	r3, r8, 4
    a79e:	9360      	ld.w      	r3, (r3, 0)
    a7a0:	8b71      	ld.h      	r3, (r3, 0x22)
    a7a2:	74cd      	zexth      	r3, r3
    a7a4:	6c4f      	mov      	r1, r3
    a7a6:	1112      	lrw      	r0, 0xd9b0	// a86c <WAV_P_PrintHeader+0x26c>
    a7a8:	eae00024 	jsri      	0x0	// from address pool at 0xa838
    a7ac:	c4004820 	lsli      	r0, r0, 0
	
	printf("/n");
    a7b0:	1103      	lrw      	r0, 0xd878	// a83c <WAV_P_PrintHeader+0x23c>
    a7b2:	eae00022 	jsri      	0x0	// from address pool at 0xa838
    a7b6:	c4004820 	lsli      	r0, r0, 0
 
	printf("Chunk Type:         [%c%c%c%c]/n",
		(char)(container->chunk.type), 
    a7ba:	e4681003 	subi      	r3, r8, 4
    a7be:	9360      	ld.w      	r3, (r3, 0)
    a7c0:	9369      	ld.w      	r3, (r3, 0x24)
    a7c2:	74cc      	zextb      	r3, r3
	printf("Chunk Type:         [%c%c%c%c]/n",
    a7c4:	6c4f      	mov      	r1, r3
		(char)(container->chunk.type>>8), 
    a7c6:	e4681003 	subi      	r3, r8, 4
    a7ca:	9360      	ld.w      	r3, (r3, 0)
    a7cc:	9369      	ld.w      	r3, (r3, 0x24)
    a7ce:	4b68      	lsri      	r3, r3, 8
    a7d0:	74cc      	zextb      	r3, r3
	printf("Chunk Type:         [%c%c%c%c]/n",
    a7d2:	6c8f      	mov      	r2, r3
		(char)(container->chunk.type>>16), 
    a7d4:	e4681003 	subi      	r3, r8, 4
    a7d8:	9360      	ld.w      	r3, (r3, 0)
    a7da:	9369      	ld.w      	r3, (r3, 0x24)
    a7dc:	4b70      	lsri      	r3, r3, 16
    a7de:	74cc      	zextb      	r3, r3
	printf("Chunk Type:         [%c%c%c%c]/n",
    a7e0:	6c0f      	mov      	r0, r3
		(char)(container->chunk.type>>24));
    a7e2:	e4681003 	subi      	r3, r8, 4
    a7e6:	9360      	ld.w      	r3, (r3, 0)
    a7e8:	9369      	ld.w      	r3, (r3, 0x24)
    a7ea:	4b78      	lsri      	r3, r3, 24
    a7ec:	74cc      	zextb      	r3, r3
	printf("Chunk Type:         [%c%c%c%c]/n",
    a7ee:	b860      	st.w      	r3, (sp, 0)
    a7f0:	6cc3      	mov      	r3, r0
    a7f2:	1100      	lrw      	r0, 0xd9cc	// a870 <WAV_P_PrintHeader+0x270>
    a7f4:	eae00011 	jsri      	0x0	// from address pool at 0xa838
    a7f8:	c4004820 	lsli      	r0, r0, 0
	printf("Chunk Length:       [%d]/n", container->chunk.length);
    a7fc:	e4681003 	subi      	r3, r8, 4
    a800:	9360      	ld.w      	r3, (r3, 0)
    a802:	936a      	ld.w      	r3, (r3, 0x28)
    a804:	6c4f      	mov      	r1, r3
    a806:	101c      	lrw      	r0, 0xd9f0	// a874 <WAV_P_PrintHeader+0x274>
    a808:	eae0000c 	jsri      	0x0	// from address pool at 0xa838
    a80c:	c4004820 	lsli      	r0, r0, 0
	
	printf("/n");
    a810:	100b      	lrw      	r0, 0xd878	// a83c <WAV_P_PrintHeader+0x23c>
    a812:	eae0000a 	jsri      	0x0	// from address pool at 0xa838
    a816:	c4004820 	lsli      	r0, r0, 0
	printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++/n");
    a81a:	1007      	lrw      	r0, 0xd834	// a834 <WAV_P_PrintHeader+0x234>
    a81c:	eae00007 	jsri      	0x0	// from address pool at 0xa838
    a820:	c4004820 	lsli      	r0, r0, 0
}
    a824:	6c00      	or      	r0, r0
    a826:	6fa3      	mov      	sp, r8
    a828:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    a82c:	d90e2000 	ld.w      	r8, (sp, 0)
    a830:	1402      	addi      	sp, sp, 8
    a832:	783c      	rts
    a834:	0000d834 	.long	0x0000d834
    a838:	00000000 	.long	0x00000000
    a83c:	0000d878 	.long	0x0000d878
    a840:	0000d87c 	.long	0x0000d87c
    a844:	0000d8a0 	.long	0x0000d8a0
    a848:	0000d8bc 	.long	0x0000d8bc
    a84c:	0000d8e0 	.long	0x0000d8e0
    a850:	0000d904 	.long	0x0000d904
    a854:	0000a598 	.long	0x0000a598
    a858:	0000d920 	.long	0x0000d920
    a85c:	0000d93c 	.long	0x0000d93c
    a860:	0000d958 	.long	0x0000d958
    a864:	0000d978 	.long	0x0000d978
    a868:	0000d994 	.long	0x0000d994
    a86c:	0000d9b0 	.long	0x0000d9b0
    a870:	0000d9cc 	.long	0x0000d9cc
    a874:	0000d9f0 	.long	0x0000d9f0

0000a878 <WAV_P_CheckValid>:
 
int WAV_P_CheckValid(WAVContainer_t *container)
{
    a878:	1422      	subi      	sp, sp, 8
    a87a:	dd0e2000 	st.w      	r8, (sp, 0)
    a87e:	ddee2001 	st.w      	r15, (sp, 0x4)
    a882:	6e3b      	mov      	r8, sp
    a884:	1421      	subi      	sp, sp, 4
    a886:	e4681003 	subi      	r3, r8, 4
    a88a:	b300      	st.w      	r0, (r3, 0)
	if (container->header.magic != WAV_RIFF ||
    a88c:	e4681003 	subi      	r3, r8, 4
    a890:	9360      	ld.w      	r3, (r3, 0)
    a892:	9340      	ld.w      	r2, (r3, 0)
    a894:	1161      	lrw      	r3, 0x46464952	// a918 <WAV_P_CheckValid+0xa0>
    a896:	64ca      	cmpne      	r2, r3
    a898:	082a      	bt      	0xa8ec	// a8ec <WAV_P_CheckValid+0x74>
		container->header.type != WAV_WAVE ||
    a89a:	e4681003 	subi      	r3, r8, 4
    a89e:	9360      	ld.w      	r3, (r3, 0)
    a8a0:	9342      	ld.w      	r2, (r3, 0x8)
	if (container->header.magic != WAV_RIFF ||
    a8a2:	107f      	lrw      	r3, 0x45564157	// a91c <WAV_P_CheckValid+0xa4>
    a8a4:	64ca      	cmpne      	r2, r3
    a8a6:	0823      	bt      	0xa8ec	// a8ec <WAV_P_CheckValid+0x74>
		container->format.magic != WAV_FMT ||
    a8a8:	e4681003 	subi      	r3, r8, 4
    a8ac:	9360      	ld.w      	r3, (r3, 0)
    a8ae:	9343      	ld.w      	r2, (r3, 0xc)
		container->header.type != WAV_WAVE ||
    a8b0:	107c      	lrw      	r3, 0x20746d66	// a920 <WAV_P_CheckValid+0xa8>
    a8b2:	64ca      	cmpne      	r2, r3
    a8b4:	081c      	bt      	0xa8ec	// a8ec <WAV_P_CheckValid+0x74>
		container->format.fmt_size != LE_INT(16) ||
    a8b6:	e4681003 	subi      	r3, r8, 4
    a8ba:	9360      	ld.w      	r3, (r3, 0)
    a8bc:	9364      	ld.w      	r3, (r3, 0x10)
		container->format.magic != WAV_FMT ||
    a8be:	3b50      	cmpnei      	r3, 16
    a8c0:	0816      	bt      	0xa8ec	// a8ec <WAV_P_CheckValid+0x74>
		(container->format.channels != LE_SHORT(1) && container->format.channels != LE_SHORT(2)) ||
    a8c2:	e4681003 	subi      	r3, r8, 4
    a8c6:	9360      	ld.w      	r3, (r3, 0)
    a8c8:	8b6b      	ld.h      	r3, (r3, 0x16)
    a8ca:	74cd      	zexth      	r3, r3
		container->format.fmt_size != LE_INT(16) ||
    a8cc:	3b41      	cmpnei      	r3, 1
    a8ce:	0c08      	bf      	0xa8de	// a8de <WAV_P_CheckValid+0x66>
		(container->format.channels != LE_SHORT(1) && container->format.channels != LE_SHORT(2)) ||
    a8d0:	e4681003 	subi      	r3, r8, 4
    a8d4:	9360      	ld.w      	r3, (r3, 0)
    a8d6:	8b6b      	ld.h      	r3, (r3, 0x16)
    a8d8:	74cd      	zexth      	r3, r3
    a8da:	3b42      	cmpnei      	r3, 2
    a8dc:	0808      	bt      	0xa8ec	// a8ec <WAV_P_CheckValid+0x74>
		container->chunk.type != WAV_DATA) {
    a8de:	e4681003 	subi      	r3, r8, 4
    a8e2:	9360      	ld.w      	r3, (r3, 0)
    a8e4:	9349      	ld.w      	r2, (r3, 0x24)
		(container->format.channels != LE_SHORT(1) && container->format.channels != LE_SHORT(2)) ||
    a8e6:	1070      	lrw      	r3, 0x61746164	// a924 <WAV_P_CheckValid+0xac>
    a8e8:	64ca      	cmpne      	r2, r3
    a8ea:	0c0d      	bf      	0xa904	// a904 <WAV_P_CheckValid+0x8c>
		
		fprintf(stderr, "non standard wav file./n");
    a8ec:	106f      	lrw      	r3, 0	// a928 <WAV_P_CheckValid+0xb0>
    a8ee:	9360      	ld.w      	r3, (r3, 0)
    a8f0:	3218      	movi      	r2, 24
    a8f2:	3101      	movi      	r1, 1
    a8f4:	100e      	lrw      	r0, 0xda0c	// a92c <WAV_P_CheckValid+0xb4>
    a8f6:	eae0000f 	jsri      	0x0	// from address pool at 0xa930
    a8fa:	c4004820 	lsli      	r0, r0, 0
		return -1;
    a8fe:	3300      	movi      	r3, 0
    a900:	2b00      	subi      	r3, 1
    a902:	0402      	br      	0xa906	// a906 <WAV_P_CheckValid+0x8e>
	}
 
	return 0;
    a904:	3300      	movi      	r3, 0
}
    a906:	6c0f      	mov      	r0, r3
    a908:	6fa3      	mov      	sp, r8
    a90a:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    a90e:	d90e2000 	ld.w      	r8, (sp, 0)
    a912:	1402      	addi      	sp, sp, 8
    a914:	783c      	rts
    a916:	0000      	.short	0x0000
    a918:	46464952 	.long	0x46464952
    a91c:	45564157 	.long	0x45564157
    a920:	20746d66 	.long	0x20746d66
    a924:	61746164 	.long	0x61746164
    a928:	00000000 	.long	0x00000000
    a92c:	0000da0c 	.long	0x0000da0c
    a930:	00000000 	.long	0x00000000

0000a934 <WAV_ReadHeader>:
*	WAVChunkHeader_t chunk;//数据大小
* } WAVContainer_t;
*/

int WAV_ReadHeader(int fd, WAVContainer_t *container)
{
    a934:	1422      	subi      	sp, sp, 8
    a936:	dd0e2000 	st.w      	r8, (sp, 0)
    a93a:	ddee2001 	st.w      	r15, (sp, 0x4)
    a93e:	6e3b      	mov      	r8, sp
    a940:	1422      	subi      	sp, sp, 8
    a942:	e4681003 	subi      	r3, r8, 4
    a946:	b300      	st.w      	r0, (r3, 0)
    a948:	e4681007 	subi      	r3, r8, 8
    a94c:	b320      	st.w      	r1, (r3, 0)
	assert((fd >=0) && container);
    a94e:	e4681003 	subi      	r3, r8, 4
    a952:	9360      	ld.w      	r3, (r3, 0)
    a954:	e9830007 	blz      	r3, 0xa962	// a962 <WAV_ReadHeader+0x2e>
    a958:	e4681007 	subi      	r3, r8, 8
    a95c:	9360      	ld.w      	r3, (r3, 0)
    a95e:	e923000a 	bnez      	r3, 0xa972	// a972 <WAV_ReadHeader+0x3e>
    a962:	1170      	lrw      	r3, 0xda88	// aa20 <WAV_ReadHeader+0xec>
    a964:	326c      	movi      	r2, 108
    a966:	1130      	lrw      	r1, 0xda28	// aa24 <WAV_ReadHeader+0xf0>
    a968:	1110      	lrw      	r0, 0xda40	// aa28 <WAV_ReadHeader+0xf4>
    a96a:	eae00031 	jsri      	0x0	// from address pool at 0xaa2c
    a96e:	c4004820 	lsli      	r0, r0, 0
 
	if (read(fd, &container->header, sizeof(container->header)) != sizeof(container->header) || 
    a972:	e4681007 	subi      	r3, r8, 8
    a976:	9320      	ld.w      	r1, (r3, 0)
    a978:	e4681003 	subi      	r3, r8, 4
    a97c:	320c      	movi      	r2, 12
    a97e:	9300      	ld.w      	r0, (r3, 0)
    a980:	eae0002c 	jsri      	0x0	// from address pool at 0xaa30
    a984:	c4004820 	lsli      	r0, r0, 0
    a988:	6cc3      	mov      	r3, r0
    a98a:	3b4c      	cmpnei      	r3, 12
    a98c:	0821      	bt      	0xa9ce	// a9ce <WAV_ReadHeader+0x9a>
		read(fd, &container->format, sizeof(container->format)) != sizeof(container->format) ||
    a98e:	e4681007 	subi      	r3, r8, 8
    a992:	9360      	ld.w      	r3, (r3, 0)
    a994:	e423000b 	addi      	r1, r3, 12
    a998:	e4681003 	subi      	r3, r8, 4
    a99c:	3218      	movi      	r2, 24
    a99e:	9300      	ld.w      	r0, (r3, 0)
    a9a0:	eae00024 	jsri      	0x0	// from address pool at 0xaa30
    a9a4:	c4004820 	lsli      	r0, r0, 0
    a9a8:	6cc3      	mov      	r3, r0
	if (read(fd, &container->header, sizeof(container->header)) != sizeof(container->header) || 
    a9aa:	3b58      	cmpnei      	r3, 24
    a9ac:	0811      	bt      	0xa9ce	// a9ce <WAV_ReadHeader+0x9a>
		read(fd, &container->chunk, sizeof(container->chunk)) != sizeof(container->chunk)) {
    a9ae:	e4681007 	subi      	r3, r8, 8
    a9b2:	9360      	ld.w      	r3, (r3, 0)
    a9b4:	e4230023 	addi      	r1, r3, 36
    a9b8:	e4681003 	subi      	r3, r8, 4
    a9bc:	3208      	movi      	r2, 8
    a9be:	9300      	ld.w      	r0, (r3, 0)
    a9c0:	eae0001c 	jsri      	0x0	// from address pool at 0xaa30
    a9c4:	c4004820 	lsli      	r0, r0, 0
    a9c8:	6cc3      	mov      	r3, r0
		read(fd, &container->format, sizeof(container->format)) != sizeof(container->format) ||
    a9ca:	3b48      	cmpnei      	r3, 8
    a9cc:	0c0d      	bf      	0xa9e6	// a9e6 <WAV_ReadHeader+0xb2>
 
		fprintf(stderr, "Error WAV_ReadHeader/n");
    a9ce:	107a      	lrw      	r3, 0	// aa34 <WAV_ReadHeader+0x100>
    a9d0:	9360      	ld.w      	r3, (r3, 0)
    a9d2:	3216      	movi      	r2, 22
    a9d4:	3101      	movi      	r1, 1
    a9d6:	1019      	lrw      	r0, 0xda58	// aa38 <WAV_ReadHeader+0x104>
    a9d8:	eae00019 	jsri      	0x0	// from address pool at 0xaa3c
    a9dc:	c4004820 	lsli      	r0, r0, 0
		return -1;
    a9e0:	3300      	movi      	r3, 0
    a9e2:	2b00      	subi      	r3, 1
    a9e4:	0416      	br      	0xaa10	// aa10 <WAV_ReadHeader+0xdc>
	}
/*
* 对音频文件头部保存的信息进行有效性检查check
*/ 
	if (WAV_P_CheckValid(container) < 0)
    a9e6:	e4681007 	subi      	r3, r8, 8
    a9ea:	9300      	ld.w      	r0, (r3, 0)
    a9ec:	e3ffff46 	bsr      	0xa878	// a878 <WAV_P_CheckValid>
    a9f0:	c4004820 	lsli      	r0, r0, 0
    a9f4:	6cc3      	mov      	r3, r0
    a9f6:	e9a30005 	bhsz      	r3, 0xaa00	// aa00 <WAV_ReadHeader+0xcc>
		return -1;
    a9fa:	3300      	movi      	r3, 0
    a9fc:	2b00      	subi      	r3, 1
    a9fe:	0409      	br      	0xaa10	// aa10 <WAV_ReadHeader+0xdc>

/*
* 将音频文件的头部信息打印出来
*/	
#ifdef WAV_PRINT_MSG
	WAV_P_PrintHeader(container);
    aa00:	e4681007 	subi      	r3, r8, 8
    aa04:	9300      	ld.w      	r0, (r3, 0)
    aa06:	e3fffdfd 	bsr      	0xa600	// a600 <WAV_P_PrintHeader>
    aa0a:	c4004820 	lsli      	r0, r0, 0
#endif
 
	return 0;
    aa0e:	3300      	movi      	r3, 0
}
    aa10:	6c0f      	mov      	r0, r3
    aa12:	6fa3      	mov      	sp, r8
    aa14:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    aa18:	d90e2000 	ld.w      	r8, (sp, 0)
    aa1c:	1402      	addi      	sp, sp, 8
    aa1e:	783c      	rts
    aa20:	0000da88 	.long	0x0000da88
    aa24:	0000da28 	.long	0x0000da28
    aa28:	0000da40 	.long	0x0000da40
	...
    aa38:	0000da58 	.long	0x0000da58
    aa3c:	00000000 	.long	0x00000000
    aa40:	0000a878 	.long	0x0000a878
    aa44:	0000a600 	.long	0x0000a600

0000aa48 <WAV_WriteHeader>:
 
int WAV_WriteHeader(int fd, WAVContainer_t *container)
{
    aa48:	1422      	subi      	sp, sp, 8
    aa4a:	dd0e2000 	st.w      	r8, (sp, 0)
    aa4e:	ddee2001 	st.w      	r15, (sp, 0x4)
    aa52:	6e3b      	mov      	r8, sp
    aa54:	1422      	subi      	sp, sp, 8
    aa56:	e4681003 	subi      	r3, r8, 4
    aa5a:	b300      	st.w      	r0, (r3, 0)
    aa5c:	e4681007 	subi      	r3, r8, 8
    aa60:	b320      	st.w      	r1, (r3, 0)
	assert((fd >=0) && container);
    aa62:	e4681003 	subi      	r3, r8, 4
    aa66:	9360      	ld.w      	r3, (r3, 0)
    aa68:	e9830007 	blz      	r3, 0xaa76	// aa76 <WAV_WriteHeader+0x2e>
    aa6c:	e4681007 	subi      	r3, r8, 8
    aa70:	9360      	ld.w      	r3, (r3, 0)
    aa72:	e923000a 	bnez      	r3, 0xaa86	// aa86 <WAV_WriteHeader+0x3e>
    aa76:	1170      	lrw      	r3, 0xda98	// ab34 <WAV_WriteHeader+0xec>
    aa78:	3287      	movi      	r2, 135
    aa7a:	1130      	lrw      	r1, 0xda28	// ab38 <WAV_WriteHeader+0xf0>
    aa7c:	1110      	lrw      	r0, 0xda40	// ab3c <WAV_WriteHeader+0xf4>
    aa7e:	eae00031 	jsri      	0x0	// from address pool at 0xab40
    aa82:	c4004820 	lsli      	r0, r0, 0
	
	if (WAV_P_CheckValid(container) < 0)
    aa86:	e4681007 	subi      	r3, r8, 8
    aa8a:	9300      	ld.w      	r0, (r3, 0)
    aa8c:	e3fffef6 	bsr      	0xa878	// a878 <WAV_P_CheckValid>
    aa90:	c4004820 	lsli      	r0, r0, 0
    aa94:	6cc3      	mov      	r3, r0
    aa96:	e9a30005 	bhsz      	r3, 0xaaa0	// aaa0 <WAV_WriteHeader+0x58>
		return -1;
    aa9a:	3300      	movi      	r3, 0
    aa9c:	2b00      	subi      	r3, 1
    aa9e:	0443      	br      	0xab24	// ab24 <WAV_WriteHeader+0xdc>
 
	if (write(fd, &container->header, sizeof(container->header)) != sizeof(container->header) || 
    aaa0:	e4681007 	subi      	r3, r8, 8
    aaa4:	9320      	ld.w      	r1, (r3, 0)
    aaa6:	e4681003 	subi      	r3, r8, 4
    aaaa:	320c      	movi      	r2, 12
    aaac:	9300      	ld.w      	r0, (r3, 0)
    aaae:	eae00027 	jsri      	0x0	// from address pool at 0xab48
    aab2:	c4004820 	lsli      	r0, r0, 0
    aab6:	6cc3      	mov      	r3, r0
    aab8:	3b4c      	cmpnei      	r3, 12
    aaba:	0821      	bt      	0xaafc	// aafc <WAV_WriteHeader+0xb4>
		write(fd, &container->format, sizeof(container->format)) != sizeof(container->format) ||
    aabc:	e4681007 	subi      	r3, r8, 8
    aac0:	9360      	ld.w      	r3, (r3, 0)
    aac2:	e423000b 	addi      	r1, r3, 12
    aac6:	e4681003 	subi      	r3, r8, 4
    aaca:	3218      	movi      	r2, 24
    aacc:	9300      	ld.w      	r0, (r3, 0)
    aace:	eae0001f 	jsri      	0x0	// from address pool at 0xab48
    aad2:	c4004820 	lsli      	r0, r0, 0
    aad6:	6cc3      	mov      	r3, r0
	if (write(fd, &container->header, sizeof(container->header)) != sizeof(container->header) || 
    aad8:	3b58      	cmpnei      	r3, 24
    aada:	0811      	bt      	0xaafc	// aafc <WAV_WriteHeader+0xb4>
		write(fd, &container->chunk, sizeof(container->chunk)) != sizeof(container->chunk)) {
    aadc:	e4681007 	subi      	r3, r8, 8
    aae0:	9360      	ld.w      	r3, (r3, 0)
    aae2:	e4230023 	addi      	r1, r3, 36
    aae6:	e4681003 	subi      	r3, r8, 4
    aaea:	3208      	movi      	r2, 8
    aaec:	9300      	ld.w      	r0, (r3, 0)
    aaee:	eae00017 	jsri      	0x0	// from address pool at 0xab48
    aaf2:	c4004820 	lsli      	r0, r0, 0
    aaf6:	6cc3      	mov      	r3, r0
		write(fd, &container->format, sizeof(container->format)) != sizeof(container->format) ||
    aaf8:	3b48      	cmpnei      	r3, 8
    aafa:	0c0d      	bf      	0xab14	// ab14 <WAV_WriteHeader+0xcc>
		
		fprintf(stderr, "Error WAV_WriteHeader/n");
    aafc:	1074      	lrw      	r3, 0	// ab4c <WAV_WriteHeader+0x104>
    aafe:	9360      	ld.w      	r3, (r3, 0)
    ab00:	3217      	movi      	r2, 23
    ab02:	3101      	movi      	r1, 1
    ab04:	1013      	lrw      	r0, 0xda70	// ab50 <WAV_WriteHeader+0x108>
    ab06:	eae00014 	jsri      	0x0	// from address pool at 0xab54
    ab0a:	c4004820 	lsli      	r0, r0, 0
		return -1;
    ab0e:	3300      	movi      	r3, 0
    ab10:	2b00      	subi      	r3, 1
    ab12:	0409      	br      	0xab24	// ab24 <WAV_WriteHeader+0xdc>
	}
 
#ifdef WAV_PRINT_MSG
	WAV_P_PrintHeader(container);
    ab14:	e4681007 	subi      	r3, r8, 8
    ab18:	9300      	ld.w      	r0, (r3, 0)
    ab1a:	e3fffd73 	bsr      	0xa600	// a600 <WAV_P_PrintHeader>
    ab1e:	c4004820 	lsli      	r0, r0, 0
#endif
 
	return 0;
    ab22:	3300      	movi      	r3, 0

    ab24:	6c0f      	mov      	r0, r3
    ab26:	6fa3      	mov      	sp, r8
    ab28:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    ab2c:	d90e2000 	ld.w      	r8, (sp, 0)
    ab30:	1402      	addi      	sp, sp, 8
    ab32:	783c      	rts
    ab34:	0000da98 	.long	0x0000da98
    ab38:	0000da28 	.long	0x0000da28
    ab3c:	0000da40 	.long	0x0000da40
    ab40:	00000000 	.long	0x00000000
    ab44:	0000a878 	.long	0x0000a878
	...
    ab50:	0000da70 	.long	0x0000da70
    ab54:	00000000 	.long	0x00000000
    ab58:	0000a600 	.long	0x0000a600

0000ab5c <phy_to_virtual>:

} wav_header;

static int fd_mem;
void* phy_to_virtual(phys_addr_t phy_start,unsigned int phy_size)
{
    ab5c:	1423      	subi      	sp, sp, 12
    ab5e:	b880      	st.w      	r4, (sp, 0)
    ab60:	dd0e2001 	st.w      	r8, (sp, 0x4)
    ab64:	ddee2002 	st.w      	r15, (sp, 0x8)
    ab68:	6e3b      	mov      	r8, sp
    ab6a:	1425      	subi      	sp, sp, 20
    ab6c:	e4681007 	subi      	r3, r8, 8
    ab70:	b300      	st.w      	r0, (r3, 0)
    ab72:	e468100b 	subi      	r3, r8, 12
    ab76:	b320      	st.w      	r1, (r3, 0)

	void *vir_addr = NULL;
    ab78:	e4681003 	subi      	r3, r8, 4
    ab7c:	3200      	movi      	r2, 0
    ab7e:	b340      	st.w      	r2, (r3, 0)
	// Open the /dev/mem Device
	fd_mem = open(mem_dev,O_RDWR | O_SYNC);
    ab80:	ea011002 	movi      	r1, 4098
    ab84:	39b4      	bseti      	r1, r1, 20
    ab86:	110f      	lrw      	r0, 0xdaa8	// ac40 <phy_to_virtual+0xe4>
    ab88:	eae0002f 	jsri      	0x0	// from address pool at 0xac44
    ab8c:	c4004820 	lsli      	r0, r0, 0
    ab90:	6c83      	mov      	r2, r0
    ab92:	116e      	lrw      	r3, 0x10020	// ac48 <phy_to_virtual+0xec>
    ab94:	b340      	st.w      	r2, (r3, 0)
	if (fd_mem < 0) 
    ab96:	116d      	lrw      	r3, 0x10020	// ac48 <phy_to_virtual+0xec>
    ab98:	9360      	ld.w      	r3, (r3, 0)
    ab9a:	e9a3000d 	bhsz      	r3, 0xabb4	// abb4 <phy_to_virtual+0x58>
	{
		printf("Open /dev/mem Device Fail \r\n");
    ab9e:	110c      	lrw      	r0, 0xdab4	// ac4c <phy_to_virtual+0xf0>
    aba0:	eae0002c 	jsri      	0x0	// from address pool at 0xac50
    aba4:	c4004820 	lsli      	r0, r0, 0
		exit(-1);
    aba8:	3000      	movi      	r0, 0
    abaa:	2800      	subi      	r0, 1
    abac:	eae0002a 	jsri      	0x0	// from address pool at 0xac54
    abb0:	c4004820 	lsli      	r0, r0, 0
	}

	printf("phy_to_virtual:phy_start:0x%x ,phy_size:%d\n",phy_start,phy_size);
    abb4:	e448100b 	subi      	r2, r8, 12
    abb8:	e4681007 	subi      	r3, r8, 8
    abbc:	9240      	ld.w      	r2, (r2, 0)
    abbe:	9320      	ld.w      	r1, (r3, 0)
    abc0:	1106      	lrw      	r0, 0xdad0	// ac58 <phy_to_virtual+0xfc>
    abc2:	eae00027 	jsri      	0x0	// from address pool at 0xac5c
    abc6:	c4004820 	lsli      	r0, r0, 0
	//share memory map
	vir_addr = mmap(NULL, phy_size,PROT_READ | PROT_WRITE,MAP_SHARED, fd_mem, phy_start);
    abca:	1160      	lrw      	r3, 0x10020	// ac48 <phy_to_virtual+0xec>
    abcc:	9360      	ld.w      	r3, (r3, 0)
    abce:	e4481007 	subi      	r2, r8, 8
    abd2:	9240      	ld.w      	r2, (r2, 0)
    abd4:	e4881003 	subi      	r4, r8, 4
    abd8:	e428100b 	subi      	r1, r8, 12
    abdc:	b841      	st.w      	r2, (sp, 0x4)
    abde:	b860      	st.w      	r3, (sp, 0)
    abe0:	3301      	movi      	r3, 1
    abe2:	3203      	movi      	r2, 3
    abe4:	9120      	ld.w      	r1, (r1, 0)
    abe6:	3000      	movi      	r0, 0
    abe8:	eae0001e 	jsri      	0x0	// from address pool at 0xac60
    abec:	c4004820 	lsli      	r0, r0, 0
    abf0:	b400      	st.w      	r0, (r4, 0)
	if (vir_addr == MAP_FAILED)
    abf2:	e4681003 	subi      	r3, r8, 4
    abf6:	9340      	ld.w      	r2, (r3, 0)
    abf8:	3300      	movi      	r3, 0
    abfa:	2b00      	subi      	r3, 1
    abfc:	64ca      	cmpne      	r2, r3
    abfe:	080c      	bt      	0xac16	// ac16 <phy_to_virtual+0xba>
	{
		printf("Mmap Share Memory Fail \r\n");
    ac00:	1019      	lrw      	r0, 0xdafc	// ac64 <phy_to_virtual+0x108>
    ac02:	eae00014 	jsri      	0x0	// from address pool at 0xac50
    ac06:	c4004820 	lsli      	r0, r0, 0
		exit(-1);
    ac0a:	3000      	movi      	r0, 0
    ac0c:	2800      	subi      	r0, 1
    ac0e:	eae00012 	jsri      	0x0	// from address pool at 0xac54
    ac12:	c4004820 	lsli      	r0, r0, 0
	}
	printf("vir_addr = 0x%x\n",vir_addr);
    ac16:	e4681003 	subi      	r3, r8, 4
    ac1a:	9320      	ld.w      	r1, (r3, 0)
    ac1c:	1013      	lrw      	r0, 0xdb18	// ac68 <phy_to_virtual+0x10c>
    ac1e:	eae00010 	jsri      	0x0	// from address pool at 0xac5c
    ac22:	c4004820 	lsli      	r0, r0, 0
	return vir_addr;
    ac26:	e4681003 	subi      	r3, r8, 4
    ac2a:	9360      	ld.w      	r3, (r3, 0)
}
    ac2c:	6c0f      	mov      	r0, r3
    ac2e:	6fa3      	mov      	sp, r8
    ac30:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    ac34:	d90e2001 	ld.w      	r8, (sp, 0x4)
    ac38:	9880      	ld.w      	r4, (sp, 0)
    ac3a:	1403      	addi      	sp, sp, 12
    ac3c:	783c      	rts
    ac3e:	0000      	.short	0x0000
    ac40:	0000daa8 	.long	0x0000daa8
    ac44:	00000000 	.long	0x00000000
    ac48:	00010020 	.long	0x00010020
    ac4c:	0000dab4 	.long	0x0000dab4
	...
    ac58:	0000dad0 	.long	0x0000dad0
	...
    ac64:	0000dafc 	.long	0x0000dafc
    ac68:	0000db18 	.long	0x0000db18

0000ac6c <ck860_set_parameter_audio>:
static short BitsPerSample;
static int CHANNELS;

/* 设置好参数后，返回pcm设备句柄 */
snd_pcm_t* ck860_set_parameter_audio(GV_IPCM_MSG_S* pMsg_SetParameter)
{
    ac6c:	1423      	subi      	sp, sp, 12
    ac6e:	b880      	st.w      	r4, (sp, 0)
    ac70:	dd0e2001 	st.w      	r8, (sp, 0x4)
    ac74:	ddee2002 	st.w      	r15, (sp, 0x8)
    ac78:	6e3b      	mov      	r8, sp
    ac7a:	142b      	subi      	sp, sp, 44
    ac7c:	e468102b 	subi      	r3, r8, 44
    ac80:	b300      	st.w      	r0, (r3, 0)

	printf("ck860 set pcm device parameter!\n");
    ac82:	ea800095 	lrw      	r0, 0xdb2c	// aed4 <ck860_set_parameter_audio+0x268>
    ac86:	eae00095 	jsri      	0x0	// from address pool at 0xaed8
    ac8a:	c4004820 	lsli      	r0, r0, 0

/* 对保存数据的物理地址映射进线程 */
	struct WAV_HEADER* ck860_wav_header = (struct WAV_HEADER*)phy_to_virtual(pMsg_SetParameter->msg_body->start,pMsg_SetParameter->msg_body->size);
    ac8e:	e468102b 	subi      	r3, r8, 44
    ac92:	9360      	ld.w      	r3, (r3, 0)
    ac94:	9361      	ld.w      	r3, (r3, 0x4)
    ac96:	9340      	ld.w      	r2, (r3, 0)
    ac98:	e468102b 	subi      	r3, r8, 44
    ac9c:	9360      	ld.w      	r3, (r3, 0)
    ac9e:	9361      	ld.w      	r3, (r3, 0x4)
    aca0:	9361      	ld.w      	r3, (r3, 0x4)
    aca2:	e4881007 	subi      	r4, r8, 8
    aca6:	6c4f      	mov      	r1, r3
    aca8:	6c0b      	mov      	r0, r2
    acaa:	e3ffff59 	bsr      	0xab5c	// ab5c <phy_to_virtual>
    acae:	c4004820 	lsli      	r0, r0, 0
    acb2:	b400      	st.w      	r0, (r4, 0)
	int	  ret;
	int   resolution;
	snd_pcm_t*		handle; 	   //PCI设备句柄
	snd_pcm_hw_params_t* 	 params;//硬件信息和PCM流配置
	unsigned int 	  val;
	int				  dir=0;
    acb4:	e4681027 	subi      	r3, r8, 40
    acb8:	3200      	movi      	r2, 0
    acba:	b340      	st.w      	r2, (r3, 0)
	char   *buffer;
	int channels=ck860_wav_header->wChannels;
    acbc:	e4681007 	subi      	r3, r8, 8
    acc0:	9360      	ld.w      	r3, (r3, 0)
    acc2:	8b6b      	ld.h      	r3, (r3, 0x16)
    acc4:	748f      	sexth      	r2, r3
    acc6:	e468100b 	subi      	r3, r8, 12
    acca:	b340      	st.w      	r2, (r3, 0)
	CHANNELS = ck860_wav_header->wChannels;
    accc:	e4681007 	subi      	r3, r8, 8
    acd0:	9360      	ld.w      	r3, (r3, 0)
    acd2:	8b6b      	ld.h      	r3, (r3, 0x16)
    acd4:	74cf      	sexth      	r3, r3
    acd6:	6c8f      	mov      	r2, r3
    acd8:	ea830082 	lrw      	r3, 0x10030	// aee0 <ck860_set_parameter_audio+0x274>
    acdc:	b340      	st.w      	r2, (r3, 0)
	int frequency=ck860_wav_header->nSamplesPersec;
    acde:	e468100f 	subi      	r3, r8, 16
    ace2:	e4481007 	subi      	r2, r8, 8
    ace6:	9240      	ld.w      	r2, (r2, 0)
    ace8:	9246      	ld.w      	r2, (r2, 0x18)
    acea:	b340      	st.w      	r2, (r3, 0)
	int bit=ck860_wav_header->wBitsPerSample;
    acec:	e4681007 	subi      	r3, r8, 8
    acf0:	9360      	ld.w      	r3, (r3, 0)
    acf2:	8b71      	ld.h      	r3, (r3, 0x22)
    acf4:	748f      	sexth      	r2, r3
    acf6:	e4681013 	subi      	r3, r8, 20
    acfa:	b340      	st.w      	r2, (r3, 0)
	//int datablock=ck860_wav_header->wBlockAlign;
	
	datablock_byavs=ck860_wav_header->wBlockAlign;
    acfc:	e4681007 	subi      	r3, r8, 8
    ad00:	9360      	ld.w      	r3, (r3, 0)
    ad02:	8b70      	ld.h      	r3, (r3, 0x20)
    ad04:	74cf      	sexth      	r3, r3
    ad06:	6c8f      	mov      	r2, r3
    ad08:	1377      	lrw      	r3, 0x10028	// aee4 <ck860_set_parameter_audio+0x278>
    ad0a:	b340      	st.w      	r2, (r3, 0)
	BitsPerSample = ck860_wav_header->wBitsPerSample;
    ad0c:	e4681007 	subi      	r3, r8, 8
    ad10:	9360      	ld.w      	r3, (r3, 0)
    ad12:	8b71      	ld.h      	r3, (r3, 0x22)
    ad14:	748f      	sexth      	r2, r3
    ad16:	1375      	lrw      	r3, 0x1002c	// aee8 <ck860_set_parameter_audio+0x27c>
    ad18:	ab40      	st.h      	r2, (r3, 0)
	//	 unsigned char ch[100];  //用来存储wav文件的头信息

	printf("datablock: %d\n",ck860_wav_header->wBlockAlign);
    ad1a:	e4681007 	subi      	r3, r8, 8
    ad1e:	9360      	ld.w      	r3, (r3, 0)
    ad20:	8b70      	ld.h      	r3, (r3, 0x20)
    ad22:	74cf      	sexth      	r3, r3
    ad24:	6c4f      	mov      	r1, r3
    ad26:	1312      	lrw      	r0, 0xdb4c	// aeec <ck860_set_parameter_audio+0x280>
    ad28:	eae00072 	jsri      	0x0	// from address pool at 0xaef0
    ad2c:	c4004820 	lsli      	r0, r0, 0
	printf("wav_header.rLen:%d\n",ck860_wav_header->rLen);
    ad30:	e4681007 	subi      	r3, r8, 8
    ad34:	9360      	ld.w      	r3, (r3, 0)
    ad36:	9361      	ld.w      	r3, (r3, 0x4)
    ad38:	6c4f      	mov      	r1, r3
    ad3a:	130f      	lrw      	r0, 0xdb5c	// aef4 <ck860_set_parameter_audio+0x288>
    ad3c:	eae0006d 	jsri      	0x0	// from address pool at 0xaef0
    ad40:	c4004820 	lsli      	r0, r0, 0
	printf("wChannels:%d\n",ck860_wav_header->wChannels);
    ad44:	e4681007 	subi      	r3, r8, 8
    ad48:	9360      	ld.w      	r3, (r3, 0)
    ad4a:	8b6b      	ld.h      	r3, (r3, 0x16)
    ad4c:	74cf      	sexth      	r3, r3
    ad4e:	6c4f      	mov      	r1, r3
    ad50:	130a      	lrw      	r0, 0xdb70	// aef8 <ck860_set_parameter_audio+0x28c>
    ad52:	eae00068 	jsri      	0x0	// from address pool at 0xaef0
    ad56:	c4004820 	lsli      	r0, r0, 0
	printf("nSamplesPersec:%d\n",ck860_wav_header->nSamplesPersec);
    ad5a:	e4681007 	subi      	r3, r8, 8
    ad5e:	9360      	ld.w      	r3, (r3, 0)
    ad60:	9366      	ld.w      	r3, (r3, 0x18)
    ad62:	6c4f      	mov      	r1, r3
    ad64:	1306      	lrw      	r0, 0xdb80	// aefc <ck860_set_parameter_audio+0x290>
    ad66:	eae00063 	jsri      	0x0	// from address pool at 0xaef0
    ad6a:	c4004820 	lsli      	r0, r0, 0
	printf("wSampleLength=%d\n",ck860_wav_header->wSampleLength);
    ad6e:	e4681007 	subi      	r3, r8, 8
    ad72:	9360      	ld.w      	r3, (r3, 0)
    ad74:	936a      	ld.w      	r3, (r3, 0x28)
    ad76:	6c4f      	mov      	r1, r3
    ad78:	1302      	lrw      	r0, 0xdb94	// af00 <ck860_set_parameter_audio+0x294>
    ad7a:	eae0005e 	jsri      	0x0	// from address pool at 0xaef0
    ad7e:	c4004820 	lsli      	r0, r0, 0
	printf("wBitsPerSample=%d\n",BitsPerSample);
    ad82:	127a      	lrw      	r3, 0x1002c	// aee8 <ck860_set_parameter_audio+0x27c>
    ad84:	8b60      	ld.h      	r3, (r3, 0)
    ad86:	74cf      	sexth      	r3, r3
    ad88:	6c4f      	mov      	r1, r3
    ad8a:	121f      	lrw      	r0, 0xdba8	// af04 <ck860_set_parameter_audio+0x298>
    ad8c:	eae00059 	jsri      	0x0	// from address pool at 0xaef0
    ad90:	c4004820 	lsli      	r0, r0, 0

	rc=snd_pcm_open(&handle, "default", SND_PCM_STREAM_PLAYBACK, 0);//用于播放
    ad94:	e4881017 	subi      	r4, r8, 24
    ad98:	e408101b 	subi      	r0, r8, 28
    ad9c:	3300      	movi      	r3, 0
    ad9e:	3200      	movi      	r2, 0
    ada0:	123a      	lrw      	r1, 0xdbbc	// af08 <ck860_set_parameter_audio+0x29c>
    ada2:	eae0005b 	jsri      	0x0	// from address pool at 0xaf0c
    ada6:	c4004820 	lsli      	r0, r0, 0
    adaa:	b400      	st.w      	r0, (r4, 0)
	if(rc<0)
    adac:	e4681017 	subi      	r3, r8, 24
    adb0:	9360      	ld.w      	r3, (r3, 0)
    adb2:	e9a3000c 	bhsz      	r3, 0xadca	// adca <ck860_set_parameter_audio+0x15e>
	{
		   perror("\nopen PCM device failed:");
    adb6:	1217      	lrw      	r0, 0xdbc4	// af10 <ck860_set_parameter_audio+0x2a4>
    adb8:	eae00057 	jsri      	0x0	// from address pool at 0xaf14
    adbc:	c4004820 	lsli      	r0, r0, 0
		   exit(1);
    adc0:	3001      	movi      	r0, 1
    adc2:	eae00056 	jsri      	0x0	// from address pool at 0xaf18
    adc6:	c4004820 	lsli      	r0, r0, 0
	}


	snd_pcm_hw_params_alloca(&params); //分配params结构体
    adca:	eae00055 	jsri      	0x0	// from address pool at 0xaf1c
    adce:	c4004820 	lsli      	r0, r0, 0
    add2:	6cc3      	mov      	r3, r0
    add4:	2302      	addi      	r3, 3
    add6:	2302      	addi      	r3, 3
    add8:	4b62      	lsri      	r3, r3, 2
    adda:	4362      	lsli      	r3, r3, 2
    addc:	ea021000 	movi      	r2, 4096
    ade0:	64c8      	cmphs      	r2, r3
    ade2:	0807      	bt      	0xadf0	// adf0 <ck860_set_parameter_audio+0x184>
    ade4:	638a      	subu      	sp, r2
    ade6:	ddce2000 	st.w      	sp, (sp, 0)
    adea:	60ca      	subu      	r3, r2
    adec:	64c8      	cmphs      	r2, r3
    adee:	0ffb      	bf      	0xade4	// ade4 <ck860_set_parameter_audio+0x178>
    adf0:	638e      	subu      	sp, r3
    adf2:	6cfb      	mov      	r3, sp
    adf4:	2302      	addi      	r3, 3
    adf6:	4b62      	lsri      	r3, r3, 2
    adf8:	4362      	lsli      	r3, r3, 2
    adfa:	6c8f      	mov      	r2, r3
    adfc:	e468101f 	subi      	r3, r8, 32
    ae00:	b340      	st.w      	r2, (r3, 0)
    ae02:	e468101f 	subi      	r3, r8, 32
    ae06:	9380      	ld.w      	r4, (r3, 0)
    ae08:	eae00045 	jsri      	0x0	// from address pool at 0xaf1c
    ae0c:	c4004820 	lsli      	r0, r0, 0
    ae10:	6cc3      	mov      	r3, r0
    ae12:	6c8f      	mov      	r2, r3
    ae14:	3100      	movi      	r1, 0
    ae16:	6c13      	mov      	r0, r4
    ae18:	eae00042 	jsri      	0x0	// from address pool at 0xaf20
    ae1c:	c4004820 	lsli      	r0, r0, 0
	if(rc<0)
    ae20:	e4681017 	subi      	r3, r8, 24
    ae24:	9360      	ld.w      	r3, (r3, 0)
    ae26:	e9a3000c 	bhsz      	r3, 0xae3e	// ae3e <ck860_set_parameter_audio+0x1d2>
	{
		   perror("\nsnd_pcm_hw_params_alloca:");
    ae2a:	111f      	lrw      	r0, 0xdbe0	// af24 <ck860_set_parameter_audio+0x2b8>
    ae2c:	eae0003a 	jsri      	0x0	// from address pool at 0xaf14
    ae30:	c4004820 	lsli      	r0, r0, 0
		   exit(1);
    ae34:	3001      	movi      	r0, 1
    ae36:	eae00039 	jsri      	0x0	// from address pool at 0xaf18
    ae3a:	c4004820 	lsli      	r0, r0, 0
	}
	rc=snd_pcm_hw_params_any(handle, params);//初始化params
    ae3e:	e468101b 	subi      	r3, r8, 28
    ae42:	9340      	ld.w      	r2, (r3, 0)
    ae44:	e468101f 	subi      	r3, r8, 32
    ae48:	9360      	ld.w      	r3, (r3, 0)
    ae4a:	e4881017 	subi      	r4, r8, 24
    ae4e:	6c4f      	mov      	r1, r3
    ae50:	6c0b      	mov      	r0, r2
    ae52:	eae00036 	jsri      	0x0	// from address pool at 0xaf28
    ae56:	c4004820 	lsli      	r0, r0, 0
    ae5a:	b400      	st.w      	r0, (r4, 0)
	if(rc<0)
    ae5c:	e4681017 	subi      	r3, r8, 24
    ae60:	9360      	ld.w      	r3, (r3, 0)
    ae62:	e9a3000c 	bhsz      	r3, 0xae7a	// ae7a <ck860_set_parameter_audio+0x20e>
	{
		   perror("\nsnd_pcm_hw_params_any:");
    ae66:	1112      	lrw      	r0, 0xdbfc	// af2c <ck860_set_parameter_audio+0x2c0>
    ae68:	eae0002b 	jsri      	0x0	// from address pool at 0xaf14
    ae6c:	c4004820 	lsli      	r0, r0, 0
		   exit(1);
    ae70:	3001      	movi      	r0, 1
    ae72:	eae0002a 	jsri      	0x0	// from address pool at 0xaf18
    ae76:	c4004820 	lsli      	r0, r0, 0
	}
	rc=snd_pcm_hw_params_set_access(handle, params, SND_PCM_ACCESS_RW_INTERLEAVED); //初始化访问权限
    ae7a:	e468101b 	subi      	r3, r8, 28
    ae7e:	9300      	ld.w      	r0, (r3, 0)
    ae80:	e468101f 	subi      	r3, r8, 32
    ae84:	9360      	ld.w      	r3, (r3, 0)
    ae86:	e4881017 	subi      	r4, r8, 24
    ae8a:	3203      	movi      	r2, 3
    ae8c:	6c4f      	mov      	r1, r3
    ae8e:	eae00029 	jsri      	0x0	// from address pool at 0xaf30
    ae92:	c4004820 	lsli      	r0, r0, 0
    ae96:	b400      	st.w      	r0, (r4, 0)
	if(rc<0)
    ae98:	e4681017 	subi      	r3, r8, 24
    ae9c:	9360      	ld.w      	r3, (r3, 0)
    ae9e:	e9a3000c 	bhsz      	r3, 0xaeb6	// aeb6 <ck860_set_parameter_audio+0x24a>
	{
		   perror("\nsed_pcm_hw_set_access:");
    aea2:	1105      	lrw      	r0, 0xdc14	// af34 <ck860_set_parameter_audio+0x2c8>
    aea4:	eae0001c 	jsri      	0x0	// from address pool at 0xaf14
    aea8:	c4004820 	lsli      	r0, r0, 0
		   exit(1);
    aeac:	3001      	movi      	r0, 1
    aeae:	eae0001b 	jsri      	0x0	// from address pool at 0xaf18
    aeb2:	c4004820 	lsli      	r0, r0, 0
			   break ;

	}
#else
	//采样精度
	switch(bit/8)
    aeb6:	e4681013 	subi      	r3, r8, 20
    aeba:	9360      	ld.w      	r3, (r3, 0)
    aebc:	e9a30003 	bhsz      	r3, 0xaec2	// aec2 <ck860_set_parameter_audio+0x256>
    aec0:	2306      	addi      	r3, 7
    aec2:	5363      	asri      	r3, r3, 3
    aec4:	3b42      	cmpnei      	r3, 2
    aec6:	0c4e      	bf      	0xaf62	// af62 <ck860_set_parameter_audio+0x2f6>
    aec8:	3b22      	cmplti      	r3, 3
    aeca:	0c37      	bf      	0xaf38	// af38 <ck860_set_parameter_audio+0x2cc>
    aecc:	3b41      	cmpnei      	r3, 1
    aece:	0c3a      	bf      	0xaf42	// af42 <ck860_set_parameter_audio+0x2d6>
    aed0:	0479      	br      	0xafc2	// afc2 <ck860_set_parameter_audio+0x356>
    aed2:	0000      	.short	0x0000
    aed4:	0000db2c 	.long	0x0000db2c
    aed8:	00000000 	.long	0x00000000
    aedc:	0000ab5c 	.long	0x0000ab5c
    aee0:	00010030 	.long	0x00010030
    aee4:	00010028 	.long	0x00010028
    aee8:	0001002c 	.long	0x0001002c
    aeec:	0000db4c 	.long	0x0000db4c
    aef0:	00000000 	.long	0x00000000
    aef4:	0000db5c 	.long	0x0000db5c
    aef8:	0000db70 	.long	0x0000db70
    aefc:	0000db80 	.long	0x0000db80
    af00:	0000db94 	.long	0x0000db94
    af04:	0000dba8 	.long	0x0000dba8
    af08:	0000dbbc 	.long	0x0000dbbc
    af0c:	00000000 	.long	0x00000000
    af10:	0000dbc4 	.long	0x0000dbc4
	...
    af24:	0000dbe0 	.long	0x0000dbe0
    af28:	00000000 	.long	0x00000000
    af2c:	0000dbfc 	.long	0x0000dbfc
    af30:	00000000 	.long	0x00000000
    af34:	0000dc14 	.long	0x0000dc14
    af38:	3b43      	cmpnei      	r3, 3
    af3a:	0c24      	bf      	0xaf82	// af82 <ck860_set_parameter_audio+0x316>
    af3c:	3b44      	cmpnei      	r3, 4
    af3e:	0c32      	bf      	0xafa2	// afa2 <ck860_set_parameter_audio+0x336>
    af40:	0441      	br      	0xafc2	// afc2 <ck860_set_parameter_audio+0x356>
	{
	   case 1:
	   	resolution = snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_U8);
    af42:	e468101b 	subi      	r3, r8, 28
    af46:	9300      	ld.w      	r0, (r3, 0)
    af48:	e468101f 	subi      	r3, r8, 32
    af4c:	9360      	ld.w      	r3, (r3, 0)
    af4e:	e4881003 	subi      	r4, r8, 4
    af52:	3201      	movi      	r2, 1
    af54:	6c4f      	mov      	r1, r3
    af56:	eae00079 	jsri      	0x0	// from address pool at 0xb138
    af5a:	c4004820 	lsli      	r0, r0, 0
    af5e:	b400      	st.w      	r0, (r4, 0)
			   break ;
    af60:	0431      	br      	0xafc2	// afc2 <ck860_set_parameter_audio+0x356>
	   case 2:
	   	resolution = snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_S16_LE);
    af62:	e468101b 	subi      	r3, r8, 28
    af66:	9300      	ld.w      	r0, (r3, 0)
    af68:	e468101f 	subi      	r3, r8, 32
    af6c:	9360      	ld.w      	r3, (r3, 0)
    af6e:	e4881003 	subi      	r4, r8, 4
    af72:	3202      	movi      	r2, 2
    af74:	6c4f      	mov      	r1, r3
    af76:	eae00071 	jsri      	0x0	// from address pool at 0xb138
    af7a:	c4004820 	lsli      	r0, r0, 0
    af7e:	b400      	st.w      	r0, (r4, 0)
			   break ;
    af80:	0421      	br      	0xafc2	// afc2 <ck860_set_parameter_audio+0x356>
	   case 3:
	   	resolution =snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_S24_LE);
    af82:	e468101b 	subi      	r3, r8, 28
    af86:	9300      	ld.w      	r0, (r3, 0)
    af88:	e468101f 	subi      	r3, r8, 32
    af8c:	9360      	ld.w      	r3, (r3, 0)
    af8e:	e4881003 	subi      	r4, r8, 4
    af92:	3206      	movi      	r2, 6
    af94:	6c4f      	mov      	r1, r3
    af96:	eae00069 	jsri      	0x0	// from address pool at 0xb138
    af9a:	c4004820 	lsli      	r0, r0, 0
    af9e:	b400      	st.w      	r0, (r4, 0)
			   break ;
    afa0:	0411      	br      	0xafc2	// afc2 <ck860_set_parameter_audio+0x356>
	   case 4:
	   	resolution =snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_S32_LE);
    afa2:	e468101b 	subi      	r3, r8, 28
    afa6:	9300      	ld.w      	r0, (r3, 0)
    afa8:	e468101f 	subi      	r3, r8, 32
    afac:	9360      	ld.w      	r3, (r3, 0)
    afae:	e4881003 	subi      	r4, r8, 4
    afb2:	320a      	movi      	r2, 10
    afb4:	6c4f      	mov      	r1, r3
    afb6:	eae00061 	jsri      	0x0	// from address pool at 0xb138
    afba:	c4004820 	lsli      	r0, r0, 0
    afbe:	b400      	st.w      	r0, (r4, 0)
			   break ;
    afc0:	6c00      	or      	r0, r0

	}

	if (resolution < 0)
    afc2:	e4681003 	subi      	r3, r8, 4
    afc6:	9360      	ld.w      	r3, (r3, 0)
    afc8:	e9a30010 	bhsz      	r3, 0xafe8	// afe8 <ck860_set_parameter_audio+0x37c>
	{
		printf("=Error! set format fail %d==",bit/8);
    afcc:	e4681013 	subi      	r3, r8, 20
    afd0:	9360      	ld.w      	r3, (r3, 0)
    afd2:	e9a30003 	bhsz      	r3, 0xafd8	// afd8 <ck860_set_parameter_audio+0x36c>
    afd6:	2306      	addi      	r3, 7
    afd8:	5363      	asri      	r3, r3, 3
    afda:	6c4f      	mov      	r1, r3
    afdc:	1218      	lrw      	r0, 0xdc2c	// b13c <ck860_set_parameter_audio+0x4d0>
    afde:	eae00059 	jsri      	0x0	// from address pool at 0xb140
    afe2:	c4004820 	lsli      	r0, r0, 0
    afe6:	040e      	br      	0xb002	// b002 <ck860_set_parameter_audio+0x396>
	}
	else {
		printf("set format success %d !",bit/8);	
    afe8:	e4681013 	subi      	r3, r8, 20
    afec:	9360      	ld.w      	r3, (r3, 0)
    afee:	e9a30003 	bhsz      	r3, 0xaff4	// aff4 <ck860_set_parameter_audio+0x388>
    aff2:	2306      	addi      	r3, 7
    aff4:	5363      	asri      	r3, r3, 3
    aff6:	6c4f      	mov      	r1, r3
    aff8:	1213      	lrw      	r0, 0xdc4c	// b144 <ck860_set_parameter_audio+0x4d8>
    affa:	eae00052 	jsri      	0x0	// from address pool at 0xb140
    affe:	c4004820 	lsli      	r0, r0, 0
	}

#endif

	
	rc=snd_pcm_hw_params_set_channels(handle, params, channels);  //设置声道,1表示单声>道，2表示立体声
    b002:	e468101b 	subi      	r3, r8, 28
    b006:	9300      	ld.w      	r0, (r3, 0)
    b008:	e468101f 	subi      	r3, r8, 32
    b00c:	9320      	ld.w      	r1, (r3, 0)
    b00e:	e468100b 	subi      	r3, r8, 12
    b012:	9360      	ld.w      	r3, (r3, 0)
    b014:	e4881017 	subi      	r4, r8, 24
    b018:	6c8f      	mov      	r2, r3
    b01a:	eae0004c 	jsri      	0x0	// from address pool at 0xb148
    b01e:	c4004820 	lsli      	r0, r0, 0
    b022:	b400      	st.w      	r0, (r4, 0)
	if(rc<0)
    b024:	e4681017 	subi      	r3, r8, 24
    b028:	9360      	ld.w      	r3, (r3, 0)
    b02a:	e9a3000c 	bhsz      	r3, 0xb042	// b042 <ck860_set_parameter_audio+0x3d6>
	{
		   perror("\nsnd_pcm_hw_params_set_channels:");
    b02e:	1208      	lrw      	r0, 0xdc64	// b14c <ck860_set_parameter_audio+0x4e0>
    b030:	eae00048 	jsri      	0x0	// from address pool at 0xb150
    b034:	c4004820 	lsli      	r0, r0, 0
		   exit(1);
    b038:	3001      	movi      	r0, 1
    b03a:	eae00047 	jsri      	0x0	// from address pool at 0xb154
    b03e:	c4004820 	lsli      	r0, r0, 0
	}
	val = frequency;
    b042:	e468100f 	subi      	r3, r8, 16
    b046:	9340      	ld.w      	r2, (r3, 0)
    b048:	e4681023 	subi      	r3, r8, 36
    b04c:	b340      	st.w      	r2, (r3, 0)
	rc=snd_pcm_hw_params_set_rate_near(handle, params, &val, &dir);	//设置>频率
    b04e:	e468101b 	subi      	r3, r8, 28
    b052:	9300      	ld.w      	r0, (r3, 0)
    b054:	e468101f 	subi      	r3, r8, 32
    b058:	9320      	ld.w      	r1, (r3, 0)
    b05a:	e4881017 	subi      	r4, r8, 24
    b05e:	e4681027 	subi      	r3, r8, 40
    b062:	e4481023 	subi      	r2, r8, 36
    b066:	eae0003d 	jsri      	0x0	// from address pool at 0xb158
    b06a:	c4004820 	lsli      	r0, r0, 0
    b06e:	b400      	st.w      	r0, (r4, 0)
	if(rc<0)
    b070:	e4681017 	subi      	r3, r8, 24
    b074:	9360      	ld.w      	r3, (r3, 0)
    b076:	e9a3000c 	bhsz      	r3, 0xb08e	// b08e <ck860_set_parameter_audio+0x422>
	{
		   perror("\nsnd_pcm_hw_params_set_rate_near:");
    b07a:	1119      	lrw      	r0, 0xdc88	// b15c <ck860_set_parameter_audio+0x4f0>
    b07c:	eae00035 	jsri      	0x0	// from address pool at 0xb150
    b080:	c4004820 	lsli      	r0, r0, 0
		   exit(1);
    b084:	3001      	movi      	r0, 1
    b086:	eae00034 	jsri      	0x0	// from address pool at 0xb154
    b08a:	c4004820 	lsli      	r0, r0, 0
	}

/*设置pcm hw params 完成*/
	rc = snd_pcm_hw_params(handle, params);
    b08e:	e468101b 	subi      	r3, r8, 28
    b092:	9340      	ld.w      	r2, (r3, 0)
    b094:	e468101f 	subi      	r3, r8, 32
    b098:	9360      	ld.w      	r3, (r3, 0)
    b09a:	e4881017 	subi      	r4, r8, 24
    b09e:	6c4f      	mov      	r1, r3
    b0a0:	6c0b      	mov      	r0, r2
    b0a2:	eae00030 	jsri      	0x0	// from address pool at 0xb160
    b0a6:	c4004820 	lsli      	r0, r0, 0
    b0aa:	b400      	st.w      	r0, (r4, 0)
	if(rc<0)
    b0ac:	e4681017 	subi      	r3, r8, 24
    b0b0:	9360      	ld.w      	r3, (r3, 0)
    b0b2:	e9a3000c 	bhsz      	r3, 0xb0ca	// b0ca <ck860_set_parameter_audio+0x45e>
	{
	   perror("\nsnd_pcm_hw_params: ");
    b0b6:	110c      	lrw      	r0, 0xdcac	// b164 <ck860_set_parameter_audio+0x4f8>
    b0b8:	eae00026 	jsri      	0x0	// from address pool at 0xb150
    b0bc:	c4004820 	lsli      	r0, r0, 0
	   exit(1);
    b0c0:	3001      	movi      	r0, 1
    b0c2:	eae00025 	jsri      	0x0	// from address pool at 0xb154
    b0c6:	c4004820 	lsli      	r0, r0, 0
	}
	
    rc=snd_pcm_hw_params_get_period_size(params, &frames_byavs, &dir);  /*获取周期长度*/
    b0ca:	e468101f 	subi      	r3, r8, 32
    b0ce:	9360      	ld.w      	r3, (r3, 0)
    b0d0:	e4881017 	subi      	r4, r8, 24
    b0d4:	e4481027 	subi      	r2, r8, 40
    b0d8:	1124      	lrw      	r1, 0x10024	// b168 <ck860_set_parameter_audio+0x4fc>
    b0da:	6c0f      	mov      	r0, r3
    b0dc:	eae00024 	jsri      	0x0	// from address pool at 0xb16c
    b0e0:	c4004820 	lsli      	r0, r0, 0
    b0e4:	b400      	st.w      	r0, (r4, 0)
    if(rc<0)
    b0e6:	e4681017 	subi      	r3, r8, 24
    b0ea:	9360      	ld.w      	r3, (r3, 0)
    b0ec:	e9a3000c 	bhsz      	r3, 0xb104	// b104 <ck860_set_parameter_audio+0x498>
    {
            perror("\nsnd_pcm_hw_params_get_period_size:");
    b0f0:	1100      	lrw      	r0, 0xdcc4	// b170 <ck860_set_parameter_audio+0x504>
    b0f2:	eae00018 	jsri      	0x0	// from address pool at 0xb150
    b0f6:	c4004820 	lsli      	r0, r0, 0
            exit(1);
    b0fa:	3001      	movi      	r0, 1
    b0fc:	eae00016 	jsri      	0x0	// from address pool at 0xb154
    b100:	c4004820 	lsli      	r0, r0, 0
    }

	printf("frames_byavs:%d\n",frames_byavs);	
    b104:	1079      	lrw      	r3, 0x10024	// b168 <ck860_set_parameter_audio+0x4fc>
    b106:	9360      	ld.w      	r3, (r3, 0)
    b108:	6c4f      	mov      	r1, r3
    b10a:	101b      	lrw      	r0, 0xdce8	// b174 <ck860_set_parameter_audio+0x508>
    b10c:	eae0000d 	jsri      	0x0	// from address pool at 0xb140
    b110:	c4004820 	lsli      	r0, r0, 0
	printf("set pcm parameter finish!\n");
    b114:	1019      	lrw      	r0, 0xdcfc	// b178 <ck860_set_parameter_audio+0x50c>
    b116:	eae0001a 	jsri      	0x0	// from address pool at 0xb17c
    b11a:	c4004820 	lsli      	r0, r0, 0
	return handle;
    b11e:	e468101b 	subi      	r3, r8, 28
    b122:	9360      	ld.w      	r3, (r3, 0)
	
}
    b124:	6c0f      	mov      	r0, r3
    b126:	6fa3      	mov      	sp, r8
    b128:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    b12c:	d90e2001 	ld.w      	r8, (sp, 0x4)
    b130:	9880      	ld.w      	r4, (sp, 0)
    b132:	1403      	addi      	sp, sp, 12
    b134:	783c      	rts
    b136:	0000      	.short	0x0000
    b138:	00000000 	.long	0x00000000
    b13c:	0000dc2c 	.long	0x0000dc2c
    b140:	00000000 	.long	0x00000000
    b144:	0000dc4c 	.long	0x0000dc4c
    b148:	00000000 	.long	0x00000000
    b14c:	0000dc64 	.long	0x0000dc64
	...
    b15c:	0000dc88 	.long	0x0000dc88
    b160:	00000000 	.long	0x00000000
    b164:	0000dcac 	.long	0x0000dcac
    b168:	00010024 	.long	0x00010024
    b16c:	00000000 	.long	0x00000000
    b170:	0000dcc4 	.long	0x0000dcc4
    b174:	0000dce8 	.long	0x0000dce8
    b178:	0000dcfc 	.long	0x0000dcfc
    b17c:	00000000 	.long	0x00000000

0000b180 <ck860_playback>:

int ck860_playback(GV_IPCM_MSG_S* pMsg_playback,snd_pcm_t*		handle)
{
    b180:	1423      	subi      	sp, sp, 12
    b182:	b880      	st.w      	r4, (sp, 0)
    b184:	dd0e2001 	st.w      	r8, (sp, 0x4)
    b188:	ddee2002 	st.w      	r15, (sp, 0x8)
    b18c:	6e3b      	mov      	r8, sp
    b18e:	1427      	subi      	sp, sp, 28
    b190:	e4681017 	subi      	r3, r8, 24
    b194:	b300      	st.w      	r0, (r3, 0)
    b196:	e468101b 	subi      	r3, r8, 28
    b19a:	b320      	st.w      	r1, (r3, 0)
	printf("ck860 begin playback!\n");
    b19c:	ea80008d 	lrw      	r0, 0xdd18	// b3d0 <ck860_playback+0x250>
    b1a0:	eae0008d 	jsri      	0x0	// from address pool at 0xb3d4
    b1a4:	c4004820 	lsli      	r0, r0, 0
	int ret ;

	int r;
	int wcount;//代表音频数据帧数
/* 从pcm 数据读取到paly_vir当中 */
	void* play_vir = phy_to_virtual(pMsg_playback->msg_body->start,pMsg_playback->msg_body->size); 
    b1a8:	e4681017 	subi      	r3, r8, 24
    b1ac:	9360      	ld.w      	r3, (r3, 0)
    b1ae:	9361      	ld.w      	r3, (r3, 0x4)
    b1b0:	9340      	ld.w      	r2, (r3, 0)
    b1b2:	e4681017 	subi      	r3, r8, 24
    b1b6:	9360      	ld.w      	r3, (r3, 0)
    b1b8:	9361      	ld.w      	r3, (r3, 0x4)
    b1ba:	9361      	ld.w      	r3, (r3, 0x4)
    b1bc:	e4881007 	subi      	r4, r8, 8
    b1c0:	6c4f      	mov      	r1, r3
    b1c2:	6c0b      	mov      	r0, r2
    b1c4:	e3fffccc 	bsr      	0xab5c	// ab5c <phy_to_virtual>
    b1c8:	c4004820 	lsli      	r0, r0, 0
    b1cc:	b400      	st.w      	r0, (r4, 0)
	int size = pMsg_playback->msg_body->size;//pcm 字节大小
    b1ce:	e4681017 	subi      	r3, r8, 24
    b1d2:	9360      	ld.w      	r3, (r3, 0)
    b1d4:	9361      	ld.w      	r3, (r3, 0x4)
    b1d6:	9341      	ld.w      	r2, (r3, 0x4)
    b1d8:	e468100b 	subi      	r3, r8, 12
    b1dc:	b340      	st.w      	r2, (r3, 0)
	
/* Transfer to size frame */
	wcount = size*8/BitsPerSample * CHANNELS;
    b1de:	e468100b 	subi      	r3, r8, 12
    b1e2:	9360      	ld.w      	r3, (r3, 0)
    b1e4:	4363      	lsli      	r3, r3, 3
    b1e6:	135e      	lrw      	r2, 0x1002c	// b3dc <ck860_playback+0x25c>
    b1e8:	8a40      	ld.h      	r2, (r2, 0)
    b1ea:	748b      	sexth      	r2, r2
    b1ec:	c4438041 	divs      	r1, r3, r2
    b1f0:	137c      	lrw      	r3, 0x10030	// b3e0 <ck860_playback+0x260>
    b1f2:	9340      	ld.w      	r2, (r3, 0)
    b1f4:	e4681003 	subi      	r3, r8, 4
    b1f8:	7c84      	mult      	r2, r1
    b1fa:	b340      	st.w      	r2, (r3, 0)
	printf("frames_byavs :%d,wcount: %d\n",frames_byavs,wcount); 
    b1fc:	137a      	lrw      	r3, 0x10024	// b3e4 <ck860_playback+0x264>
    b1fe:	9320      	ld.w      	r1, (r3, 0)
    b200:	e4681003 	subi      	r3, r8, 4
    b204:	9340      	ld.w      	r2, (r3, 0)
    b206:	1319      	lrw      	r0, 0xdd30	// b3e8 <ck860_playback+0x268>
    b208:	eae00079 	jsri      	0x0	// from address pool at 0xb3ec
    b20c:	c4004820 	lsli      	r0, r0, 0

// snd_pcm_writei() snd_pcm_readi();size 是以frame为单位，frame与bytes的转换
// 1 frame = channels*sample_size ;1frame = 2bytes
	
	while(wcount > 0){
    b210:	04a5      	br      	0xb35a	// b35a <ck860_playback+0x1da>
		r = snd_pcm_writei(handle,play_vir,wcount);
    b212:	e4681003 	subi      	r3, r8, 4
    b216:	9340      	ld.w      	r2, (r3, 0)
    b218:	e488100f 	subi      	r4, r8, 16
    b21c:	e4281007 	subi      	r1, r8, 8
    b220:	e468101b 	subi      	r3, r8, 28
    b224:	9120      	ld.w      	r1, (r1, 0)
    b226:	9300      	ld.w      	r0, (r3, 0)
    b228:	eae00072 	jsri      	0x0	// from address pool at 0xb3f0
    b22c:	c4004820 	lsli      	r0, r0, 0
    b230:	b400      	st.w      	r0, (r4, 0)
		if (r == -EAGAIN || (r>=0 && (size_t)r << wcount)){
    b232:	e468100f 	subi      	r3, r8, 16
    b236:	9340      	ld.w      	r2, (r3, 0)
    b238:	3300      	movi      	r3, 0
    b23a:	2b0a      	subi      	r3, 11
    b23c:	64ca      	cmpne      	r2, r3
    b23e:	0c10      	bf      	0xb25e	// b25e <ck860_playback+0xde>
    b240:	e468100f 	subi      	r3, r8, 16
    b244:	9360      	ld.w      	r3, (r3, 0)
    b246:	e9830016 	blz      	r3, 0xb272	// b272 <ck860_playback+0xf2>
    b24a:	e468100f 	subi      	r3, r8, 16
    b24e:	9340      	ld.w      	r2, (r3, 0)
    b250:	e4681003 	subi      	r3, r8, 4
    b254:	9360      	ld.w      	r3, (r3, 0)
    b256:	c4624023 	lsl      	r3, r2, r3
    b25a:	e903000c 	bez      	r3, 0xb272	// b272 <ck860_playback+0xf2>
			snd_pcm_wait(handle,1000);
    b25e:	e468101b 	subi      	r3, r8, 28
    b262:	ea0103e8 	movi      	r1, 1000
    b266:	9300      	ld.w      	r0, (r3, 0)
    b268:	eae00063 	jsri      	0x0	// from address pool at 0xb3f4
    b26c:	c4004820 	lsli      	r0, r0, 0
    b270:	0446      	br      	0xb2fc	// b2fc <ck860_playback+0x17c>
			}	else if (ret == -EPIPE)
    b272:	e4681013 	subi      	r3, r8, 20
    b276:	9340      	ld.w      	r2, (r3, 0)
    b278:	3300      	movi      	r3, 0
    b27a:	2b1f      	subi      	r3, 32
    b27c:	64ca      	cmpne      	r2, r3
    b27e:	0812      	bt      	0xb2a2	// b2a2 <ck860_playback+0x122>
			{
				/* EPIPE means underrun */
		      fprintf(stderr, "underrun occurred\n");
    b280:	127e      	lrw      	r3, 0	// b3f8 <ck860_playback+0x278>
    b282:	9360      	ld.w      	r3, (r3, 0)
    b284:	3212      	movi      	r2, 18
    b286:	3101      	movi      	r1, 1
    b288:	121d      	lrw      	r0, 0xdd50	// b3fc <ck860_playback+0x27c>
    b28a:	eae0005e 	jsri      	0x0	// from address pool at 0xb400
    b28e:	c4004820 	lsli      	r0, r0, 0
		      //完成硬件参数设置，使设备准备好  
		      snd_pcm_prepare(handle);
    b292:	e468101b 	subi      	r3, r8, 28
    b296:	9300      	ld.w      	r0, (r3, 0)
    b298:	eae0005b 	jsri      	0x0	// from address pool at 0xb404
    b29c:	c4004820 	lsli      	r0, r0, 0
    b2a0:	042e      	br      	0xb2fc	// b2fc <ck860_playback+0x17c>
			}
			else if (r == -ESTRPIPE)
    b2a2:	e468100f 	subi      	r3, r8, 16
    b2a6:	9340      	ld.w      	r2, (r3, 0)
    b2a8:	3300      	movi      	r3, 0
    b2aa:	2b55      	subi      	r3, 86
    b2ac:	64ca      	cmpne      	r2, r3
    b2ae:	080b      	bt      	0xb2c4	// b2c4 <ck860_playback+0x144>
			{
				 fprintf(stderr, "need suspend!\n");
    b2b0:	1272      	lrw      	r3, 0	// b3f8 <ck860_playback+0x278>
    b2b2:	9360      	ld.w      	r3, (r3, 0)
    b2b4:	320e      	movi      	r2, 14
    b2b6:	3101      	movi      	r1, 1
    b2b8:	1214      	lrw      	r0, 0xdd64	// b408 <ck860_playback+0x288>
    b2ba:	eae00052 	jsri      	0x0	// from address pool at 0xb400
    b2be:	c4004820 	lsli      	r0, r0, 0
    b2c2:	041d      	br      	0xb2fc	// b2fc <ck860_playback+0x17c>
			}
		    else if (ret < 0)
    b2c4:	e4681013 	subi      	r3, r8, 20
    b2c8:	9360      	ld.w      	r3, (r3, 0)
    b2ca:	e9a30019 	bhsz      	r3, 0xb2fc	// b2fc <ck860_playback+0x17c>
		   {
		         fprintf(stderr,"error from writei: %s\n",snd_strerror(ret));
    b2ce:	126b      	lrw      	r3, 0	// b3f8 <ck860_playback+0x278>
    b2d0:	9380      	ld.w      	r4, (r3, 0)
    b2d2:	e4681013 	subi      	r3, r8, 20
    b2d6:	9300      	ld.w      	r0, (r3, 0)
    b2d8:	eae0004d 	jsri      	0x0	// from address pool at 0xb40c
    b2dc:	c4004820 	lsli      	r0, r0, 0
    b2e0:	6cc3      	mov      	r3, r0
    b2e2:	6c8f      	mov      	r2, r3
    b2e4:	122b      	lrw      	r1, 0xdd74	// b410 <ck860_playback+0x290>
    b2e6:	6c13      	mov      	r0, r4
    b2e8:	eae0004b 	jsri      	0x0	// from address pool at 0xb414
    b2ec:	c4004820 	lsli      	r0, r0, 0
				 exit(-1);
    b2f0:	3000      	movi      	r0, 0
    b2f2:	2800      	subi      	r0, 1
    b2f4:	eae00049 	jsri      	0x0	// from address pool at 0xb418
    b2f8:	c4004820 	lsli      	r0, r0, 0
    b2fc:	e4681003 	subi      	r3, r8, 4
    b300:	e4481003 	subi      	r2, r8, 4
    b304:	9240      	ld.w      	r2, (r2, 0)
    b306:	b340      	st.w      	r2, (r3, 0)
    b308:	e4681007 	subi      	r3, r8, 8
    b30c:	e4481007 	subi      	r2, r8, 8
    b310:	9240      	ld.w      	r2, (r2, 0)
    b312:	b340      	st.w      	r2, (r3, 0)
		   }

		if (r > 0)
    b314:	e468100f 	subi      	r3, r8, 16
    b318:	9360      	ld.w      	r3, (r3, 0)
    b31a:	e9630020 	blsz      	r3, 0xb35a	// b35a <ck860_playback+0x1da>
		{
			wcount -= r;
    b31e:	e4681003 	subi      	r3, r8, 4
    b322:	e4281003 	subi      	r1, r8, 4
    b326:	e448100f 	subi      	r2, r8, 16
    b32a:	9120      	ld.w      	r1, (r1, 0)
    b32c:	9240      	ld.w      	r2, (r2, 0)
    b32e:	5949      	subu      	r2, r1, r2
    b330:	b340      	st.w      	r2, (r3, 0)
			play_vir+= r*BitsPerSample/8;//每次偏移r帧
    b332:	116b      	lrw      	r3, 0x1002c	// b3dc <ck860_playback+0x25c>
    b334:	8b60      	ld.h      	r3, (r3, 0)
    b336:	74cf      	sexth      	r3, r3
    b338:	6c8f      	mov      	r2, r3
    b33a:	e468100f 	subi      	r3, r8, 16
    b33e:	9360      	ld.w      	r3, (r3, 0)
    b340:	7cc8      	mult      	r3, r2
    b342:	e9a30003 	bhsz      	r3, 0xb348	// b348 <ck860_playback+0x1c8>
    b346:	2306      	addi      	r3, 7
    b348:	5363      	asri      	r3, r3, 3
    b34a:	6c4f      	mov      	r1, r3
    b34c:	e4681007 	subi      	r3, r8, 8
    b350:	e4481007 	subi      	r2, r8, 8
    b354:	9240      	ld.w      	r2, (r2, 0)
    b356:	6084      	addu      	r2, r1
    b358:	b340      	st.w      	r2, (r3, 0)
	while(wcount > 0){
    b35a:	e4681003 	subi      	r3, r8, 4
    b35e:	9360      	ld.w      	r3, (r3, 0)
    b360:	e943ff59 	bhz      	r3, 0xb212	// b212 <ck860_playback+0x92>
		}
	
	}

	printf("end of test.wav play!===========\n");
    b364:	110e      	lrw      	r0, 0xdd8c	// b41c <ck860_playback+0x29c>
    b366:	eae0001c 	jsri      	0x0	// from address pool at 0xb3d4
    b36a:	c4004820 	lsli      	r0, r0, 0
		
	}
#endif


    snd_pcm_drain(handle);
    b36e:	e468101b 	subi      	r3, r8, 28
    b372:	9300      	ld.w      	r0, (r3, 0)
    b374:	eae0002b 	jsri      	0x0	// from address pool at 0xb420
    b378:	c4004820 	lsli      	r0, r0, 0
    snd_pcm_close(handle);
    b37c:	e468101b 	subi      	r3, r8, 28
    b380:	9300      	ld.w      	r0, (r3, 0)
    b382:	eae00029 	jsri      	0x0	// from address pool at 0xb424
    b386:	c4004820 	lsli      	r0, r0, 0


	munmap(play_vir,pMsg_playback->msg_body->size);
    b38a:	e4681017 	subi      	r3, r8, 24
    b38e:	9360      	ld.w      	r3, (r3, 0)
    b390:	9361      	ld.w      	r3, (r3, 0x4)
    b392:	9341      	ld.w      	r2, (r3, 0x4)
    b394:	e4681007 	subi      	r3, r8, 8
    b398:	6c4b      	mov      	r1, r2
    b39a:	9300      	ld.w      	r0, (r3, 0)
    b39c:	eae00023 	jsri      	0x0	// from address pool at 0xb428
    b3a0:	c4004820 	lsli      	r0, r0, 0
	close(fd_mem);
    b3a4:	1162      	lrw      	r3, 0x10020	// b42c <ck860_playback+0x2ac>
    b3a6:	9360      	ld.w      	r3, (r3, 0)
    b3a8:	6c0f      	mov      	r0, r3
    b3aa:	eae00022 	jsri      	0x0	// from address pool at 0xb430
    b3ae:	c4004820 	lsli      	r0, r0, 0
	printf("ck860 playback test.wav finish!\n");
    b3b2:	1101      	lrw      	r0, 0xddb0	// b434 <ck860_playback+0x2b4>
    b3b4:	eae00008 	jsri      	0x0	// from address pool at 0xb3d4
    b3b8:	c4004820 	lsli      	r0, r0, 0
	return 0;
    b3bc:	3300      	movi      	r3, 0

}
    b3be:	6c0f      	mov      	r0, r3
    b3c0:	6fa3      	mov      	sp, r8
    b3c2:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    b3c6:	d90e2001 	ld.w      	r8, (sp, 0x4)
    b3ca:	9880      	ld.w      	r4, (sp, 0)
    b3cc:	1403      	addi      	sp, sp, 12
    b3ce:	783c      	rts
    b3d0:	0000dd18 	.long	0x0000dd18
    b3d4:	00000000 	.long	0x00000000
    b3d8:	0000ab5c 	.long	0x0000ab5c
    b3dc:	0001002c 	.long	0x0001002c
    b3e0:	00010030 	.long	0x00010030
    b3e4:	00010024 	.long	0x00010024
    b3e8:	0000dd30 	.long	0x0000dd30
	...
    b3fc:	0000dd50 	.long	0x0000dd50
	...
    b408:	0000dd64 	.long	0x0000dd64
    b40c:	00000000 	.long	0x00000000
    b410:	0000dd74 	.long	0x0000dd74
	...
    b41c:	0000dd8c 	.long	0x0000dd8c
	...
    b42c:	00010020 	.long	0x00010020
    b430:	00000000 	.long	0x00000000
    b434:	0000ddb0 	.long	0x0000ddb0

0000b438 <ck860_play_audio_pthread>:

/*
* 接收810 消息后。播放音频
*/
void* ck860_play_audio_pthread(void *arg)
{
    b438:	1423      	subi      	sp, sp, 12
    b43a:	b880      	st.w      	r4, (sp, 0)
    b43c:	dd0e2001 	st.w      	r8, (sp, 0x4)
    b440:	ddee2002 	st.w      	r15, (sp, 0x8)
    b444:	6e3b      	mov      	r8, sp
    b446:	1529      	subi      	sp, sp, 164
    b448:	e468109f 	subi      	r3, r8, 160
    b44c:	b300      	st.w      	r0, (r3, 0)

	int ret = 1;
    b44e:	e4681007 	subi      	r3, r8, 8
    b452:	3201      	movi      	r2, 1
    b454:	b340      	st.w      	r2, (r3, 0)
	int len = 0;//读写消息的长度
    b456:	e468101b 	subi      	r3, r8, 28
    b45a:	3200      	movi      	r2, 0
    b45c:	b340      	st.w      	r2, (r3, 0)
	snd_pcm_t*		handle; 	
	GV_IPCM_HANDLE_ATTR_S* stConnectAttr = (GV_IPCM_HANDLE_ATTR_S*)arg;
    b45e:	e468100b 	subi      	r3, r8, 12
    b462:	e448109f 	subi      	r2, r8, 160
    b466:	9240      	ld.w      	r2, (r2, 0)
    b468:	b340      	st.w      	r2, (r3, 0)

	printf("ck860 ipcm audio pthread is run...\n");
    b46a:	1309      	lrw      	r0, 0xddd0	// b60c <ck860_play_audio_pthread+0x1d4>
    b46c:	eae00069 	jsri      	0x0	// from address pool at 0xb610
    b470:	c4004820 	lsli      	r0, r0, 0

	GV_IPCM_MSG_POOL_S* fd_pool =(GV_IPCM_MSG_POOL_S* )malloc(sizeof(GV_IPCM_MSG_POOL_S));
    b474:	e488100f 	subi      	r4, r8, 16
    b478:	3014      	movi      	r0, 20
    b47a:	eae00067 	jsri      	0x0	// from address pool at 0xb614
    b47e:	c4004820 	lsli      	r0, r0, 0
    b482:	6cc3      	mov      	r3, r0
    b484:	b460      	st.w      	r3, (r4, 0)
	if(!fd_pool)
    b486:	e468100f 	subi      	r3, r8, 16
    b48a:	9360      	ld.w      	r3, (r3, 0)
    b48c:	e923000d 	bnez      	r3, 0xb4a6	// b4a6 <ck860_play_audio_pthread+0x6e>
	{
		printf("malloc mem for fd_pool fail!\n");
    b490:	1302      	lrw      	r0, 0xddf4	// b618 <ck860_play_audio_pthread+0x1e0>
    b492:	eae00060 	jsri      	0x0	// from address pool at 0xb610
    b496:	c4004820 	lsli      	r0, r0, 0
		exit(-1);
    b49a:	3000      	movi      	r0, 0
    b49c:	2800      	subi      	r0, 1
    b49e:	eae00060 	jsri      	0x0	// from address pool at 0xb61c
    b4a2:	c4004820 	lsli      	r0, r0, 0
		 printf("Connect fail\n");
		 exit(-1);
	}
	*/

	GV_IPCM_TryConnect(stConnectAttr,fd_pool);
    b4a6:	e448100f 	subi      	r2, r8, 16
    b4aa:	e468100b 	subi      	r3, r8, 12
    b4ae:	9220      	ld.w      	r1, (r2, 0)
    b4b0:	9300      	ld.w      	r0, (r3, 0)
    b4b2:	e000051b 	bsr      	0xbee8	// bee8 <GV_IPCM_TryConnect>
    b4b6:	c4004820 	lsli      	r0, r0, 0

	while (GV_FALSE == GV_IPCM_CheckConnected(fd_pool))
    b4ba:	040e      	br      	0xb4d6	// b4d6 <ck860_play_audio_pthread+0x9e>
    {
        printf("Wait connection ok\n");
    b4bc:	121a      	lrw      	r0, 0xde14	// b624 <ck860_play_audio_pthread+0x1ec>
    b4be:	eae00055 	jsri      	0x0	// from address pool at 0xb610
    b4c2:	c4004820 	lsli      	r0, r0, 0
        usleep(200000);
    b4c6:	ea00c350 	movi      	r0, 50000
    b4ca:	c4404900 	rotli      	r0, r0, 2
    b4ce:	eae00057 	jsri      	0x0	// from address pool at 0xb628
    b4d2:	c4004820 	lsli      	r0, r0, 0
	while (GV_FALSE == GV_IPCM_CheckConnected(fd_pool))
    b4d6:	e468100f 	subi      	r3, r8, 16
    b4da:	9300      	ld.w      	r0, (r3, 0)
    b4dc:	e0000a80 	bsr      	0xc9dc	// c9dc <GV_IPCM_CheckConnected>
    b4e0:	c4004820 	lsli      	r0, r0, 0
    b4e4:	6cc3      	mov      	r3, r0
    b4e6:	e903ffeb 	bez      	r3, 0xb4bc	// b4bc <ck860_play_audio_pthread+0x84>
    }

	
	printf("ck860 connect to target successful!\n");
    b4ea:	1212      	lrw      	r0, 0xde28	// b630 <ck860_play_audio_pthread+0x1f8>
    b4ec:	eae00049 	jsri      	0x0	// from address pool at 0xb610
    b4f0:	c4004820 	lsli      	r0, r0, 0

/*for test ipcm connect */
#if 1
	
	char zxf[64];
	while (0 != strncmp(fgets(zxf, 64, stdin), "q", 1))
    b4f4:	040e      	br      	0xb510	// b510 <ck860_play_audio_pthread+0xd8>
	{
		printf("Enter q to exit\n");
    b4f6:	1210      	lrw      	r0, 0xde4c	// b634 <ck860_play_audio_pthread+0x1fc>
    b4f8:	eae00046 	jsri      	0x0	// from address pool at 0xb610
    b4fc:	c4004820 	lsli      	r0, r0, 0
		usleep(200000);
    b500:	ea00c350 	movi      	r0, 50000
    b504:	c4404900 	rotli      	r0, r0, 2
    b508:	eae00048 	jsri      	0x0	// from address pool at 0xb628
    b50c:	c4004820 	lsli      	r0, r0, 0
	while (0 != strncmp(fgets(zxf, 64, stdin), "q", 1))
    b510:	126a      	lrw      	r3, 0	// b638 <ck860_play_audio_pthread+0x200>
    b512:	9340      	ld.w      	r2, (r3, 0)
    b514:	e468105b 	subi      	r3, r8, 92
    b518:	3140      	movi      	r1, 64
    b51a:	6c0f      	mov      	r0, r3
    b51c:	eae00048 	jsri      	0x0	// from address pool at 0xb63c
    b520:	c4004820 	lsli      	r0, r0, 0
    b524:	6cc3      	mov      	r3, r0
    b526:	8360      	ld.b      	r3, (r3, 0)
    b528:	748c      	zextb      	r2, r3
    b52a:	1266      	lrw      	r3, 0xde5c	// b640 <ck860_play_audio_pthread+0x208>
    b52c:	8360      	ld.b      	r3, (r3, 0)
    b52e:	74cc      	zextb      	r3, r3
    b530:	64ca      	cmpne      	r2, r3
    b532:	0be2      	bt      	0xb4f6	// b4f6 <ck860_play_audio_pthread+0xbe>
	}
#endif

	
	GV_IPCM_MSG_S* pMsg =  GV_IPCM_CreateMessage(fd_pool,0 , 0, 0);
    b534:	e4881013 	subi      	r4, r8, 20
    b538:	e408100f 	subi      	r0, r8, 16
    b53c:	3300      	movi      	r3, 0
    b53e:	3200      	movi      	r2, 0
    b540:	3100      	movi      	r1, 0
    b542:	9000      	ld.w      	r0, (r0, 0)
    b544:	e00001c0 	bsr      	0xb8c4	// b8c4 <GV_IPCM_CreateMessage>
    b548:	c4004820 	lsli      	r0, r0, 0
    b54c:	b400      	st.w      	r0, (r4, 0)
	
	while(1)
	{
		ret = GV_IPCM_ReceiveMessage(fd_pool, pMsg,&len);
    b54e:	e448101b 	subi      	r2, r8, 28
    b552:	e4281013 	subi      	r1, r8, 20
    b556:	e468100f 	subi      	r3, r8, 16
    b55a:	9120      	ld.w      	r1, (r1, 0)
    b55c:	9300      	ld.w      	r0, (r3, 0)
    b55e:	e0000701 	bsr      	0xc360	// c360 <GV_IPCM_ReceiveMessage>
    b562:	c4004820 	lsli      	r0, r0, 0
    b566:	6c83      	mov      	r2, r0
    b568:	e4681007 	subi      	r3, r8, 8
    b56c:	b340      	st.w      	r2, (r3, 0)
		if(GV_SUCCESS != ret)
    b56e:	e4681007 	subi      	r3, r8, 8
    b572:	9360      	ld.w      	r3, (r3, 0)
    b574:	e903000b 	bez      	r3, 0xb58a	// b58a <ck860_play_audio_pthread+0x152>
		{
			printf("remote node is disconneted returnNum[%d] \n",ret);
    b578:	e4681007 	subi      	r3, r8, 8
    b57c:	9320      	ld.w      	r1, (r3, 0)
    b57e:	1114      	lrw      	r0, 0xde60	// b64c <ck860_play_audio_pthread+0x214>
    b580:	eae00034 	jsri      	0x0	// from address pool at 0xb650
    b584:	c4004820 	lsli      	r0, r0, 0
			break;
    b588:	04bb      	br      	0xb6fe	// b6fe <ck860_play_audio_pthread+0x2c6>
		} else if (0 == len)
    b58a:	e468101b 	subi      	r3, r8, 28
    b58e:	9360      	ld.w      	r3, (r3, 0)
    b590:	e923000c 	bnez      	r3, 0xb5a8	// b5a8 <ck860_play_audio_pthread+0x170>
		{
			printf("GV_IPCM_ReceiveMessage len: %d \n",len);
    b594:	e468101b 	subi      	r3, r8, 28
    b598:	9360      	ld.w      	r3, (r3, 0)
    b59a:	6c4f      	mov      	r1, r3
    b59c:	110e      	lrw      	r0, 0xde8c	// b654 <ck860_play_audio_pthread+0x21c>
    b59e:	eae0002d 	jsri      	0x0	// from address pool at 0xb650
    b5a2:	c4004820 	lsli      	r0, r0, 0
			break;
    b5a6:	04ac      	br      	0xb6fe	// b6fe <ck860_play_audio_pthread+0x2c6>
		}	
		//3.打印消息,或消息处理
printf("Message phy addr:0x%#x ,size:%d,CMD:%d,IsResp:%d \n",pMsg->msg_body->start,pMsg->msg_body->size,pMsg->msg_body->u32CMD,pMsg->msg_body->bIsResp);
    b5a8:	e4681013 	subi      	r3, r8, 20
    b5ac:	9360      	ld.w      	r3, (r3, 0)
    b5ae:	9361      	ld.w      	r3, (r3, 0x4)
    b5b0:	9320      	ld.w      	r1, (r3, 0)
    b5b2:	e4681013 	subi      	r3, r8, 20
    b5b6:	9360      	ld.w      	r3, (r3, 0)
    b5b8:	9361      	ld.w      	r3, (r3, 0x4)
    b5ba:	9341      	ld.w      	r2, (r3, 0x4)
    b5bc:	e4681013 	subi      	r3, r8, 20
    b5c0:	9360      	ld.w      	r3, (r3, 0)
    b5c2:	9361      	ld.w      	r3, (r3, 0x4)
    b5c4:	9302      	ld.w      	r0, (r3, 0x8)
    b5c6:	e4681013 	subi      	r3, r8, 20
    b5ca:	9360      	ld.w      	r3, (r3, 0)
    b5cc:	9361      	ld.w      	r3, (r3, 0x4)
    b5ce:	9363      	ld.w      	r3, (r3, 0xc)
    b5d0:	b860      	st.w      	r3, (sp, 0)
    b5d2:	6cc3      	mov      	r3, r0
    b5d4:	1101      	lrw      	r0, 0xdeb0	// b658 <ck860_play_audio_pthread+0x220>
    b5d6:	eae0001f 	jsri      	0x0	// from address pool at 0xb650
    b5da:	c4004820 	lsli      	r0, r0, 0

		switch (pMsg->msg_body->u32CMD)
    b5de:	e4681013 	subi      	r3, r8, 20
    b5e2:	9360      	ld.w      	r3, (r3, 0)
    b5e4:	9361      	ld.w      	r3, (r3, 0x4)
    b5e6:	9362      	ld.w      	r3, (r3, 0x8)
    b5e8:	3b44      	cmpnei      	r3, 4
    b5ea:	0c3b      	bf      	0xb660	// b660 <ck860_play_audio_pthread+0x228>
    b5ec:	3b45      	cmpnei      	r3, 5
    b5ee:	0c4d      	bf      	0xb688	// b688 <ck860_play_audio_pthread+0x250>
    b5f0:	3b43      	cmpnei      	r3, 3
    b5f2:	0845      	bt      	0xb67c	// b67c <ck860_play_audio_pthread+0x244>
		{
			case IPCM_CMD_SET_PARAMETER_AUDIO:
					//消息处理
				handle =ck860_set_parameter_audio(pMsg);
    b5f4:	e4881003 	subi      	r4, r8, 4
    b5f8:	e4681013 	subi      	r3, r8, 20
    b5fc:	9300      	ld.w      	r0, (r3, 0)
    b5fe:	e3fffb37 	bsr      	0xac6c	// ac6c <ck860_set_parameter_audio>
    b602:	c4004820 	lsli      	r0, r0, 0
    b606:	b400      	st.w      	r0, (r4, 0)
				break;
    b608:	0441      	br      	0xb68a	// b68a <ck860_play_audio_pthread+0x252>
    b60a:	0000      	.short	0x0000
    b60c:	0000ddd0 	.long	0x0000ddd0
	...
    b618:	0000ddf4 	.long	0x0000ddf4
    b61c:	00000000 	.long	0x00000000
    b620:	0000bee8 	.long	0x0000bee8
    b624:	0000de14 	.long	0x0000de14
    b628:	00000000 	.long	0x00000000
    b62c:	0000c9dc 	.long	0x0000c9dc
    b630:	0000de28 	.long	0x0000de28
    b634:	0000de4c 	.long	0x0000de4c
	...
    b640:	0000de5c 	.long	0x0000de5c
    b644:	0000b8c4 	.long	0x0000b8c4
    b648:	0000c360 	.long	0x0000c360
    b64c:	0000de60 	.long	0x0000de60
    b650:	00000000 	.long	0x00000000
    b654:	0000de8c 	.long	0x0000de8c
    b658:	0000deb0 	.long	0x0000deb0
    b65c:	0000ac6c 	.long	0x0000ac6c
			case IPCM_CMD_PLAY_AUDIO:
				//播发音频
				//ret = ck860_play_audio();
				  ret = ck860_playback(pMsg,handle);
    b660:	e4881007 	subi      	r4, r8, 8
    b664:	e4481003 	subi      	r2, r8, 4
    b668:	e4681013 	subi      	r3, r8, 20
    b66c:	9220      	ld.w      	r1, (r2, 0)
    b66e:	9300      	ld.w      	r0, (r3, 0)
    b670:	e3fffd88 	bsr      	0xb180	// b180 <ck860_playback>
    b674:	c4004820 	lsli      	r0, r0, 0
    b678:	b400      	st.w      	r0, (r4, 0)
				break;
    b67a:	0408      	br      	0xb68a	// b68a <ck860_play_audio_pthread+0x252>
			case IPCM_CMD_RECORD_AUDIO:
				//录音record
			//	ret = record_audio();
				break;
			default:
				printf("receive cmd is not find!\n");
    b67c:	111f      	lrw      	r0, 0xdee4	// b778 <ck860_play_audio_pthread+0x340>
    b67e:	eae00040 	jsri      	0x0	// from address pool at 0xb77c
    b682:	c4004820 	lsli      	r0, r0, 0
				break;
    b686:	0402      	br      	0xb68a	// b68a <ck860_play_audio_pthread+0x252>
				break;
    b688:	6c00      	or      	r0, r0
		}
		if(pMsg->msg_body->bIsResp) //返回同步消息
    b68a:	e4681013 	subi      	r3, r8, 20
    b68e:	9360      	ld.w      	r3, (r3, 0)
    b690:	9361      	ld.w      	r3, (r3, 0x4)
    b692:	9363      	ld.w      	r3, (r3, 0xc)
    b694:	e903ff5d 	bez      	r3, 0xb54e	// b54e <ck860_play_audio_pthread+0x116>
		{
			GV_IPCM_MSG_S* pMsgResp =  GV_IPCM_CreateMessage(fd_pool,0 , 0, 0);
    b698:	e4881017 	subi      	r4, r8, 24
    b69c:	e408100f 	subi      	r0, r8, 16
    b6a0:	3300      	movi      	r3, 0
    b6a2:	3200      	movi      	r2, 0
    b6a4:	3100      	movi      	r1, 0
    b6a6:	9000      	ld.w      	r0, (r0, 0)
    b6a8:	e000010e 	bsr      	0xb8c4	// b8c4 <GV_IPCM_CreateMessage>
    b6ac:	c4004820 	lsli      	r0, r0, 0
    b6b0:	b400      	st.w      	r0, (r4, 0)
			ret = GV_IPCM_SendMessage(pMsgResp, fd_pool);
    b6b2:	e448100f 	subi      	r2, r8, 16
    b6b6:	e4681017 	subi      	r3, r8, 24
    b6ba:	9220      	ld.w      	r1, (r2, 0)
    b6bc:	9300      	ld.w      	r0, (r3, 0)
    b6be:	e0000589 	bsr      	0xc1d0	// c1d0 <GV_IPCM_SendMessage>
    b6c2:	c4004820 	lsli      	r0, r0, 0
    b6c6:	6c83      	mov      	r2, r0
    b6c8:	e4681007 	subi      	r3, r8, 8
    b6cc:	b340      	st.w      	r2, (r3, 0)
			if(ret != GV_SUCCESS)
    b6ce:	e4681007 	subi      	r3, r8, 8
    b6d2:	9360      	ld.w      	r3, (r3, 0)
    b6d4:	e903000d 	bez      	r3, 0xb6ee	// b6ee <ck860_play_audio_pthread+0x2b6>
			{
				printf("send message fail!\n");
    b6d8:	110c      	lrw      	r0, 0xdf00	// b788 <ck860_play_audio_pthread+0x350>
    b6da:	eae00029 	jsri      	0x0	// from address pool at 0xb77c
    b6de:	c4004820 	lsli      	r0, r0, 0
				exit(-1);
    b6e2:	3000      	movi      	r0, 0
    b6e4:	2800      	subi      	r0, 1
    b6e6:	eae0002a 	jsri      	0x0	// from address pool at 0xb78c
    b6ea:	c4004820 	lsli      	r0, r0, 0
			}
			GV_IPCM_DestroyMessage(pMsgResp); 
    b6ee:	e4681017 	subi      	r3, r8, 24
    b6f2:	9300      	ld.w      	r0, (r3, 0)
    b6f4:	e000024c 	bsr      	0xbb8c	// bb8c <GV_IPCM_DestroyMessage>
    b6f8:	c4004820 	lsli      	r0, r0, 0
		ret = GV_IPCM_ReceiveMessage(fd_pool, pMsg,&len);
    b6fc:	0729      	br      	0xb54e	// b54e <ck860_play_audio_pthread+0x116>
		}
		
	}

	GV_IPCM_DestroyMessage(pMsg); 
    b6fe:	e4681013 	subi      	r3, r8, 20
    b702:	9300      	ld.w      	r0, (r3, 0)
    b704:	e0000244 	bsr      	0xbb8c	// bb8c <GV_IPCM_DestroyMessage>
    b708:	c4004820 	lsli      	r0, r0, 0
	printf("Enter q to exit\n");
    b70c:	1102      	lrw      	r0, 0xde4c	// b794 <ck860_play_audio_pthread+0x35c>
    b70e:	eae0001c 	jsri      	0x0	// from address pool at 0xb77c
    b712:	c4004820 	lsli      	r0, r0, 0
	char cmd[64];

	while (0 != strncmp(fgets(cmd, 64, stdin), "q", 1))
    b716:	0406      	br      	0xb722	// b722 <ck860_play_audio_pthread+0x2ea>
	{
		printf("Enter q to exit\n");
    b718:	101f      	lrw      	r0, 0xde4c	// b794 <ck860_play_audio_pthread+0x35c>
    b71a:	eae00019 	jsri      	0x0	// from address pool at 0xb77c
    b71e:	c4004820 	lsli      	r0, r0, 0
	while (0 != strncmp(fgets(cmd, 64, stdin), "q", 1))
    b722:	107e      	lrw      	r3, 0	// b798 <ck860_play_audio_pthread+0x360>
    b724:	9340      	ld.w      	r2, (r3, 0)
    b726:	e468109b 	subi      	r3, r8, 156
    b72a:	3140      	movi      	r1, 64
    b72c:	6c0f      	mov      	r0, r3
    b72e:	eae0001c 	jsri      	0x0	// from address pool at 0xb79c
    b732:	c4004820 	lsli      	r0, r0, 0
    b736:	6cc3      	mov      	r3, r0
    b738:	8360      	ld.b      	r3, (r3, 0)
    b73a:	748c      	zextb      	r2, r3
    b73c:	1079      	lrw      	r3, 0xde5c	// b7a0 <ck860_play_audio_pthread+0x368>
    b73e:	8360      	ld.b      	r3, (r3, 0)
    b740:	74cc      	zextb      	r3, r3
    b742:	64ca      	cmpne      	r2, r3
    b744:	0bea      	bt      	0xb718	// b718 <ck860_play_audio_pthread+0x2e0>
	}
	GV_IPCM_Disconnect(fd_pool);
    b746:	e468100f 	subi      	r3, r8, 16
    b74a:	9300      	ld.w      	r0, (r3, 0)
    b74c:	e00004c0 	bsr      	0xc0cc	// c0cc <GV_IPCM_Disconnect>
    b750:	c4004820 	lsli      	r0, r0, 0

	printf("CK860 ipcm audio thread is exit.....\n");
    b754:	1015      	lrw      	r0, 0xdf14	// b7a8 <ck860_play_audio_pthread+0x370>
    b756:	eae0000a 	jsri      	0x0	// from address pool at 0xb77c
    b75a:	c4004820 	lsli      	r0, r0, 0
	return NULL;
    b75e:	3300      	movi      	r3, 0

}
    b760:	6c0f      	mov      	r0, r3
    b762:	6fa3      	mov      	sp, r8
    b764:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    b768:	d90e2001 	ld.w      	r8, (sp, 0x4)
    b76c:	9880      	ld.w      	r4, (sp, 0)
    b76e:	1403      	addi      	sp, sp, 12
    b770:	783c      	rts
    b772:	0000      	.short	0x0000
    b774:	0000b180 	.long	0x0000b180
    b778:	0000dee4 	.long	0x0000dee4
    b77c:	00000000 	.long	0x00000000
    b780:	0000b8c4 	.long	0x0000b8c4
    b784:	0000c1d0 	.long	0x0000c1d0
    b788:	0000df00 	.long	0x0000df00
    b78c:	00000000 	.long	0x00000000
    b790:	0000bb8c 	.long	0x0000bb8c
    b794:	0000de4c 	.long	0x0000de4c
	...
    b7a0:	0000de5c 	.long	0x0000de5c
    b7a4:	0000c0cc 	.long	0x0000c0cc
    b7a8:	0000df14 	.long	0x0000df14

0000b7ac <main>:
int main()
{
    b7ac:	1422      	subi      	sp, sp, 8
    b7ae:	dd0e2000 	st.w      	r8, (sp, 0)
    b7b2:	ddee2001 	st.w      	r15, (sp, 0x4)
    b7b6:	6e3b      	mov      	r8, sp
    b7b8:	1434      	subi      	sp, sp, 80

	GV_IPCM_HANDLE_ATTR_S stConnectAttr;
	stConnectAttr.target = TARGET_NODE;
    b7ba:	e468100b 	subi      	r3, r8, 12
    b7be:	3201      	movi      	r2, 1
    b7c0:	b340      	st.w      	r2, (r3, 0)
	stConnectAttr.port = 1;
    b7c2:	e468100b 	subi      	r3, r8, 12
    b7c6:	3201      	movi      	r2, 1
    b7c8:	b341      	st.w      	r2, (r3, 0x4)
//	stConnectAttr.priority = HANDLE_MSG_NORMAL;//msg_priority
	stConnectAttr.priority = HANDLE_MSG_PRIORITY;
    b7ca:	e468100b 	subi      	r3, r8, 12
    b7ce:	3201      	movi      	r2, 1
    b7d0:	b342      	st.w      	r2, (r3, 0x8)

//	ck860_play(&stConnectAttr);
	pthread_t audiopid;
			
	if (0 != pthread_create(&audiopid, NULL, ck860_play_audio_pthread, &stConnectAttr))
    b7d2:	e468100b 	subi      	r3, r8, 12
    b7d6:	e408100f 	subi      	r0, r8, 16
    b7da:	1142      	lrw      	r2, 0xb438	// b860 <main+0xb4>
    b7dc:	3100      	movi      	r1, 0
    b7de:	eae00022 	jsri      	0x0	// from address pool at 0xb864
    b7e2:	c4004820 	lsli      	r0, r0, 0
    b7e6:	6cc3      	mov      	r3, r0
    b7e8:	e903000d 	bez      	r3, 0xb802	// b802 <main+0x56>
	{
		printf("pthread_create ipcm_audio_pthread fail\n");
    b7ec:	101f      	lrw      	r0, 0xdf3c	// b868 <main+0xbc>
    b7ee:	eae00020 	jsri      	0x0	// from address pool at 0xb86c
    b7f2:	c4004820 	lsli      	r0, r0, 0
		exit(-1);
    b7f6:	3000      	movi      	r0, 0
    b7f8:	2800      	subi      	r0, 1
    b7fa:	eae0001e 	jsri      	0x0	// from address pool at 0xb870
    b7fe:	c4004820 	lsli      	r0, r0, 0
	}	

	pthread_join(audiopid, NULL);//阻塞等待子线程audiopid完成
    b802:	e468100f 	subi      	r3, r8, 16
    b806:	9360      	ld.w      	r3, (r3, 0)
    b808:	3100      	movi      	r1, 0
    b80a:	6c0f      	mov      	r0, r3
    b80c:	eae0001a 	jsri      	0x0	// from address pool at 0xb874
    b810:	c4004820 	lsli      	r0, r0, 0
	
	printf("THE audiopid pthread is finish!\n");
    b814:	1019      	lrw      	r0, 0xdf64	// b878 <main+0xcc>
    b816:	eae00016 	jsri      	0x0	// from address pool at 0xb86c
    b81a:	c4004820 	lsli      	r0, r0, 0
	char cmd[64];

    while (0 != strncmp(fgets(cmd, 64, stdin), "q", 1))
    b81e:	0406      	br      	0xb82a	// b82a <main+0x7e>
    {
        printf("Enter q to exit\n");
    b820:	1017      	lrw      	r0, 0xde4c	// b87c <main+0xd0>
    b822:	eae00013 	jsri      	0x0	// from address pool at 0xb86c
    b826:	c4004820 	lsli      	r0, r0, 0
    while (0 != strncmp(fgets(cmd, 64, stdin), "q", 1))
    b82a:	1076      	lrw      	r3, 0	// b880 <main+0xd4>
    b82c:	9340      	ld.w      	r2, (r3, 0)
    b82e:	e468104f 	subi      	r3, r8, 80
    b832:	3140      	movi      	r1, 64
    b834:	6c0f      	mov      	r0, r3
    b836:	eae00014 	jsri      	0x0	// from address pool at 0xb884
    b83a:	c4004820 	lsli      	r0, r0, 0
    b83e:	6cc3      	mov      	r3, r0
    b840:	8360      	ld.b      	r3, (r3, 0)
    b842:	748c      	zextb      	r2, r3
    b844:	1071      	lrw      	r3, 0xde5c	// b888 <main+0xdc>
    b846:	8360      	ld.b      	r3, (r3, 0)
    b848:	74cc      	zextb      	r3, r3
    b84a:	64ca      	cmpne      	r2, r3
    b84c:	0bea      	bt      	0xb820	// b820 <main+0x74>
    }

	return 0;
    b84e:	3300      	movi      	r3, 0
}
    b850:	6c0f      	mov      	r0, r3
    b852:	6fa3      	mov      	sp, r8
    b854:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    b858:	d90e2000 	ld.w      	r8, (sp, 0)
    b85c:	1402      	addi      	sp, sp, 8
    b85e:	783c      	rts
    b860:	0000b438 	.long	0x0000b438
    b864:	00000000 	.long	0x00000000
    b868:	0000df3c 	.long	0x0000df3c
	...
    b878:	0000df64 	.long	0x0000df64
    b87c:	0000de4c 	.long	0x0000de4c
	...
    b888:	0000de5c 	.long	0x0000de5c

0000b88c <pr>:
	pr(s); \
	pr("\r\n"); \
} while (0)

static inline void pr(const char *fmt, ...)
{
    b88c:	1424      	subi      	sp, sp, 16
    b88e:	b863      	st.w      	r3, (sp, 0xc)
    b890:	b842      	st.w      	r2, (sp, 0x8)
    b892:	b821      	st.w      	r1, (sp, 0x4)
    b894:	b800      	st.w      	r0, (sp, 0)
    b896:	1422      	subi      	sp, sp, 8
    b898:	dd0e2000 	st.w      	r8, (sp, 0)
    b89c:	ddee2001 	st.w      	r15, (sp, 0x4)
    b8a0:	6e3b      	mov      	r8, sp
	printf(fmt);
    b8a2:	e4680007 	addi      	r3, r8, 8
    b8a6:	9300      	ld.w      	r0, (r3, 0)
    b8a8:	eae00006 	jsri      	0x0	// from address pool at 0xb8c0
    b8ac:	c4004820 	lsli      	r0, r0, 0
}
    b8b0:	6c00      	or      	r0, r0
    b8b2:	6fa3      	mov      	sp, r8
    b8b4:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    b8b8:	d90e2000 	ld.w      	r8, (sp, 0)
    b8bc:	1406      	addi      	sp, sp, 24
    b8be:	783c      	rts
    b8c0:	00000000 	.long	0x00000000

0000b8c4 <GV_IPCM_CreateMessage>:
#define IPCM_POOL_START 0x40000000 //high 1G
#define IPCM_POOL_SIZE  0x10000000 //SIZE 256M
//#define IPCM_POOL_SIZE  0x20000000 //size 512M

GV_IPCM_MSG_S* GV_IPCM_CreateMessage(GV_IPCM_MSG_POOL_S *msg_pool,GV_U32 size,GV_U32 u32CMD,GV_BOOL bIsResp)
{
    b8c4:	1423      	subi      	sp, sp, 12
    b8c6:	b880      	st.w      	r4, (sp, 0)
    b8c8:	dd0e2001 	st.w      	r8, (sp, 0x4)
    b8cc:	ddee2002 	st.w      	r15, (sp, 0x8)
    b8d0:	6e3b      	mov      	r8, sp
    b8d2:	1426      	subi      	sp, sp, 24
    b8d4:	e588100b 	subi      	r12, r8, 12
    b8d8:	dc0c2000 	st.w      	r0, (r12, 0)
    b8dc:	e408100f 	subi      	r0, r8, 16
    b8e0:	b020      	st.w      	r1, (r0, 0)
    b8e2:	e4281013 	subi      	r1, r8, 20
    b8e6:	b140      	st.w      	r2, (r1, 0)
    b8e8:	e4481017 	subi      	r2, r8, 24
    b8ec:	b260      	st.w      	r3, (r2, 0)
	GV_IPCM_MSG_S* pMsg = (GV_IPCM_MSG_S*)malloc(sizeof(GV_IPCM_MSG_S));
    b8ee:	e4881003 	subi      	r4, r8, 4
    b8f2:	3008      	movi      	r0, 8
    b8f4:	eae00096 	jsri      	0x0	// from address pool at 0xbb4c
    b8f8:	c4004820 	lsli      	r0, r0, 0
    b8fc:	6cc3      	mov      	r3, r0
    b8fe:	b460      	st.w      	r3, (r4, 0)
	if(!pMsg)
    b900:	e4681003 	subi      	r3, r8, 4
    b904:	9360      	ld.w      	r3, (r3, 0)
    b906:	e9230019 	bnez      	r3, 0xb938	// b938 <GV_IPCM_CreateMessage+0x74>
	{
		ipcm_trace(TRACE_ZXF_DEBUG,"malloc memory for ipcm message fail.");
    b90a:	321f      	movi      	r2, 31
    b90c:	ea810091 	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    b910:	ea800091 	lrw      	r0, 0xdf84	// bb54 <GV_IPCM_CreateMessage+0x290>
    b914:	e3ffffbc 	bsr      	0xb88c	// b88c <pr>
    b918:	c4004820 	lsli      	r0, r0, 0
    b91c:	ea800090 	lrw      	r0, 0xdf94	// bb5c <GV_IPCM_CreateMessage+0x298>
    b920:	e3ffffb6 	bsr      	0xb88c	// b88c <pr>
    b924:	c4004820 	lsli      	r0, r0, 0
    b928:	ea80008e 	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    b92c:	e3ffffb0 	bsr      	0xb88c	// b88c <pr>
    b930:	c4004820 	lsli      	r0, r0, 0
		return NULL;
    b934:	3300      	movi      	r3, 0
    b936:	0502      	br      	0xbb3a	// bb3a <GV_IPCM_CreateMessage+0x276>
	}
	pMsg->msg_body = (struct ipcm_msg_body*)malloc(sizeof(struct ipcm_msg_body));
    b938:	3010      	movi      	r0, 16
    b93a:	eae00085 	jsri      	0x0	// from address pool at 0xbb4c
    b93e:	c4004820 	lsli      	r0, r0, 0
    b942:	6cc3      	mov      	r3, r0
    b944:	6c8f      	mov      	r2, r3
    b946:	e4681003 	subi      	r3, r8, 4
    b94a:	9360      	ld.w      	r3, (r3, 0)
    b94c:	b341      	st.w      	r2, (r3, 0x4)
	if(!pMsg->msg_body)
    b94e:	e4681003 	subi      	r3, r8, 4
    b952:	9360      	ld.w      	r3, (r3, 0)
    b954:	9361      	ld.w      	r3, (r3, 0x4)
    b956:	e9230015 	bnez      	r3, 0xb980	// b980 <GV_IPCM_CreateMessage+0xbc>
	{
		ipcm_trace(TRACE_ZXF_DEBUG,"malloc memory for message body fail.");
    b95a:	3225      	movi      	r2, 37
    b95c:	133d      	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    b95e:	131e      	lrw      	r0, 0xdf84	// bb54 <GV_IPCM_CreateMessage+0x290>
    b960:	e3ffff96 	bsr      	0xb88c	// b88c <pr>
    b964:	c4004820 	lsli      	r0, r0, 0
    b968:	131f      	lrw      	r0, 0xdfc0	// bb64 <GV_IPCM_CreateMessage+0x2a0>
    b96a:	e3ffff91 	bsr      	0xb88c	// b88c <pr>
    b96e:	c4004820 	lsli      	r0, r0, 0
    b972:	131c      	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    b974:	e3ffff8c 	bsr      	0xb88c	// b88c <pr>
    b978:	c4004820 	lsli      	r0, r0, 0
		return NULL;
    b97c:	3300      	movi      	r3, 0
    b97e:	04de      	br      	0xbb3a	// bb3a <GV_IPCM_CreateMessage+0x276>
	}
//no need to memset to zero
	ipcm_trace(TRACE_ZXF_DEBUG,"alloc mem pool size is:%d",size);
    b980:	3229      	movi      	r2, 41
    b982:	1334      	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    b984:	1314      	lrw      	r0, 0xdf84	// bb54 <GV_IPCM_CreateMessage+0x290>
    b986:	e3ffff83 	bsr      	0xb88c	// b88c <pr>
    b98a:	c4004820 	lsli      	r0, r0, 0
    b98e:	e468100f 	subi      	r3, r8, 16
    b992:	9320      	ld.w      	r1, (r3, 0)
    b994:	1315      	lrw      	r0, 0xdfe8	// bb68 <GV_IPCM_CreateMessage+0x2a4>
    b996:	e3ffff7b 	bsr      	0xb88c	// b88c <pr>
    b99a:	c4004820 	lsli      	r0, r0, 0
    b99e:	1311      	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    b9a0:	e3ffff76 	bsr      	0xb88c	// b88c <pr>
    b9a4:	c4004820 	lsli      	r0, r0, 0

	if( size > 0 )
    b9a8:	e468100f 	subi      	r3, r8, 16
    b9ac:	9360      	ld.w      	r3, (r3, 0)
    b9ae:	e903006e 	bez      	r3, 0xba8a	// ba8a <GV_IPCM_CreateMessage+0x1c6>
	{
		long rc = xrp_allocate(&msg_pool->pool, size , 0x10,&pMsg->msg_alloc);
    b9b2:	e468100b 	subi      	r3, r8, 12
    b9b6:	9360      	ld.w      	r3, (r3, 0)
    b9b8:	5b0e      	addi      	r0, r3, 4
    b9ba:	e4681003 	subi      	r3, r8, 4
    b9be:	9360      	ld.w      	r3, (r3, 0)
    b9c0:	e4881007 	subi      	r4, r8, 8
    b9c4:	e428100f 	subi      	r1, r8, 16
    b9c8:	3210      	movi      	r2, 16
    b9ca:	9120      	ld.w      	r1, (r1, 0)
    b9cc:	e0000aba 	bsr      	0xcf40	// cf40 <xrp_allocate>
    b9d0:	c4004820 	lsli      	r0, r0, 0
    b9d4:	b400      	st.w      	r0, (r4, 0)
		if(rc < 0)
    b9d6:	e4681007 	subi      	r3, r8, 8
    b9da:	9360      	ld.w      	r3, (r3, 0)
    b9dc:	e9a30026 	bhsz      	r3, 0xba28	// ba28 <GV_IPCM_CreateMessage+0x164>
		{
			ipcm_err("allocate memory from pool fail!");
    b9e0:	3230      	movi      	r2, 48
    b9e2:	123c      	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    b9e4:	1303      	lrw      	r0, 0xe004	// bb70 <GV_IPCM_CreateMessage+0x2ac>
    b9e6:	e3ffff53 	bsr      	0xb88c	// b88c <pr>
    b9ea:	c4004820 	lsli      	r0, r0, 0
    b9ee:	1302      	lrw      	r0, 0xe014	// bb74 <GV_IPCM_CreateMessage+0x2b0>
    b9f0:	e3ffff4e 	bsr      	0xb88c	// b88c <pr>
    b9f4:	c4004820 	lsli      	r0, r0, 0
    b9f8:	121a      	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    b9fa:	e3ffff49 	bsr      	0xb88c	// b88c <pr>
    b9fe:	c4004820 	lsli      	r0, r0, 0
			goto createMsg_fail;
    ba02:	6c00      	or      	r0, r0

	ipcm_trace(TRACE_ZXF_DEBUG,"create Message successful!");
	return pMsg;

createMsg_fail:
	free(pMsg->msg_body);
    ba04:	e4681003 	subi      	r3, r8, 4
    ba08:	9360      	ld.w      	r3, (r3, 0)
    ba0a:	9361      	ld.w      	r3, (r3, 0x4)
    ba0c:	6c0f      	mov      	r0, r3
    ba0e:	eae0005b 	jsri      	0x0	// from address pool at 0xbb78
    ba12:	c4004820 	lsli      	r0, r0, 0
	free(pMsg);
    ba16:	e4681003 	subi      	r3, r8, 4
    ba1a:	9300      	ld.w      	r0, (r3, 0)
    ba1c:	eae00057 	jsri      	0x0	// from address pool at 0xbb78
    ba20:	c4004820 	lsli      	r0, r0, 0
	return NULL;
    ba24:	3300      	movi      	r3, 0
    ba26:	048a      	br      	0xbb3a	// bb3a <GV_IPCM_CreateMessage+0x276>
		pMsg->msg_body->start = pMsg->msg_alloc->start;
    ba28:	e4681003 	subi      	r3, r8, 4
    ba2c:	9360      	ld.w      	r3, (r3, 0)
    ba2e:	9361      	ld.w      	r3, (r3, 0x4)
    ba30:	e4481003 	subi      	r2, r8, 4
    ba34:	9240      	ld.w      	r2, (r2, 0)
    ba36:	9240      	ld.w      	r2, (r2, 0)
    ba38:	9240      	ld.w      	r2, (r2, 0)
    ba3a:	b340      	st.w      	r2, (r3, 0)
		pMsg->msg_body->size = pMsg->msg_alloc->size;
    ba3c:	e4681003 	subi      	r3, r8, 4
    ba40:	9360      	ld.w      	r3, (r3, 0)
    ba42:	9361      	ld.w      	r3, (r3, 0x4)
    ba44:	e4481003 	subi      	r2, r8, 4
    ba48:	9240      	ld.w      	r2, (r2, 0)
    ba4a:	9240      	ld.w      	r2, (r2, 0)
    ba4c:	9241      	ld.w      	r2, (r2, 0x4)
    ba4e:	b341      	st.w      	r2, (r3, 0x4)
		ipcm_trace(TRACE_ZXF_DEBUG,"pMsg->msg_alloc->start:0x%x ,pMsg->msg_alloc->size:%d",pMsg->msg_alloc->start,pMsg->msg_alloc->size);
    ba50:	3236      	movi      	r2, 54
    ba52:	1220      	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    ba54:	1200      	lrw      	r0, 0xdf84	// bb54 <GV_IPCM_CreateMessage+0x290>
    ba56:	e3ffff1b 	bsr      	0xb88c	// b88c <pr>
    ba5a:	c4004820 	lsli      	r0, r0, 0
    ba5e:	e4681003 	subi      	r3, r8, 4
    ba62:	9360      	ld.w      	r3, (r3, 0)
    ba64:	9360      	ld.w      	r3, (r3, 0)
    ba66:	9320      	ld.w      	r1, (r3, 0)
    ba68:	e4681003 	subi      	r3, r8, 4
    ba6c:	9360      	ld.w      	r3, (r3, 0)
    ba6e:	9360      	ld.w      	r3, (r3, 0)
    ba70:	9361      	ld.w      	r3, (r3, 0x4)
    ba72:	6c8f      	mov      	r2, r3
    ba74:	1202      	lrw      	r0, 0xe034	// bb7c <GV_IPCM_CreateMessage+0x2b8>
    ba76:	e3ffff0b 	bsr      	0xb88c	// b88c <pr>
    ba7a:	c4004820 	lsli      	r0, r0, 0
    ba7e:	1119      	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    ba80:	e3ffff06 	bsr      	0xb88c	// b88c <pr>
    ba84:	c4004820 	lsli      	r0, r0, 0
    ba88:	0435      	br      	0xbaf2	// baf2 <GV_IPCM_CreateMessage+0x22e>
		pMsg->msg_alloc = (struct xrp_allocation*)calloc(1,sizeof(struct xrp_allocation));
    ba8a:	3114      	movi      	r1, 20
    ba8c:	3001      	movi      	r0, 1
    ba8e:	eae0003d 	jsri      	0x0	// from address pool at 0xbb80
    ba92:	c4004820 	lsli      	r0, r0, 0
    ba96:	6cc3      	mov      	r3, r0
    ba98:	6c8f      	mov      	r2, r3
    ba9a:	e4681003 	subi      	r3, r8, 4
    ba9e:	9360      	ld.w      	r3, (r3, 0)
    baa0:	b340      	st.w      	r2, (r3, 0)
		pMsg->msg_body->start = 0;
    baa2:	e4681003 	subi      	r3, r8, 4
    baa6:	9360      	ld.w      	r3, (r3, 0)
    baa8:	9361      	ld.w      	r3, (r3, 0x4)
    baaa:	3200      	movi      	r2, 0
    baac:	b340      	st.w      	r2, (r3, 0)
		pMsg->msg_body->size = 0;
    baae:	e4681003 	subi      	r3, r8, 4
    bab2:	9360      	ld.w      	r3, (r3, 0)
    bab4:	9361      	ld.w      	r3, (r3, 0x4)
    bab6:	3200      	movi      	r2, 0
    bab8:	b341      	st.w      	r2, (r3, 0x4)
		ipcm_trace(TRACE_ZXF_DEBUG,"pMsg->msg_alloc->start:0x%x,pMsg->msg_alloc->size:%d",pMsg->msg_alloc->start,pMsg->msg_alloc->size);
    baba:	323c      	movi      	r2, 60
    babc:	1125      	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    babe:	1106      	lrw      	r0, 0xdf84	// bb54 <GV_IPCM_CreateMessage+0x290>
    bac0:	e3fffee6 	bsr      	0xb88c	// b88c <pr>
    bac4:	c4004820 	lsli      	r0, r0, 0
    bac8:	e4681003 	subi      	r3, r8, 4
    bacc:	9360      	ld.w      	r3, (r3, 0)
    bace:	9360      	ld.w      	r3, (r3, 0)
    bad0:	9320      	ld.w      	r1, (r3, 0)
    bad2:	e4681003 	subi      	r3, r8, 4
    bad6:	9360      	ld.w      	r3, (r3, 0)
    bad8:	9360      	ld.w      	r3, (r3, 0)
    bada:	9361      	ld.w      	r3, (r3, 0x4)
    badc:	6c8f      	mov      	r2, r3
    bade:	110a      	lrw      	r0, 0xe06c	// bb84 <GV_IPCM_CreateMessage+0x2c0>
    bae0:	e3fffed6 	bsr      	0xb88c	// b88c <pr>
    bae4:	c4004820 	lsli      	r0, r0, 0
    bae8:	101e      	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    baea:	e3fffed1 	bsr      	0xb88c	// b88c <pr>
    baee:	c4004820 	lsli      	r0, r0, 0
	pMsg->msg_body->u32CMD = u32CMD;
    baf2:	e4681003 	subi      	r3, r8, 4
    baf6:	9360      	ld.w      	r3, (r3, 0)
    baf8:	9361      	ld.w      	r3, (r3, 0x4)
    bafa:	e4481013 	subi      	r2, r8, 20
    bafe:	9240      	ld.w      	r2, (r2, 0)
    bb00:	b342      	st.w      	r2, (r3, 0x8)
	pMsg->msg_body->bIsResp = bIsResp;
    bb02:	e4681003 	subi      	r3, r8, 4
    bb06:	9360      	ld.w      	r3, (r3, 0)
    bb08:	9361      	ld.w      	r3, (r3, 0x4)
    bb0a:	e4481017 	subi      	r2, r8, 24
    bb0e:	9240      	ld.w      	r2, (r2, 0)
    bb10:	b343      	st.w      	r2, (r3, 0xc)
	ipcm_trace(TRACE_ZXF_DEBUG,"create Message successful!");
    bb12:	3243      	movi      	r2, 67
    bb14:	102f      	lrw      	r1, 0xe3fc	// bb50 <GV_IPCM_CreateMessage+0x28c>
    bb16:	1010      	lrw      	r0, 0xdf84	// bb54 <GV_IPCM_CreateMessage+0x290>
    bb18:	e3fffeba 	bsr      	0xb88c	// b88c <pr>
    bb1c:	c4004820 	lsli      	r0, r0, 0
    bb20:	101a      	lrw      	r0, 0xe0a4	// bb88 <GV_IPCM_CreateMessage+0x2c4>
    bb22:	e3fffeb5 	bsr      	0xb88c	// b88c <pr>
    bb26:	c4004820 	lsli      	r0, r0, 0
    bb2a:	100e      	lrw      	r0, 0xdfbc	// bb60 <GV_IPCM_CreateMessage+0x29c>
    bb2c:	e3fffeb0 	bsr      	0xb88c	// b88c <pr>
    bb30:	c4004820 	lsli      	r0, r0, 0
	return pMsg;
    bb34:	e4681003 	subi      	r3, r8, 4
    bb38:	9360      	ld.w      	r3, (r3, 0)
}
    bb3a:	6c0f      	mov      	r0, r3
    bb3c:	6fa3      	mov      	sp, r8
    bb3e:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    bb42:	d90e2001 	ld.w      	r8, (sp, 0x4)
    bb46:	9880      	ld.w      	r4, (sp, 0)
    bb48:	1403      	addi      	sp, sp, 12
    bb4a:	783c      	rts
    bb4c:	00000000 	.long	0x00000000
    bb50:	0000e3fc 	.long	0x0000e3fc
    bb54:	0000df84 	.long	0x0000df84
    bb58:	0000b88c 	.long	0x0000b88c
    bb5c:	0000df94 	.long	0x0000df94
    bb60:	0000dfbc 	.long	0x0000dfbc
    bb64:	0000dfc0 	.long	0x0000dfc0
    bb68:	0000dfe8 	.long	0x0000dfe8
    bb6c:	0000cf40 	.long	0x0000cf40
    bb70:	0000e004 	.long	0x0000e004
    bb74:	0000e014 	.long	0x0000e014
    bb78:	00000000 	.long	0x00000000
    bb7c:	0000e034 	.long	0x0000e034
    bb80:	00000000 	.long	0x00000000
    bb84:	0000e06c 	.long	0x0000e06c
    bb88:	0000e0a4 	.long	0x0000e0a4

0000bb8c <GV_IPCM_DestroyMessage>:

GV_IPCM_RetValue_E GV_IPCM_DestroyMessage(GV_IPCM_MSG_S *pstMsg)
{
    bb8c:	1422      	subi      	sp, sp, 8
    bb8e:	dd0e2000 	st.w      	r8, (sp, 0)
    bb92:	ddee2001 	st.w      	r15, (sp, 0x4)
    bb96:	6e3b      	mov      	r8, sp
    bb98:	1421      	subi      	sp, sp, 4
    bb9a:	e4681003 	subi      	r3, r8, 4
    bb9e:	b300      	st.w      	r0, (r3, 0)
	if(NULL == pstMsg)
    bba0:	e4681003 	subi      	r3, r8, 4
    bba4:	9360      	ld.w      	r3, (r3, 0)
    bba6:	e9230015 	bnez      	r3, 0xbbd0	// bbd0 <GV_IPCM_DestroyMessage+0x44>
	{
		ipcm_err("Destroy message is NULL");
    bbaa:	3250      	movi      	r2, 80
    bbac:	1227      	lrw      	r1, 0xe414	// bcc8 <GV_IPCM_DestroyMessage+0x13c>
    bbae:	1208      	lrw      	r0, 0xe004	// bccc <GV_IPCM_DestroyMessage+0x140>
    bbb0:	e3fffe6e 	bsr      	0xb88c	// b88c <pr>
    bbb4:	c4004820 	lsli      	r0, r0, 0
    bbb8:	1207      	lrw      	r0, 0xe0c0	// bcd4 <GV_IPCM_DestroyMessage+0x148>
    bbba:	e3fffe69 	bsr      	0xb88c	// b88c <pr>
    bbbe:	c4004820 	lsli      	r0, r0, 0
    bbc2:	1206      	lrw      	r0, 0xdfbc	// bcd8 <GV_IPCM_DestroyMessage+0x14c>
    bbc4:	e3fffe64 	bsr      	0xb88c	// b88c <pr>
    bbc8:	c4004820 	lsli      	r0, r0, 0
		return GV_SUCCESS;
    bbcc:	3300      	movi      	r3, 0
    bbce:	0474      	br      	0xbcb6	// bcb6 <GV_IPCM_DestroyMessage+0x12a>
	}

	if(pstMsg->msg_alloc != NULL)
    bbd0:	e4681003 	subi      	r3, r8, 4
    bbd4:	9360      	ld.w      	r3, (r3, 0)
    bbd6:	9360      	ld.w      	r3, (r3, 0)
    bbd8:	e9030032 	bez      	r3, 0xbc3c	// bc3c <GV_IPCM_DestroyMessage+0xb0>
	{		
		//if no
		if(pstMsg->msg_alloc->size > 0)
    bbdc:	e4681003 	subi      	r3, r8, 4
    bbe0:	9360      	ld.w      	r3, (r3, 0)
    bbe2:	9360      	ld.w      	r3, (r3, 0)
    bbe4:	9361      	ld.w      	r3, (r3, 0x4)
    bbe6:	e9030022 	bez      	r3, 0xbc2a	// bc2a <GV_IPCM_DestroyMessage+0x9e>
		{
			ipcm_trace(TRACE_ZXF_DEBUG,"pstMsg->msg_body->size: %d",pstMsg->msg_alloc->size);
    bbea:	3259      	movi      	r2, 89
    bbec:	1137      	lrw      	r1, 0xe414	// bcc8 <GV_IPCM_DestroyMessage+0x13c>
    bbee:	111c      	lrw      	r0, 0xdf84	// bcdc <GV_IPCM_DestroyMessage+0x150>
    bbf0:	e3fffe4e 	bsr      	0xb88c	// b88c <pr>
    bbf4:	c4004820 	lsli      	r0, r0, 0
    bbf8:	e4681003 	subi      	r3, r8, 4
    bbfc:	9360      	ld.w      	r3, (r3, 0)
    bbfe:	9360      	ld.w      	r3, (r3, 0)
    bc00:	9361      	ld.w      	r3, (r3, 0x4)
    bc02:	6c4f      	mov      	r1, r3
    bc04:	1117      	lrw      	r0, 0xe0d8	// bce0 <GV_IPCM_DestroyMessage+0x154>
    bc06:	e3fffe43 	bsr      	0xb88c	// b88c <pr>
    bc0a:	c4004820 	lsli      	r0, r0, 0
    bc0e:	1113      	lrw      	r0, 0xdfbc	// bcd8 <GV_IPCM_DestroyMessage+0x14c>
    bc10:	e3fffe3e 	bsr      	0xb88c	// b88c <pr>
    bc14:	c4004820 	lsli      	r0, r0, 0
			xrp_free(pstMsg->msg_alloc);
    bc18:	e4681003 	subi      	r3, r8, 4
    bc1c:	9360      	ld.w      	r3, (r3, 0)
    bc1e:	9360      	ld.w      	r3, (r3, 0)
    bc20:	6c0f      	mov      	r0, r3
    bc22:	e0000825 	bsr      	0xcc6c	// cc6c <xrp_free>
    bc26:	c4004820 	lsli      	r0, r0, 0
		}
		free(pstMsg->msg_alloc);
    bc2a:	e4681003 	subi      	r3, r8, 4
    bc2e:	9360      	ld.w      	r3, (r3, 0)
    bc30:	9360      	ld.w      	r3, (r3, 0)
    bc32:	6c0f      	mov      	r0, r3
    bc34:	eae0002d 	jsri      	0x0	// from address pool at 0xbce8
    bc38:	c4004820 	lsli      	r0, r0, 0
	}
	ipcm_trace(TRACE_ZXF_DEBUG,"pstMsg->msg_body.size: %d",pstMsg->msg_body->size);
    bc3c:	325e      	movi      	r2, 94
    bc3e:	1123      	lrw      	r1, 0xe414	// bcc8 <GV_IPCM_DestroyMessage+0x13c>
    bc40:	1107      	lrw      	r0, 0xdf84	// bcdc <GV_IPCM_DestroyMessage+0x150>
    bc42:	e3fffe25 	bsr      	0xb88c	// b88c <pr>
    bc46:	c4004820 	lsli      	r0, r0, 0
    bc4a:	e4681003 	subi      	r3, r8, 4
    bc4e:	9360      	ld.w      	r3, (r3, 0)
    bc50:	9361      	ld.w      	r3, (r3, 0x4)
    bc52:	9361      	ld.w      	r3, (r3, 0x4)
    bc54:	6c4f      	mov      	r1, r3
    bc56:	1106      	lrw      	r0, 0xe0f4	// bcec <GV_IPCM_DestroyMessage+0x160>
    bc58:	e3fffe1a 	bsr      	0xb88c	// b88c <pr>
    bc5c:	c4004820 	lsli      	r0, r0, 0
    bc60:	101e      	lrw      	r0, 0xdfbc	// bcd8 <GV_IPCM_DestroyMessage+0x14c>
    bc62:	e3fffe15 	bsr      	0xb88c	// b88c <pr>
    bc66:	c4004820 	lsli      	r0, r0, 0

	free(pstMsg->msg_body);
    bc6a:	e4681003 	subi      	r3, r8, 4
    bc6e:	9360      	ld.w      	r3, (r3, 0)
    bc70:	9361      	ld.w      	r3, (r3, 0x4)
    bc72:	6c0f      	mov      	r0, r3
    bc74:	eae0001d 	jsri      	0x0	// from address pool at 0xbce8
    bc78:	c4004820 	lsli      	r0, r0, 0
	free(pstMsg);
    bc7c:	e4681003 	subi      	r3, r8, 4
    bc80:	9300      	ld.w      	r0, (r3, 0)
    bc82:	eae0001a 	jsri      	0x0	// from address pool at 0xbce8
    bc86:	c4004820 	lsli      	r0, r0, 0

	pstMsg = NULL;
    bc8a:	e4681003 	subi      	r3, r8, 4
    bc8e:	3200      	movi      	r2, 0
    bc90:	b340      	st.w      	r2, (r3, 0)
	ipcm_trace(TRACE_ZXF_DEBUG,"Destroy message successful!");
    bc92:	3264      	movi      	r2, 100
    bc94:	102d      	lrw      	r1, 0xe414	// bcc8 <GV_IPCM_DestroyMessage+0x13c>
    bc96:	1012      	lrw      	r0, 0xdf84	// bcdc <GV_IPCM_DestroyMessage+0x150>
    bc98:	e3fffdfa 	bsr      	0xb88c	// b88c <pr>
    bc9c:	c4004820 	lsli      	r0, r0, 0
    bca0:	1014      	lrw      	r0, 0xe110	// bcf0 <GV_IPCM_DestroyMessage+0x164>
    bca2:	e3fffdf5 	bsr      	0xb88c	// b88c <pr>
    bca6:	c4004820 	lsli      	r0, r0, 0
    bcaa:	100c      	lrw      	r0, 0xdfbc	// bcd8 <GV_IPCM_DestroyMessage+0x14c>
    bcac:	e3fffdf0 	bsr      	0xb88c	// b88c <pr>
    bcb0:	c4004820 	lsli      	r0, r0, 0

	return GV_SUCCESS;
    bcb4:	3300      	movi      	r3, 0
}
    bcb6:	6c0f      	mov      	r0, r3
    bcb8:	6fa3      	mov      	sp, r8
    bcba:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    bcbe:	d90e2000 	ld.w      	r8, (sp, 0)
    bcc2:	1402      	addi      	sp, sp, 8
    bcc4:	783c      	rts
    bcc6:	0000      	.short	0x0000
    bcc8:	0000e414 	.long	0x0000e414
    bccc:	0000e004 	.long	0x0000e004
    bcd0:	0000b88c 	.long	0x0000b88c
    bcd4:	0000e0c0 	.long	0x0000e0c0
    bcd8:	0000dfbc 	.long	0x0000dfbc
    bcdc:	0000df84 	.long	0x0000df84
    bce0:	0000e0d8 	.long	0x0000e0d8
    bce4:	0000cc6c 	.long	0x0000cc6c
    bce8:	00000000 	.long	0x00000000
    bcec:	0000e0f4 	.long	0x0000e0f4
    bcf0:	0000e110 	.long	0x0000e110

0000bcf4 <GV_IPCM_Connect>:


GV_IPCM_RetValue_E  GV_IPCM_Connect(GV_IPCM_HANDLE_ATTR_S* stHandleAttr,GV_IPCM_MSG_POOL_S* ipcm_pool)
{
    bcf4:	1423      	subi      	sp, sp, 12
    bcf6:	b880      	st.w      	r4, (sp, 0)
    bcf8:	dd0e2001 	st.w      	r8, (sp, 0x4)
    bcfc:	ddee2002 	st.w      	r15, (sp, 0x8)
    bd00:	6e3b      	mov      	r8, sp
    bd02:	1424      	subi      	sp, sp, 16
    bd04:	e4681007 	subi      	r3, r8, 8
    bd08:	b300      	st.w      	r0, (r3, 0)
    bd0a:	e468100b 	subi      	r3, r8, 12
    bd0e:	b320      	st.w      	r1, (r3, 0)
	int ret = 0;
    bd10:	e4681003 	subi      	r3, r8, 4
    bd14:	3200      	movi      	r2, 0
    bd16:	b340      	st.w      	r2, (r3, 0)
	//ipcm_pool = (GV_IPCM_MSG_POOL_S*)malloc(sizeof(GV_IPCM_MSG_POOL_S));
	if (!ipcm_pool)
    bd18:	e468100b 	subi      	r3, r8, 12
    bd1c:	9360      	ld.w      	r3, (r3, 0)
    bd1e:	e9230016 	bnez      	r3, 0xbd4a	// bd4a <GV_IPCM_Connect+0x56>
	{
		ipcm_trace(TRACE_ZXF_DEBUG,"malloc memory for ipcm message pool fail!");
    bd22:	3270      	movi      	r2, 112
    bd24:	1321      	lrw      	r1, 0xe42c	// bea8 <GV_IPCM_Connect+0x1b4>
    bd26:	1302      	lrw      	r0, 0xdf84	// beac <GV_IPCM_Connect+0x1b8>
    bd28:	e3fffdb2 	bsr      	0xb88c	// b88c <pr>
    bd2c:	c4004820 	lsli      	r0, r0, 0
    bd30:	1301      	lrw      	r0, 0xe12c	// beb4 <GV_IPCM_Connect+0x1c0>
    bd32:	e3fffdad 	bsr      	0xb88c	// b88c <pr>
    bd36:	c4004820 	lsli      	r0, r0, 0
    bd3a:	1300      	lrw      	r0, 0xdfbc	// beb8 <GV_IPCM_Connect+0x1c4>
    bd3c:	e3fffda8 	bsr      	0xb88c	// b88c <pr>
    bd40:	c4004820 	lsli      	r0, r0, 0
		return -GV_ERR_MALLOC;
    bd44:	3300      	movi      	r3, 0
    bd46:	2b02      	subi      	r3, 3
    bd48:	04a6      	br      	0xbe94	// be94 <GV_IPCM_Connect+0x1a0>
	}

	ipcm_pool->IpcmFd = open(DEV_NAME, O_RDWR);
    bd4a:	3102      	movi      	r1, 2
    bd4c:	121c      	lrw      	r0, 0xe158	// bebc <GV_IPCM_Connect+0x1c8>
    bd4e:	eae0005d 	jsri      	0x0	// from address pool at 0xbec0
    bd52:	c4004820 	lsli      	r0, r0, 0
    bd56:	6c83      	mov      	r2, r0
    bd58:	e468100b 	subi      	r3, r8, 12
    bd5c:	9360      	ld.w      	r3, (r3, 0)
    bd5e:	b340      	st.w      	r2, (r3, 0)
	if (ipcm_pool->IpcmFd < 0) {
    bd60:	e468100b 	subi      	r3, r8, 12
    bd64:	9360      	ld.w      	r3, (r3, 0)
    bd66:	9360      	ld.w      	r3, (r3, 0)
    bd68:	e9a3001c 	bhsz      	r3, 0xbda0	// bda0 <GV_IPCM_Connect+0xac>
		ipcm_err("open %s fail.return:%d!",DEV_NAME,ipcm_pool->IpcmFd);
    bd6c:	3276      	movi      	r2, 118
    bd6e:	122f      	lrw      	r1, 0xe42c	// bea8 <GV_IPCM_Connect+0x1b4>
    bd70:	1215      	lrw      	r0, 0xe004	// bec4 <GV_IPCM_Connect+0x1d0>
    bd72:	e3fffd8d 	bsr      	0xb88c	// b88c <pr>
    bd76:	c4004820 	lsli      	r0, r0, 0
    bd7a:	e468100b 	subi      	r3, r8, 12
    bd7e:	9360      	ld.w      	r3, (r3, 0)
    bd80:	9360      	ld.w      	r3, (r3, 0)
    bd82:	6c8f      	mov      	r2, r3
    bd84:	122e      	lrw      	r1, 0xe158	// bebc <GV_IPCM_Connect+0x1c8>
    bd86:	1211      	lrw      	r0, 0xe168	// bec8 <GV_IPCM_Connect+0x1d4>
    bd88:	e3fffd82 	bsr      	0xb88c	// b88c <pr>
    bd8c:	c4004820 	lsli      	r0, r0, 0
    bd90:	120a      	lrw      	r0, 0xdfbc	// beb8 <GV_IPCM_Connect+0x1c4>
    bd92:	e3fffd7d 	bsr      	0xb88c	// b88c <pr>
    bd96:	c4004820 	lsli      	r0, r0, 0
		return -GV_FAILED;
    bd9a:	3300      	movi      	r3, 0
    bd9c:	2b00      	subi      	r3, 1
    bd9e:	047b      	br      	0xbe94	// be94 <GV_IPCM_Connect+0x1a0>
	}

	ipcm_trace(TRACE_ZXF_DEBUG,"%s connecting to target [%d:%d],ipcm_fd:%d ",DEV_NAME,stHandleAttr->target,stHandleAttr->port,ipcm_pool->IpcmFd);
    bda0:	327a      	movi      	r2, 122
    bda2:	1222      	lrw      	r1, 0xe42c	// bea8 <GV_IPCM_Connect+0x1b4>
    bda4:	1202      	lrw      	r0, 0xdf84	// beac <GV_IPCM_Connect+0x1b8>
    bda6:	e3fffd73 	bsr      	0xb88c	// b88c <pr>
    bdaa:	c4004820 	lsli      	r0, r0, 0
    bdae:	e4681007 	subi      	r3, r8, 8
    bdb2:	9360      	ld.w      	r3, (r3, 0)
    bdb4:	9340      	ld.w      	r2, (r3, 0)
    bdb6:	e4681007 	subi      	r3, r8, 8
    bdba:	9360      	ld.w      	r3, (r3, 0)
    bdbc:	9321      	ld.w      	r1, (r3, 0x4)
    bdbe:	e468100b 	subi      	r3, r8, 12
    bdc2:	9360      	ld.w      	r3, (r3, 0)
    bdc4:	9360      	ld.w      	r3, (r3, 0)
    bdc6:	b860      	st.w      	r3, (sp, 0)
    bdc8:	6cc7      	mov      	r3, r1
    bdca:	113d      	lrw      	r1, 0xe158	// bebc <GV_IPCM_Connect+0x1c8>
    bdcc:	1200      	lrw      	r0, 0xe180	// becc <GV_IPCM_Connect+0x1d8>
    bdce:	e3fffd5f 	bsr      	0xb88c	// b88c <pr>
    bdd2:	c4004820 	lsli      	r0, r0, 0
    bdd6:	1119      	lrw      	r0, 0xdfbc	// beb8 <GV_IPCM_Connect+0x1c4>
    bdd8:	e3fffd5a 	bsr      	0xb88c	// b88c <pr>
    bddc:	c4004820 	lsli      	r0, r0, 0
	/*
	 * IOC_CONNECT wait and suspend until node connect success!
	 * ret = 0 :connect success ;ret !=0 connect fail
	 */
	ret = ioctl(ipcm_pool->IpcmFd, GV_IPCM_IOC_CONNECT, stHandleAttr);
    bde0:	e468100b 	subi      	r3, r8, 12
    bde4:	9360      	ld.w      	r3, (r3, 0)
    bde6:	9300      	ld.w      	r0, (r3, 0)
    bde8:	e4881003 	subi      	r4, r8, 4
    bdec:	e4681007 	subi      	r3, r8, 8
    bdf0:	9340      	ld.w      	r2, (r3, 0)
    bdf2:	1138      	lrw      	r1, 0x400c4d01	// bed0 <GV_IPCM_Connect+0x1dc>
    bdf4:	eae00038 	jsri      	0x0	// from address pool at 0xbed4
    bdf8:	c4004820 	lsli      	r0, r0, 0
    bdfc:	b400      	st.w      	r0, (r4, 0)
	if(ret)
    bdfe:	e4681003 	subi      	r3, r8, 4
    be02:	9360      	ld.w      	r3, (r3, 0)
    be04:	e9030020 	bez      	r3, 0xbe44	// be44 <GV_IPCM_Connect+0x150>
	{
		ipcm_trace(TRACE_ZXF_DEBUG,"connect fail!");
    be08:	3282      	movi      	r2, 130
    be0a:	1128      	lrw      	r1, 0xe42c	// bea8 <GV_IPCM_Connect+0x1b4>
    be0c:	1108      	lrw      	r0, 0xdf84	// beac <GV_IPCM_Connect+0x1b8>
    be0e:	e3fffd3f 	bsr      	0xb88c	// b88c <pr>
    be12:	c4004820 	lsli      	r0, r0, 0
    be16:	1111      	lrw      	r0, 0xe1ac	// bed8 <GV_IPCM_Connect+0x1e4>
    be18:	e3fffd3a 	bsr      	0xb88c	// b88c <pr>
    be1c:	c4004820 	lsli      	r0, r0, 0
    be20:	1106      	lrw      	r0, 0xdfbc	// beb8 <GV_IPCM_Connect+0x1c4>
    be22:	e3fffd35 	bsr      	0xb88c	// b88c <pr>
    be26:	c4004820 	lsli      	r0, r0, 0
		goto connect_fail;
    be2a:	6c00      	or      	r0, r0

	ipcm_trace(TRACE_ZXF_DEBUG,"connected target [%d,%d] ok~",stHandleAttr->target,stHandleAttr->port);
	return GV_SUCCESS;
	
connect_fail:
		close(ipcm_pool->IpcmFd);
    be2c:	e468100b 	subi      	r3, r8, 12
    be30:	9360      	ld.w      	r3, (r3, 0)
    be32:	9360      	ld.w      	r3, (r3, 0)
    be34:	6c0f      	mov      	r0, r3
    be36:	eae0002a 	jsri      	0x0	// from address pool at 0xbedc
    be3a:	c4004820 	lsli      	r0, r0, 0
		return -GV_FAILED;
    be3e:	3300      	movi      	r3, 0
    be40:	2b00      	subi      	r3, 1
    be42:	0429      	br      	0xbe94	// be94 <GV_IPCM_Connect+0x1a0>
	xrp_init_pool(&ipcm_pool->pool,IPCM_POOL_START,IPCM_POOL_SIZE);
    be44:	e468100b 	subi      	r3, r8, 12
    be48:	9360      	ld.w      	r3, (r3, 0)
    be4a:	2303      	addi      	r3, 4
    be4c:	ea221000 	movih      	r2, 4096
    be50:	ea214000 	movih      	r1, 16384
    be54:	6c0f      	mov      	r0, r3
    be56:	e00006a9 	bsr      	0xcba8	// cba8 <xrp_init_pool>
    be5a:	c4004820 	lsli      	r0, r0, 0
	ipcm_trace(TRACE_ZXF_DEBUG,"connected target [%d,%d] ok~",stHandleAttr->target,stHandleAttr->port);
    be5e:	328a      	movi      	r2, 138
    be60:	1032      	lrw      	r1, 0xe42c	// bea8 <GV_IPCM_Connect+0x1b4>
    be62:	1013      	lrw      	r0, 0xdf84	// beac <GV_IPCM_Connect+0x1b8>
    be64:	e3fffd14 	bsr      	0xb88c	// b88c <pr>
    be68:	c4004820 	lsli      	r0, r0, 0
    be6c:	e4681007 	subi      	r3, r8, 8
    be70:	9360      	ld.w      	r3, (r3, 0)
    be72:	9320      	ld.w      	r1, (r3, 0)
    be74:	e4681007 	subi      	r3, r8, 8
    be78:	9360      	ld.w      	r3, (r3, 0)
    be7a:	9361      	ld.w      	r3, (r3, 0x4)
    be7c:	6c8f      	mov      	r2, r3
    be7e:	101a      	lrw      	r0, 0xe1bc	// bee4 <GV_IPCM_Connect+0x1f0>
    be80:	e3fffd06 	bsr      	0xb88c	// b88c <pr>
    be84:	c4004820 	lsli      	r0, r0, 0
    be88:	100c      	lrw      	r0, 0xdfbc	// beb8 <GV_IPCM_Connect+0x1c4>
    be8a:	e3fffd01 	bsr      	0xb88c	// b88c <pr>
    be8e:	c4004820 	lsli      	r0, r0, 0
	return GV_SUCCESS;
    be92:	3300      	movi      	r3, 0
}
    be94:	6c0f      	mov      	r0, r3
    be96:	6fa3      	mov      	sp, r8
    be98:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    be9c:	d90e2001 	ld.w      	r8, (sp, 0x4)
    bea0:	9880      	ld.w      	r4, (sp, 0)
    bea2:	1403      	addi      	sp, sp, 12
    bea4:	783c      	rts
    bea6:	0000      	.short	0x0000
    bea8:	0000e42c 	.long	0x0000e42c
    beac:	0000df84 	.long	0x0000df84
    beb0:	0000b88c 	.long	0x0000b88c
    beb4:	0000e12c 	.long	0x0000e12c
    beb8:	0000dfbc 	.long	0x0000dfbc
    bebc:	0000e158 	.long	0x0000e158
    bec0:	00000000 	.long	0x00000000
    bec4:	0000e004 	.long	0x0000e004
    bec8:	0000e168 	.long	0x0000e168
    becc:	0000e180 	.long	0x0000e180
    bed0:	400c4d01 	.long	0x400c4d01
    bed4:	00000000 	.long	0x00000000
    bed8:	0000e1ac 	.long	0x0000e1ac
    bedc:	00000000 	.long	0x00000000
    bee0:	0000cba8 	.long	0x0000cba8
    bee4:	0000e1bc 	.long	0x0000e1bc

0000bee8 <GV_IPCM_TryConnect>:


GV_IPCM_RetValue_E GV_IPCM_TryConnect(GV_IPCM_HANDLE_ATTR_S* stHandleAttr,GV_IPCM_MSG_POOL_S* ipcm_pool)
{
    bee8:	1423      	subi      	sp, sp, 12
    beea:	b880      	st.w      	r4, (sp, 0)
    beec:	dd0e2001 	st.w      	r8, (sp, 0x4)
    bef0:	ddee2002 	st.w      	r15, (sp, 0x8)
    bef4:	6e3b      	mov      	r8, sp
    bef6:	1424      	subi      	sp, sp, 16
    bef8:	e4681007 	subi      	r3, r8, 8
    befc:	b300      	st.w      	r0, (r3, 0)
    befe:	e468100b 	subi      	r3, r8, 12
    bf02:	b320      	st.w      	r1, (r3, 0)

//	ipcm_trace(TRACE_ZXF_DEBUG,"%s trying to connect target [%d:%d],ipcm_fd:%d ",DEV_NAME,stHandleAttr->target,stHandleAttr->port,ipcm_pool->IpcmFd);
    bf04:	3296      	movi      	r2, 150
    bf06:	1324      	lrw      	r1, 0xe43c	// c094 <GV_IPCM_TryConnect+0x1ac>
    bf08:	1304      	lrw      	r0, 0xdf84	// c098 <GV_IPCM_TryConnect+0x1b0>
    bf0a:	e3fffcc1 	bsr      	0xb88c	// b88c <pr>
    bf0e:	c4004820 	lsli      	r0, r0, 0
    bf12:	e4681007 	subi      	r3, r8, 8
    bf16:	9360      	ld.w      	r3, (r3, 0)
    bf18:	9340      	ld.w      	r2, (r3, 0)
    bf1a:	e4681007 	subi      	r3, r8, 8
    bf1e:	9360      	ld.w      	r3, (r3, 0)
    bf20:	9321      	ld.w      	r1, (r3, 0x4)
    bf22:	e468100b 	subi      	r3, r8, 12
    bf26:	9360      	ld.w      	r3, (r3, 0)
    bf28:	9360      	ld.w      	r3, (r3, 0)
    bf2a:	b860      	st.w      	r3, (sp, 0)
    bf2c:	6cc7      	mov      	r3, r1
    bf2e:	123d      	lrw      	r1, 0xe158	// c0a0 <GV_IPCM_TryConnect+0x1b8>
    bf30:	121d      	lrw      	r0, 0xe1dc	// c0a4 <GV_IPCM_TryConnect+0x1bc>
    bf32:	e3fffcad 	bsr      	0xb88c	// b88c <pr>
    bf36:	c4004820 	lsli      	r0, r0, 0
    bf3a:	121c      	lrw      	r0, 0xdfbc	// c0a8 <GV_IPCM_TryConnect+0x1c0>
    bf3c:	e3fffca8 	bsr      	0xb88c	// b88c <pr>
    bf40:	c4004820 	lsli      	r0, r0, 0
	printf("ENTRY connect target [%d,%d],file:%d\n",stHandleAttr->target,stHandleAttr->port,ipcm_pool->IpcmFd);	

    bf44:	e4681003 	subi      	r3, r8, 4
    bf48:	3200      	movi      	r2, 0
    bf4a:	b340      	st.w      	r2, (r3, 0)
	int ret = 0;
//	GV_IPCM_MSG_POOL_S* ipcm_pool = (GV_IPCM_MSG_POOL_S*)malloc(sizeof(*ipcm_pool)); /* ipcm_pool will malloc at outside */
    bf4c:	e468100b 	subi      	r3, r8, 12
    bf50:	9360      	ld.w      	r3, (r3, 0)
    bf52:	e9230016 	bnez      	r3, 0xbf7e	// bf7e <GV_IPCM_TryConnect+0x96>
	if (!ipcm_pool)
	{
    bf56:	329c      	movi      	r2, 156
    bf58:	122f      	lrw      	r1, 0xe43c	// c094 <GV_IPCM_TryConnect+0x1ac>
    bf5a:	1210      	lrw      	r0, 0xdf84	// c098 <GV_IPCM_TryConnect+0x1b0>
    bf5c:	e3fffc98 	bsr      	0xb88c	// b88c <pr>
    bf60:	c4004820 	lsli      	r0, r0, 0
    bf64:	1212      	lrw      	r0, 0xe12c	// c0ac <GV_IPCM_TryConnect+0x1c4>
    bf66:	e3fffc93 	bsr      	0xb88c	// b88c <pr>
    bf6a:	c4004820 	lsli      	r0, r0, 0
    bf6e:	120f      	lrw      	r0, 0xdfbc	// c0a8 <GV_IPCM_TryConnect+0x1c0>
    bf70:	e3fffc8e 	bsr      	0xb88c	// b88c <pr>
    bf74:	c4004820 	lsli      	r0, r0, 0
		ipcm_trace(TRACE_ZXF_DEBUG,"malloc memory for ipcm message pool fail!");
    bf78:	3300      	movi      	r3, 0
    bf7a:	2b02      	subi      	r3, 3
    bf7c:	0482      	br      	0xc080	// c080 <GV_IPCM_TryConnect+0x198>
		return -GV_ERR_MALLOC;
	}

	/*
	* Initilization ipcm memory pool
	*/
    bf7e:	e468100b 	subi      	r3, r8, 12
    bf82:	9360      	ld.w      	r3, (r3, 0)
    bf84:	2303      	addi      	r3, 4
    bf86:	ea221000 	movih      	r2, 4096
    bf8a:	ea214000 	movih      	r1, 16384
    bf8e:	6c0f      	mov      	r0, r3
    bf90:	e000060c 	bsr      	0xcba8	// cba8 <xrp_init_pool>
    bf94:	c4004820 	lsli      	r0, r0, 0
	xrp_init_pool(&ipcm_pool->pool,IPCM_POOL_START,IPCM_POOL_SIZE);

	/*
	* try to connect
	*/
    bf98:	3102      	movi      	r1, 2
    bf9a:	1202      	lrw      	r0, 0xe158	// c0a0 <GV_IPCM_TryConnect+0x1b8>
    bf9c:	eae00046 	jsri      	0x0	// from address pool at 0xc0b4
    bfa0:	c4004820 	lsli      	r0, r0, 0
    bfa4:	6c83      	mov      	r2, r0
    bfa6:	e468100b 	subi      	r3, r8, 12
    bfaa:	9360      	ld.w      	r3, (r3, 0)
    bfac:	b340      	st.w      	r2, (r3, 0)
	ipcm_pool->IpcmFd = open(DEV_NAME, O_RDWR);
    bfae:	e468100b 	subi      	r3, r8, 12
    bfb2:	9360      	ld.w      	r3, (r3, 0)
    bfb4:	9360      	ld.w      	r3, (r3, 0)
    bfb6:	e9a3001c 	bhsz      	r3, 0xbfee	// bfee <GV_IPCM_TryConnect+0x106>
	if (ipcm_pool->IpcmFd < 0) {
    bfba:	32aa      	movi      	r2, 170
    bfbc:	1136      	lrw      	r1, 0xe43c	// c094 <GV_IPCM_TryConnect+0x1ac>
    bfbe:	111f      	lrw      	r0, 0xe004	// c0b8 <GV_IPCM_TryConnect+0x1d0>
    bfc0:	e3fffc66 	bsr      	0xb88c	// b88c <pr>
    bfc4:	c4004820 	lsli      	r0, r0, 0
    bfc8:	e468100b 	subi      	r3, r8, 12
    bfcc:	9360      	ld.w      	r3, (r3, 0)
    bfce:	9360      	ld.w      	r3, (r3, 0)
    bfd0:	6c8f      	mov      	r2, r3
    bfd2:	1134      	lrw      	r1, 0xe158	// c0a0 <GV_IPCM_TryConnect+0x1b8>
    bfd4:	111a      	lrw      	r0, 0xe168	// c0bc <GV_IPCM_TryConnect+0x1d4>
    bfd6:	e3fffc5b 	bsr      	0xb88c	// b88c <pr>
    bfda:	c4004820 	lsli      	r0, r0, 0
    bfde:	1113      	lrw      	r0, 0xdfbc	// c0a8 <GV_IPCM_TryConnect+0x1c0>
    bfe0:	e3fffc56 	bsr      	0xb88c	// b88c <pr>
    bfe4:	c4004820 	lsli      	r0, r0, 0
		ipcm_err("open %s fail.return:%d!",DEV_NAME,ipcm_pool->IpcmFd);
    bfe8:	3300      	movi      	r3, 0
    bfea:	2b06      	subi      	r3, 7
    bfec:	044a      	br      	0xc080	// c080 <GV_IPCM_TryConnect+0x198>
		return -GV_ERR_FILE;
	}
	
    bfee:	32ae      	movi      	r2, 174
    bff0:	1129      	lrw      	r1, 0xe43c	// c094 <GV_IPCM_TryConnect+0x1ac>
    bff2:	110a      	lrw      	r0, 0xdf84	// c098 <GV_IPCM_TryConnect+0x1b0>
    bff4:	e3fffc4c 	bsr      	0xb88c	// b88c <pr>
    bff8:	c4004820 	lsli      	r0, r0, 0
    bffc:	e4681007 	subi      	r3, r8, 8
    c000:	9360      	ld.w      	r3, (r3, 0)
    c002:	9340      	ld.w      	r2, (r3, 0)
    c004:	e4681007 	subi      	r3, r8, 8
    c008:	9360      	ld.w      	r3, (r3, 0)
    c00a:	9321      	ld.w      	r1, (r3, 0x4)
    c00c:	e468100b 	subi      	r3, r8, 12
    c010:	9360      	ld.w      	r3, (r3, 0)
    c012:	9360      	ld.w      	r3, (r3, 0)
    c014:	b860      	st.w      	r3, (sp, 0)
    c016:	6cc7      	mov      	r3, r1
    c018:	1122      	lrw      	r1, 0xe158	// c0a0 <GV_IPCM_TryConnect+0x1b8>
    c01a:	1103      	lrw      	r0, 0xe1dc	// c0a4 <GV_IPCM_TryConnect+0x1bc>
    c01c:	e3fffc38 	bsr      	0xb88c	// b88c <pr>
    c020:	c4004820 	lsli      	r0, r0, 0
    c024:	1101      	lrw      	r0, 0xdfbc	// c0a8 <GV_IPCM_TryConnect+0x1c0>
    c026:	e3fffc33 	bsr      	0xb88c	// b88c <pr>
    c02a:	c4004820 	lsli      	r0, r0, 0
	printf("ENTRY connect target [%d,%d],file:%d\n",stHandleAttr->target,stHandleAttr->port,ipcm_pool->IpcmFd);	
	//ipcm_trace(TRACE_ZXF_DEBUG,"%s trying to connect target [%d:%d],ipcm_fd:%d ",DEV_NAME,stHandleAttr->target,stHandleAttr->port,ipcm_pool->IpcmFd);
	/*
	 * IOC_try_CONNECT
	 * ret = 0 :connect success ;ret !=0 connect fail
    c02e:	e468100b 	subi      	r3, r8, 12
    c032:	9360      	ld.w      	r3, (r3, 0)
    c034:	9300      	ld.w      	r0, (r3, 0)
    c036:	e4881003 	subi      	r4, r8, 4
    c03a:	e4681007 	subi      	r3, r8, 8
    c03e:	9340      	ld.w      	r2, (r3, 0)
    c040:	1120      	lrw      	r1, 0x400c4d02	// c0c0 <GV_IPCM_TryConnect+0x1d8>
    c042:	eae00021 	jsri      	0x0	// from address pool at 0xc0c4
    c046:	c4004820 	lsli      	r0, r0, 0
    c04a:	b400      	st.w      	r0, (r4, 0)
	 */
    c04c:	e4681003 	subi      	r3, r8, 4
    c050:	9360      	ld.w      	r3, (r3, 0)
    c052:	e9030016 	bez      	r3, 0xc07e	// c07e <GV_IPCM_TryConnect+0x196>
	ret = ioctl(ipcm_pool->IpcmFd, GV_IPCM_IOC_TRY_CONNECT, stHandleAttr);
	if(ret)
    c056:	32b6      	movi      	r2, 182
    c058:	102f      	lrw      	r1, 0xe43c	// c094 <GV_IPCM_TryConnect+0x1ac>
    c05a:	1010      	lrw      	r0, 0xdf84	// c098 <GV_IPCM_TryConnect+0x1b0>
    c05c:	e3fffc18 	bsr      	0xb88c	// b88c <pr>
    c060:	c4004820 	lsli      	r0, r0, 0
    c064:	1019      	lrw      	r0, 0xe1ac	// c0c8 <GV_IPCM_TryConnect+0x1e0>
    c066:	e3fffc13 	bsr      	0xb88c	// b88c <pr>
    c06a:	c4004820 	lsli      	r0, r0, 0
    c06e:	100f      	lrw      	r0, 0xdfbc	// c0a8 <GV_IPCM_TryConnect+0x1c0>
    c070:	e3fffc0e 	bsr      	0xb88c	// b88c <pr>
    c074:	c4004820 	lsli      	r0, r0, 0
	{
    c078:	3300      	movi      	r3, 0
    c07a:	2b00      	subi      	r3, 1
    c07c:	0402      	br      	0xc080	// c080 <GV_IPCM_TryConnect+0x198>
		ipcm_trace(TRACE_ZXF_DEBUG,"connect fail!");
		return -GV_FAILED; 
    c07e:	3300      	movi      	r3, 0
	} 
	return GV_SUCCESS;
    c080:	6c0f      	mov      	r0, r3
    c082:	6fa3      	mov      	sp, r8
    c084:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    c088:	d90e2001 	ld.w      	r8, (sp, 0x4)
    c08c:	9880      	ld.w      	r4, (sp, 0)
    c08e:	1403      	addi      	sp, sp, 12
    c090:	783c      	rts
    c092:	0000      	.short	0x0000
    c094:	0000e43c 	.long	0x0000e43c
    c098:	0000df84 	.long	0x0000df84
    c09c:	0000b88c 	.long	0x0000b88c
    c0a0:	0000e158 	.long	0x0000e158
    c0a4:	0000e1dc 	.long	0x0000e1dc
    c0a8:	0000dfbc 	.long	0x0000dfbc
    c0ac:	0000e12c 	.long	0x0000e12c
    c0b0:	0000cba8 	.long	0x0000cba8
    c0b4:	00000000 	.long	0x00000000
    c0b8:	0000e004 	.long	0x0000e004
    c0bc:	0000e168 	.long	0x0000e168
    c0c0:	400c4d02 	.long	0x400c4d02
    c0c4:	00000000 	.long	0x00000000
    c0c8:	0000e1ac 	.long	0x0000e1ac

0000c0cc <GV_IPCM_Disconnect>:
}


/*
 * Destroy message before Disconnect
 * */
    c0cc:	1423      	subi      	sp, sp, 12
    c0ce:	b880      	st.w      	r4, (sp, 0)
    c0d0:	dd0e2001 	st.w      	r8, (sp, 0x4)
    c0d4:	ddee2002 	st.w      	r15, (sp, 0x8)
    c0d8:	6e3b      	mov      	r8, sp
    c0da:	1422      	subi      	sp, sp, 8
    c0dc:	e4681007 	subi      	r3, r8, 8
    c0e0:	b300      	st.w      	r0, (r3, 0)
GV_IPCM_RetValue_E GV_IPCM_Disconnect(GV_IPCM_MSG_POOL_S *msg_pool)
    c0e2:	e4681003 	subi      	r3, r8, 4
    c0e6:	3200      	movi      	r2, 0
    c0e8:	b340      	st.w      	r2, (r3, 0)
{
    c0ea:	32c4      	movi      	r2, 196
    c0ec:	112e      	lrw      	r1, 0xe450	// c1a4 <GV_IPCM_Disconnect+0xd8>
    c0ee:	110f      	lrw      	r0, 0xdf84	// c1a8 <GV_IPCM_Disconnect+0xdc>
    c0f0:	e3fffbce 	bsr      	0xb88c	// b88c <pr>
    c0f4:	c4004820 	lsli      	r0, r0, 0
    c0f8:	110e      	lrw      	r0, 0xe20c	// c1b0 <GV_IPCM_Disconnect+0xe4>
    c0fa:	e3fffbc9 	bsr      	0xb88c	// b88c <pr>
    c0fe:	c4004820 	lsli      	r0, r0, 0
    c102:	110d      	lrw      	r0, 0xdfbc	// c1b4 <GV_IPCM_Disconnect+0xe8>
    c104:	e3fffbc4 	bsr      	0xb88c	// b88c <pr>
    c108:	c4004820 	lsli      	r0, r0, 0
	int ret = 0;
	ipcm_trace(TRACE_ZXF_DEBUG," Entry disconnect function");

    c10c:	e4681007 	subi      	r3, r8, 8
    c110:	9360      	ld.w      	r3, (r3, 0)
    c112:	9360      	ld.w      	r3, (r3, 0)
    c114:	e4881003 	subi      	r4, r8, 4
    c118:	3200      	movi      	r2, 0
    c11a:	1128      	lrw      	r1, 0x40044d04	// c1b8 <GV_IPCM_Disconnect+0xec>
    c11c:	6c0f      	mov      	r0, r3
    c11e:	eae00028 	jsri      	0x0	// from address pool at 0xc1bc
    c122:	c4004820 	lsli      	r0, r0, 0
    c126:	b400      	st.w      	r0, (r4, 0)
	
    c128:	e4681003 	subi      	r3, r8, 4
    c12c:	9360      	ld.w      	r3, (r3, 0)
    c12e:	e9a30016 	bhsz      	r3, 0xc15a	// c15a <GV_IPCM_Disconnect+0x8e>
	ret = ioctl(msg_pool->IpcmFd, GV_IPCM_IOC_DISCONNECT, NULL);
    c132:	32c9      	movi      	r2, 201
    c134:	103c      	lrw      	r1, 0xe450	// c1a4 <GV_IPCM_Disconnect+0xd8>
    c136:	1103      	lrw      	r0, 0xe004	// c1c0 <GV_IPCM_Disconnect+0xf4>
    c138:	e3fffbaa 	bsr      	0xb88c	// b88c <pr>
    c13c:	c4004820 	lsli      	r0, r0, 0
    c140:	1101      	lrw      	r0, 0xe228	// c1c4 <GV_IPCM_Disconnect+0xf8>
    c142:	e3fffba5 	bsr      	0xb88c	// b88c <pr>
    c146:	c4004820 	lsli      	r0, r0, 0
    c14a:	101b      	lrw      	r0, 0xdfbc	// c1b4 <GV_IPCM_Disconnect+0xe8>
    c14c:	e3fffba0 	bsr      	0xb88c	// b88c <pr>
    c150:	c4004820 	lsli      	r0, r0, 0
	if(ret < 0) {
    c154:	3300      	movi      	r3, 0
    c156:	2b03      	subi      	r3, 4
    c158:	041c      	br      	0xc190	// c190 <GV_IPCM_Disconnect+0xc4>
		ipcm_err("Disconnect error!");
		return -GV_ERR_DISCONNECT;
	}
	
    c15a:	e4681007 	subi      	r3, r8, 8
    c15e:	9360      	ld.w      	r3, (r3, 0)
    c160:	9360      	ld.w      	r3, (r3, 0)
    c162:	6c0f      	mov      	r0, r3
    c164:	eae00019 	jsri      	0x0	// from address pool at 0xc1c8
    c168:	c4004820 	lsli      	r0, r0, 0
	
	close(msg_pool->IpcmFd);
    c16c:	32d0      	movi      	r2, 208
    c16e:	102e      	lrw      	r1, 0xe450	// c1a4 <GV_IPCM_Disconnect+0xd8>
    c170:	100e      	lrw      	r0, 0xdf84	// c1a8 <GV_IPCM_Disconnect+0xdc>
    c172:	e3fffb8d 	bsr      	0xb88c	// b88c <pr>
    c176:	c4004820 	lsli      	r0, r0, 0
    c17a:	1015      	lrw      	r0, 0xe23c	// c1cc <GV_IPCM_Disconnect+0x100>
    c17c:	e3fffb88 	bsr      	0xb88c	// b88c <pr>
    c180:	c4004820 	lsli      	r0, r0, 0
    c184:	100c      	lrw      	r0, 0xdfbc	// c1b4 <GV_IPCM_Disconnect+0xe8>
    c186:	e3fffb83 	bsr      	0xb88c	// b88c <pr>
    c18a:	c4004820 	lsli      	r0, r0, 0
	//free(msg_pool);
    c18e:	3300      	movi      	r3, 0
	ipcm_trace(TRACE_ZXF_DEBUG,"disconnected OK");
    c190:	6c0f      	mov      	r0, r3
    c192:	6fa3      	mov      	sp, r8
    c194:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    c198:	d90e2001 	ld.w      	r8, (sp, 0x4)
    c19c:	9880      	ld.w      	r4, (sp, 0)
    c19e:	1403      	addi      	sp, sp, 12
    c1a0:	783c      	rts
    c1a2:	0000      	.short	0x0000
    c1a4:	0000e450 	.long	0x0000e450
    c1a8:	0000df84 	.long	0x0000df84
    c1ac:	0000b88c 	.long	0x0000b88c
    c1b0:	0000e20c 	.long	0x0000e20c
    c1b4:	0000dfbc 	.long	0x0000dfbc
    c1b8:	40044d04 	.long	0x40044d04
    c1bc:	00000000 	.long	0x00000000
    c1c0:	0000e004 	.long	0x0000e004
    c1c4:	0000e228 	.long	0x0000e228
    c1c8:	00000000 	.long	0x00000000
    c1cc:	0000e23c 	.long	0x0000e23c

0000c1d0 <GV_IPCM_SendMessage>:
	return GV_SUCCESS;
}


    c1d0:	1423      	subi      	sp, sp, 12
    c1d2:	b880      	st.w      	r4, (sp, 0)
    c1d4:	dd0e2001 	st.w      	r8, (sp, 0x4)
    c1d8:	ddee2002 	st.w      	r15, (sp, 0x8)
    c1dc:	6e3b      	mov      	r8, sp
    c1de:	1424      	subi      	sp, sp, 16
    c1e0:	e468100b 	subi      	r3, r8, 12
    c1e4:	b300      	st.w      	r0, (r3, 0)
    c1e6:	e468100f 	subi      	r3, r8, 16
    c1ea:	b320      	st.w      	r1, (r3, 0)
GV_IPCM_RetValue_E GV_IPCM_SendMessage(const GV_IPCM_MSG_S *pstMsg,GV_IPCM_MSG_POOL_S *msg_pool)
    c1ec:	e4681003 	subi      	r3, r8, 4
    c1f0:	3200      	movi      	r2, 0
    c1f2:	b340      	st.w      	r2, (r3, 0)
{
	int ret = 0;
    c1f4:	e4681007 	subi      	r3, r8, 8
    c1f8:	3210      	movi      	r2, 16
    c1fa:	b340      	st.w      	r2, (r3, 0)

	int msg_len = sizeof(struct ipcm_msg_body);
    c1fc:	32db      	movi      	r2, 219
    c1fe:	122e      	lrw      	r1, 0xe464	// c334 <GV_IPCM_SendMessage+0x164>
    c200:	120e      	lrw      	r0, 0xdf84	// c338 <GV_IPCM_SendMessage+0x168>
    c202:	e3fffb45 	bsr      	0xb88c	// b88c <pr>
    c206:	c4004820 	lsli      	r0, r0, 0
    c20a:	e468100f 	subi      	r3, r8, 16
    c20e:	9360      	ld.w      	r3, (r3, 0)
    c210:	9320      	ld.w      	r1, (r3, 0)
    c212:	e4681007 	subi      	r3, r8, 8
    c216:	9340      	ld.w      	r2, (r3, 0)
    c218:	120a      	lrw      	r0, 0xe24c	// c340 <GV_IPCM_SendMessage+0x170>
    c21a:	e3fffb39 	bsr      	0xb88c	// b88c <pr>
    c21e:	c4004820 	lsli      	r0, r0, 0
    c222:	1209      	lrw      	r0, 0xdfbc	// c344 <GV_IPCM_SendMessage+0x174>
    c224:	e3fffb34 	bsr      	0xb88c	// b88c <pr>
    c228:	c4004820 	lsli      	r0, r0, 0

    c22c:	e4681007 	subi      	r3, r8, 8
    c230:	9360      	ld.w      	r3, (r3, 0)
    c232:	eb2307e0 	cmplti      	r3, 2017
    c236:	0815      	bt      	0xc260	// c260 <GV_IPCM_SendMessage+0x90>
	ipcm_trace(TRACE_ZXF_DEBUG,"entry send message begin fd: %d,msg_len = %d",msg_pool->IpcmFd,msg_len);
	if(msg_len > MAX_SEND_LEN)
    c238:	32de      	movi      	r2, 222
    c23a:	113f      	lrw      	r1, 0xe464	// c334 <GV_IPCM_SendMessage+0x164>
    c23c:	1203      	lrw      	r0, 0xe004	// c348 <GV_IPCM_SendMessage+0x178>
    c23e:	e3fffb27 	bsr      	0xb88c	// b88c <pr>
    c242:	c4004820 	lsli      	r0, r0, 0
    c246:	1202      	lrw      	r0, 0xe27c	// c34c <GV_IPCM_SendMessage+0x17c>
    c248:	e3fffb22 	bsr      	0xb88c	// b88c <pr>
    c24c:	c4004820 	lsli      	r0, r0, 0
    c250:	111d      	lrw      	r0, 0xdfbc	// c344 <GV_IPCM_SendMessage+0x174>
    c252:	e3fffb1d 	bsr      	0xb88c	// b88c <pr>
    c256:	c4004820 	lsli      	r0, r0, 0
	{
    c25a:	3300      	movi      	r3, 0
    c25c:	2b01      	subi      	r3, 2
    c25e:	0462      	br      	0xc322	// c322 <GV_IPCM_SendMessage+0x152>
		ipcm_err("send Message length is beyond of max_send_len");
		return -GV_EVALID;
    c260:	32e1      	movi      	r2, 225
    c262:	1135      	lrw      	r1, 0xe464	// c334 <GV_IPCM_SendMessage+0x164>
    c264:	1115      	lrw      	r0, 0xdf84	// c338 <GV_IPCM_SendMessage+0x168>
    c266:	e3fffb13 	bsr      	0xb88c	// b88c <pr>
    c26a:	c4004820 	lsli      	r0, r0, 0
    c26e:	e468100f 	subi      	r3, r8, 16
    c272:	9360      	ld.w      	r3, (r3, 0)
    c274:	9360      	ld.w      	r3, (r3, 0)
    c276:	6c4f      	mov      	r1, r3
    c278:	1116      	lrw      	r0, 0xe2ac	// c350 <GV_IPCM_SendMessage+0x180>
    c27a:	e3fffb09 	bsr      	0xb88c	// b88c <pr>
    c27e:	c4004820 	lsli      	r0, r0, 0
    c282:	1111      	lrw      	r0, 0xdfbc	// c344 <GV_IPCM_SendMessage+0x174>
    c284:	e3fffb04 	bsr      	0xb88c	// b88c <pr>
    c288:	c4004820 	lsli      	r0, r0, 0
	}
    c28c:	e468100f 	subi      	r3, r8, 16
    c290:	9360      	ld.w      	r3, (r3, 0)
    c292:	9300      	ld.w      	r0, (r3, 0)
    c294:	e468100b 	subi      	r3, r8, 12
    c298:	9360      	ld.w      	r3, (r3, 0)
    c29a:	9321      	ld.w      	r1, (r3, 0x4)
    c29c:	e4681007 	subi      	r3, r8, 8
    c2a0:	9360      	ld.w      	r3, (r3, 0)
    c2a2:	e4881003 	subi      	r4, r8, 4
    c2a6:	6c8f      	mov      	r2, r3
    c2a8:	eae0002b 	jsri      	0x0	// from address pool at 0xc354
    c2ac:	c4004820 	lsli      	r0, r0, 0
    c2b0:	b400      	st.w      	r0, (r4, 0)
	ipcm_trace(TRACE_ZXF_DEBUG,"send message begin fd: %d",msg_pool->IpcmFd);
    c2b2:	e4481003 	subi      	r2, r8, 4
    c2b6:	e4681007 	subi      	r3, r8, 8
    c2ba:	9240      	ld.w      	r2, (r2, 0)
    c2bc:	9360      	ld.w      	r3, (r3, 0)
    c2be:	64ca      	cmpne      	r2, r3
    c2c0:	0c1a      	bf      	0xc2f4	// c2f4 <GV_IPCM_SendMessage+0x124>
	ret = write(msg_pool->IpcmFd,(void *)pstMsg->msg_body,msg_len);
    c2c2:	32e4      	movi      	r2, 228
    c2c4:	103c      	lrw      	r1, 0xe464	// c334 <GV_IPCM_SendMessage+0x164>
    c2c6:	1101      	lrw      	r0, 0xe004	// c348 <GV_IPCM_SendMessage+0x178>
    c2c8:	e3fffae2 	bsr      	0xb88c	// b88c <pr>
    c2cc:	c4004820 	lsli      	r0, r0, 0
    c2d0:	e4681003 	subi      	r3, r8, 4
    c2d4:	9320      	ld.w      	r1, (r3, 0)
    c2d6:	1101      	lrw      	r0, 0xe2c8	// c358 <GV_IPCM_SendMessage+0x188>
    c2d8:	e3fffada 	bsr      	0xb88c	// b88c <pr>
    c2dc:	c4004820 	lsli      	r0, r0, 0
    c2e0:	1019      	lrw      	r0, 0xdfbc	// c344 <GV_IPCM_SendMessage+0x174>
    c2e2:	e3fffad5 	bsr      	0xb88c	// b88c <pr>
    c2e6:	c4004820 	lsli      	r0, r0, 0
	if(ret != msg_len) {
    c2ea:	e4481003 	subi      	r2, r8, 4
    c2ee:	3300      	movi      	r3, 0
    c2f0:	2b04      	subi      	r3, 5
    c2f2:	b260      	st.w      	r3, (r2, 0)
		ipcm_err("write error which return %d",ret);
		ret = -GV_ERR_WRITE;
	}
    c2f4:	32e8      	movi      	r2, 232
    c2f6:	1030      	lrw      	r1, 0xe464	// c334 <GV_IPCM_SendMessage+0x164>
    c2f8:	1010      	lrw      	r0, 0xdf84	// c338 <GV_IPCM_SendMessage+0x168>
    c2fa:	e3fffac9 	bsr      	0xb88c	// b88c <pr>
    c2fe:	c4004820 	lsli      	r0, r0, 0
    c302:	e468100f 	subi      	r3, r8, 16
    c306:	9360      	ld.w      	r3, (r3, 0)
    c308:	9360      	ld.w      	r3, (r3, 0)
    c30a:	6c4f      	mov      	r1, r3
    c30c:	1014      	lrw      	r0, 0xe2e4	// c35c <GV_IPCM_SendMessage+0x18c>
    c30e:	e3fffabf 	bsr      	0xb88c	// b88c <pr>
    c312:	c4004820 	lsli      	r0, r0, 0
    c316:	100c      	lrw      	r0, 0xdfbc	// c344 <GV_IPCM_SendMessage+0x174>
    c318:	e3fffaba 	bsr      	0xb88c	// b88c <pr>
    c31c:	c4004820 	lsli      	r0, r0, 0

    c320:	3300      	movi      	r3, 0
	ipcm_trace(TRACE_ZXF_DEBUG,"send message after fd: %d",msg_pool->IpcmFd);
    c322:	6c0f      	mov      	r0, r3
    c324:	6fa3      	mov      	sp, r8
    c326:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    c32a:	d90e2001 	ld.w      	r8, (sp, 0x4)
    c32e:	9880      	ld.w      	r4, (sp, 0)
    c330:	1403      	addi      	sp, sp, 12
    c332:	783c      	rts
    c334:	0000e464 	.long	0x0000e464
    c338:	0000df84 	.long	0x0000df84
    c33c:	0000b88c 	.long	0x0000b88c
    c340:	0000e24c 	.long	0x0000e24c
    c344:	0000dfbc 	.long	0x0000dfbc
    c348:	0000e004 	.long	0x0000e004
    c34c:	0000e27c 	.long	0x0000e27c
    c350:	0000e2ac 	.long	0x0000e2ac
    c354:	00000000 	.long	0x00000000
    c358:	0000e2c8 	.long	0x0000e2c8
    c35c:	0000e2e4 	.long	0x0000e2e4

0000c360 <GV_IPCM_ReceiveMessage>:
	return GV_SUCCESS;	
}

    c360:	1423      	subi      	sp, sp, 12
    c362:	b880      	st.w      	r4, (sp, 0)
    c364:	dd0e2001 	st.w      	r8, (sp, 0x4)
    c368:	ddee2002 	st.w      	r15, (sp, 0x8)
    c36c:	6e3b      	mov      	r8, sp
    c36e:	152a      	subi      	sp, sp, 168
    c370:	e468109b 	subi      	r3, r8, 156
    c374:	b300      	st.w      	r0, (r3, 0)
    c376:	e468109f 	subi      	r3, r8, 160
    c37a:	b320      	st.w      	r1, (r3, 0)
    c37c:	e46810a3 	subi      	r3, r8, 164
    c380:	b340      	st.w      	r2, (r3, 0)
GV_IPCM_RetValue_E GV_IPCM_ReceiveMessage(GV_IPCM_MSG_POOL_S *msg_pool,GV_IPCM_MSG_S *pstMsgResp,GV_S32* msg_len)
    c382:	e4681003 	subi      	r3, r8, 4
    c386:	3200      	movi      	r2, 0
    c388:	b340      	st.w      	r2, (r3, 0)
{
    c38a:	e468100b 	subi      	r3, r8, 12
    c38e:	3200      	movi      	r2, 0
    c390:	b340      	st.w      	r2, (r3, 0)
	int ret = 0;	
	int len = 0;
	
	fd_set rfds;
	struct timeval timeout;
    c392:	e468109b 	subi      	r3, r8, 156
    c396:	9360      	ld.w      	r3, (r3, 0)
    c398:	9360      	ld.w      	r3, (r3, 0)
    c39a:	e923001b 	bnez      	r3, 0xc3d0	// c3d0 <GV_IPCM_ReceiveMessage+0x70>

	if(!msg_pool->IpcmFd)
    c39e:	32f6      	movi      	r2, 246
    c3a0:	132d      	lrw      	r1, 0xe478	// c554 <GV_IPCM_ReceiveMessage+0x1f4>
    c3a2:	130e      	lrw      	r0, 0xe004	// c558 <GV_IPCM_ReceiveMessage+0x1f8>
    c3a4:	e3fffa74 	bsr      	0xb88c	// b88c <pr>
    c3a8:	c4004820 	lsli      	r0, r0, 0
    c3ac:	e468109b 	subi      	r3, r8, 156
    c3b0:	9360      	ld.w      	r3, (r3, 0)
    c3b2:	9360      	ld.w      	r3, (r3, 0)
    c3b4:	6c4f      	mov      	r1, r3
    c3b6:	130b      	lrw      	r0, 0xe300	// c560 <GV_IPCM_ReceiveMessage+0x200>
    c3b8:	e3fffa6a 	bsr      	0xb88c	// b88c <pr>
    c3bc:	c4004820 	lsli      	r0, r0, 0
    c3c0:	1309      	lrw      	r0, 0xdfbc	// c564 <GV_IPCM_ReceiveMessage+0x204>
    c3c2:	e3fffa65 	bsr      	0xb88c	// b88c <pr>
    c3c6:	c4004820 	lsli      	r0, r0, 0
	{
    c3ca:	3300      	movi      	r3, 0
    c3cc:	2b01      	subi      	r3, 2
    c3ce:	0555      	br      	0xc678	// c678 <GV_IPCM_ReceiveMessage+0x318>
		ipcm_err("file desc is error %d",msg_pool->IpcmFd);
		return -GV_EVALID;
	}
    c3d0:	32fa      	movi      	r2, 250
    c3d2:	1321      	lrw      	r1, 0xe478	// c554 <GV_IPCM_ReceiveMessage+0x1f4>
    c3d4:	1305      	lrw      	r0, 0xdf84	// c568 <GV_IPCM_ReceiveMessage+0x208>
    c3d6:	e3fffa5b 	bsr      	0xb88c	// b88c <pr>
    c3da:	c4004820 	lsli      	r0, r0, 0
    c3de:	e468109b 	subi      	r3, r8, 156
    c3e2:	9360      	ld.w      	r3, (r3, 0)
    c3e4:	9360      	ld.w      	r3, (r3, 0)
    c3e6:	6c4f      	mov      	r1, r3
    c3e8:	1301      	lrw      	r0, 0xe318	// c56c <GV_IPCM_ReceiveMessage+0x20c>
    c3ea:	e3fffa51 	bsr      	0xb88c	// b88c <pr>
    c3ee:	c4004820 	lsli      	r0, r0, 0
    c3f2:	121d      	lrw      	r0, 0xdfbc	// c564 <GV_IPCM_ReceiveMessage+0x204>
    c3f4:	e3fffa4c 	bsr      	0xb88c	// b88c <pr>
    c3f8:	c4004820 	lsli      	r0, r0, 0

	ipcm_trace(TRACE_ZXF_DEBUG,"recv message before fd: %d",msg_pool->IpcmFd);	
    c3fc:	e4681097 	subi      	r3, r8, 152
    c400:	3202      	movi      	r2, 2
    c402:	b340      	st.w      	r2, (r3, 0)
	while(1) {
    c404:	e4681097 	subi      	r3, r8, 152
    c408:	3200      	movi      	r2, 0
    c40a:	b341      	st.w      	r2, (r3, 0x4)
		timeout.tv_sec = 2;
    c40c:	e468100f 	subi      	r3, r8, 16
    c410:	e448108f 	subi      	r2, r8, 144
    c414:	b340      	st.w      	r2, (r3, 0)
    c416:	e4681007 	subi      	r3, r8, 8
    c41a:	3200      	movi      	r2, 0
    c41c:	b340      	st.w      	r2, (r3, 0)
    c41e:	0411      	br      	0xc440	// c440 <GV_IPCM_ReceiveMessage+0xe0>
    c420:	e468100f 	subi      	r3, r8, 16
    c424:	9360      	ld.w      	r3, (r3, 0)
    c426:	e4481007 	subi      	r2, r8, 8
    c42a:	9240      	ld.w      	r2, (r2, 0)
    c42c:	3100      	movi      	r1, 0
    c42e:	d4430881 	str.w      	r1, (r3, r2 << 2)
    c432:	e4681007 	subi      	r3, r8, 8
    c436:	e4481007 	subi      	r2, r8, 8
    c43a:	9240      	ld.w      	r2, (r2, 0)
    c43c:	2200      	addi      	r2, 1
    c43e:	b340      	st.w      	r2, (r3, 0)
    c440:	e4681007 	subi      	r3, r8, 8
    c444:	9340      	ld.w      	r2, (r3, 0)
    c446:	331f      	movi      	r3, 31
    c448:	648c      	cmphs      	r3, r2
    c44a:	0beb      	bt      	0xc420	// c420 <GV_IPCM_ReceiveMessage+0xc0>
		timeout.tv_usec = 0;
    c44c:	e468109b 	subi      	r3, r8, 156
    c450:	9360      	ld.w      	r3, (r3, 0)
    c452:	9360      	ld.w      	r3, (r3, 0)
    c454:	e9a30003 	bhsz      	r3, 0xc45a	// c45a <GV_IPCM_ReceiveMessage+0xfa>
    c458:	231e      	addi      	r3, 31
    c45a:	5365      	asri      	r3, r3, 5
    c45c:	6c4f      	mov      	r1, r3
    c45e:	e468108f 	subi      	r3, r8, 144
    c462:	d0230880 	ldr.w      	r0, (r3, r1 << 2)
    c466:	e468109b 	subi      	r3, r8, 156
    c46a:	9360      	ld.w      	r3, (r3, 0)
    c46c:	9340      	ld.w      	r2, (r3, 0)
    c46e:	c7c05023 	bmaski      	r3, 31
    c472:	2b1e      	subi      	r3, 31
    c474:	c4622043 	andn      	r3, r2, r3
    c478:	e9a30007 	bhsz      	r3, 0xc486	// c486 <GV_IPCM_ReceiveMessage+0x126>
    c47c:	2b00      	subi      	r3, 1
    c47e:	3200      	movi      	r2, 0
    c480:	2a1f      	subi      	r2, 32
    c482:	6cc8      	or      	r3, r2
    c484:	2300      	addi      	r3, 1
    c486:	6c8f      	mov      	r2, r3
    c488:	3301      	movi      	r3, 1
    c48a:	70c8      	lsl      	r3, r2
    c48c:	c4602422 	or      	r2, r0, r3
    c490:	e468108f 	subi      	r3, r8, 144
    c494:	d4230882 	str.w      	r2, (r3, r1 << 2)
		FD_ZERO(&rfds);
    c498:	e468109b 	subi      	r3, r8, 156
    c49c:	9360      	ld.w      	r3, (r3, 0)
    c49e:	9360      	ld.w      	r3, (r3, 0)
    c4a0:	5b02      	addi      	r0, r3, 1
    c4a2:	e4881003 	subi      	r4, r8, 4
    c4a6:	e428108f 	subi      	r1, r8, 144
    c4aa:	e4681097 	subi      	r3, r8, 152
    c4ae:	b860      	st.w      	r3, (sp, 0)
    c4b0:	3300      	movi      	r3, 0
    c4b2:	3200      	movi      	r2, 0
    c4b4:	eae0002f 	jsri      	0x0	// from address pool at 0xc570
    c4b8:	c4004820 	lsli      	r0, r0, 0
    c4bc:	b400      	st.w      	r0, (r4, 0)
		FD_SET(msg_pool->IpcmFd, &rfds);
    c4be:	e4681003 	subi      	r3, r8, 4
    c4c2:	9340      	ld.w      	r2, (r3, 0)
    c4c4:	3300      	movi      	r3, 0
    c4c6:	2b00      	subi      	r3, 1
    c4c8:	64ca      	cmpne      	r2, r3
    c4ca:	0819      	bt      	0xc4fc	// c4fc <GV_IPCM_ReceiveMessage+0x19c>
		ret = select(msg_pool->IpcmFd + 1, &rfds, NULL, NULL, &timeout);
    c4cc:	ea020102 	movi      	r2, 258
    c4d0:	1121      	lrw      	r1, 0xe478	// c554 <GV_IPCM_ReceiveMessage+0x1f4>
    c4d2:	1102      	lrw      	r0, 0xe004	// c558 <GV_IPCM_ReceiveMessage+0x1f8>
    c4d4:	e3fff9dc 	bsr      	0xb88c	// b88c <pr>
    c4d8:	c4004820 	lsli      	r0, r0, 0
    c4dc:	1106      	lrw      	r0, 0xe334	// c574 <GV_IPCM_ReceiveMessage+0x214>
    c4de:	e3fff9d7 	bsr      	0xb88c	// b88c <pr>
    c4e2:	c4004820 	lsli      	r0, r0, 0
    c4e6:	1100      	lrw      	r0, 0xdfbc	// c564 <GV_IPCM_ReceiveMessage+0x204>
    c4e8:	e3fff9d2 	bsr      	0xb88c	// b88c <pr>
    c4ec:	c4004820 	lsli      	r0, r0, 0
		if (-1 == ret) {
    c4f0:	e4481003 	subi      	r2, r8, 4
    c4f4:	3300      	movi      	r3, 0
    c4f6:	2b00      	subi      	r3, 1
    c4f8:	b260      	st.w      	r3, (r2, 0)
			ipcm_err("SELECT error");
    c4fa:	04bc      	br      	0xc672	// c672 <GV_IPCM_ReceiveMessage+0x312>
			ret = -GV_FAILED;
    c4fc:	e4681003 	subi      	r3, r8, 4
    c500:	9360      	ld.w      	r3, (r3, 0)
    c502:	e9230041 	bnez      	r3, 0xc584	// c584 <GV_IPCM_ReceiveMessage+0x224>
			break;
    c506:	e468109b 	subi      	r3, r8, 156
    c50a:	9360      	ld.w      	r3, (r3, 0)
    c50c:	9360      	ld.w      	r3, (r3, 0)
    c50e:	3200      	movi      	r2, 0
    c510:	103a      	lrw      	r1, 0x40044d03	// c578 <GV_IPCM_ReceiveMessage+0x218>
    c512:	6c0f      	mov      	r0, r3
    c514:	eae0001a 	jsri      	0x0	// from address pool at 0xc57c
    c518:	c4004820 	lsli      	r0, r0, 0
    c51c:	6cc3      	mov      	r3, r0
    c51e:	3b42      	cmpnei      	r3, 2
    c520:	0c32      	bf      	0xc584	// c584 <GV_IPCM_ReceiveMessage+0x224>
		} else if (!ret) {
    c522:	ea020107 	movi      	r2, 263
    c526:	102c      	lrw      	r1, 0xe478	// c554 <GV_IPCM_ReceiveMessage+0x1f4>
    c528:	100c      	lrw      	r0, 0xe004	// c558 <GV_IPCM_ReceiveMessage+0x1f8>
    c52a:	e3fff9b1 	bsr      	0xb88c	// b88c <pr>
    c52e:	c4004820 	lsli      	r0, r0, 0
    c532:	1014      	lrw      	r0, 0xe344	// c580 <GV_IPCM_ReceiveMessage+0x220>
    c534:	e3fff9ac 	bsr      	0xb88c	// b88c <pr>
    c538:	c4004820 	lsli      	r0, r0, 0
    c53c:	100a      	lrw      	r0, 0xdfbc	// c564 <GV_IPCM_ReceiveMessage+0x204>
    c53e:	e3fff9a7 	bsr      	0xb88c	// b88c <pr>
    c542:	c4004820 	lsli      	r0, r0, 0
			if(HANDLE_CONNECTED != ioctl(msg_pool->IpcmFd, GV_IPCM_IOC_CHECK, NULL)) {
    c546:	e4481003 	subi      	r2, r8, 4
    c54a:	3300      	movi      	r3, 0
    c54c:	2b00      	subi      	r3, 1
    c54e:	b260      	st.w      	r3, (r2, 0)
				ipcm_err("Disconnected by remote,exit");				
    c550:	0491      	br      	0xc672	// c672 <GV_IPCM_ReceiveMessage+0x312>
    c552:	0000      	.short	0x0000
    c554:	0000e478 	.long	0x0000e478
    c558:	0000e004 	.long	0x0000e004
    c55c:	0000b88c 	.long	0x0000b88c
    c560:	0000e300 	.long	0x0000e300
    c564:	0000dfbc 	.long	0x0000dfbc
    c568:	0000df84 	.long	0x0000df84
    c56c:	0000e318 	.long	0x0000e318
    c570:	00000000 	.long	0x00000000
    c574:	0000e334 	.long	0x0000e334
    c578:	40044d03 	.long	0x40044d03
    c57c:	00000000 	.long	0x00000000
    c580:	0000e344 	.long	0x0000e344
				ret = -GV_FAILED;
				break;
			}
			/*if timeout and handle is connect,routine will infinite run*/
		}
    c584:	e468109b 	subi      	r3, r8, 156
    c588:	9360      	ld.w      	r3, (r3, 0)
    c58a:	9360      	ld.w      	r3, (r3, 0)
    c58c:	e9a30003 	bhsz      	r3, 0xc592	// c592 <GV_IPCM_ReceiveMessage+0x232>
    c590:	231e      	addi      	r3, 31
    c592:	5365      	asri      	r3, r3, 5
    c594:	6c8f      	mov      	r2, r3
    c596:	e468108f 	subi      	r3, r8, 144
    c59a:	d0430881 	ldr.w      	r1, (r3, r2 << 2)
    c59e:	e468109b 	subi      	r3, r8, 156
    c5a2:	9360      	ld.w      	r3, (r3, 0)
    c5a4:	9340      	ld.w      	r2, (r3, 0)
    c5a6:	c7c05023 	bmaski      	r3, 31
    c5aa:	2b1e      	subi      	r3, 31
    c5ac:	c4622043 	andn      	r3, r2, r3
    c5b0:	e9a30007 	bhsz      	r3, 0xc5be	// c5be <GV_IPCM_ReceiveMessage+0x25e>
    c5b4:	2b00      	subi      	r3, 1
    c5b6:	3200      	movi      	r2, 0
    c5b8:	2a1f      	subi      	r2, 32
    c5ba:	6cc8      	or      	r3, r2
    c5bc:	2300      	addi      	r3, 1
    c5be:	6c8f      	mov      	r2, r3
    c5c0:	3301      	movi      	r3, 1
    c5c2:	70c8      	lsl      	r3, r2
    c5c4:	68c4      	and      	r3, r1
    c5c6:	e903ff1b 	bez      	r3, 0xc3fc	// c3fc <GV_IPCM_ReceiveMessage+0x9c>

    c5ca:	e468109b 	subi      	r3, r8, 156
    c5ce:	9360      	ld.w      	r3, (r3, 0)
    c5d0:	9300      	ld.w      	r0, (r3, 0)
    c5d2:	e468109f 	subi      	r3, r8, 160
    c5d6:	9360      	ld.w      	r3, (r3, 0)
    c5d8:	9361      	ld.w      	r3, (r3, 0x4)
    c5da:	e488100b 	subi      	r4, r8, 12
    c5de:	ea0207e0 	movi      	r2, 2016
    c5e2:	6c4f      	mov      	r1, r3
    c5e4:	eae0002a 	jsri      	0x0	// from address pool at 0xc68c
    c5e8:	c4004820 	lsli      	r0, r0, 0
    c5ec:	b400      	st.w      	r0, (r4, 0)
		if (FD_ISSET(msg_pool->IpcmFd, &rfds)) {
    c5ee:	e468100b 	subi      	r3, r8, 12
    c5f2:	9360      	ld.w      	r3, (r3, 0)
    c5f4:	e9a3001d 	bhsz      	r3, 0xc62e	// c62e <GV_IPCM_ReceiveMessage+0x2ce>
			len = read(msg_pool->IpcmFd,(void *)pstMsgResp->msg_body,MAX_SEND_LEN);
    c5f8:	ea020111 	movi      	r2, 273
    c5fc:	1125      	lrw      	r1, 0xe478	// c690 <GV_IPCM_ReceiveMessage+0x330>
    c5fe:	1106      	lrw      	r0, 0xe004	// c694 <GV_IPCM_ReceiveMessage+0x334>
    c600:	e3fff946 	bsr      	0xb88c	// b88c <pr>
    c604:	c4004820 	lsli      	r0, r0, 0
    c608:	e4681003 	subi      	r3, r8, 4
    c60c:	9320      	ld.w      	r1, (r3, 0)
    c60e:	1104      	lrw      	r0, 0xe360	// c69c <GV_IPCM_ReceiveMessage+0x33c>
    c610:	e3fff93e 	bsr      	0xb88c	// b88c <pr>
    c614:	c4004820 	lsli      	r0, r0, 0
    c618:	1102      	lrw      	r0, 0xdfbc	// c6a0 <GV_IPCM_ReceiveMessage+0x340>
    c61a:	e3fff939 	bsr      	0xb88c	// b88c <pr>
    c61e:	c4004820 	lsli      	r0, r0, 0
			if(len < 0) {
    c622:	e4481003 	subi      	r2, r8, 4
    c626:	3300      	movi      	r3, 0
    c628:	2b00      	subi      	r3, 1
    c62a:	b260      	st.w      	r3, (r2, 0)
				ipcm_err("read error %d.",ret);
    c62c:	0423      	br      	0xc672	// c672 <GV_IPCM_ReceiveMessage+0x312>
				ret = -1;
				break;
    c62e:	e46810a3 	subi      	r3, r8, 164
    c632:	9360      	ld.w      	r3, (r3, 0)
    c634:	e448100b 	subi      	r2, r8, 12
    c638:	9240      	ld.w      	r2, (r2, 0)
    c63a:	b340      	st.w      	r2, (r3, 0)
			}
    c63c:	e4681003 	subi      	r3, r8, 4
    c640:	3200      	movi      	r2, 0
    c642:	b340      	st.w      	r2, (r3, 0)
			*msg_len = len;
    c644:	ea020117 	movi      	r2, 279
    c648:	1032      	lrw      	r1, 0xe478	// c690 <GV_IPCM_ReceiveMessage+0x330>
    c64a:	1017      	lrw      	r0, 0xdf84	// c6a4 <GV_IPCM_ReceiveMessage+0x344>
    c64c:	e3fff920 	bsr      	0xb88c	// b88c <pr>
    c650:	c4004820 	lsli      	r0, r0, 0
    c654:	e46810a3 	subi      	r3, r8, 164
    c658:	9360      	ld.w      	r3, (r3, 0)
    c65a:	9360      	ld.w      	r3, (r3, 0)
    c65c:	6c4f      	mov      	r1, r3
    c65e:	1013      	lrw      	r0, 0xe370	// c6a8 <GV_IPCM_ReceiveMessage+0x348>
    c660:	e3fff916 	bsr      	0xb88c	// b88c <pr>
    c664:	c4004820 	lsli      	r0, r0, 0
    c668:	100e      	lrw      	r0, 0xdfbc	// c6a0 <GV_IPCM_ReceiveMessage+0x340>
    c66a:	e3fff911 	bsr      	0xb88c	// b88c <pr>
    c66e:	c4004820 	lsli      	r0, r0, 0
			ret = GV_SUCCESS;
			ipcm_trace(TRACE_ZXF_DEBUG,"Read message length %d.",*msg_len);
			break;
		}
    c672:	e4681003 	subi      	r3, r8, 4
    c676:	9360      	ld.w      	r3, (r3, 0)
	}
    c678:	6c0f      	mov      	r0, r3
    c67a:	6fa3      	mov      	sp, r8
    c67c:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    c680:	d90e2001 	ld.w      	r8, (sp, 0x4)
    c684:	9880      	ld.w      	r4, (sp, 0)
    c686:	1403      	addi      	sp, sp, 12
    c688:	783c      	rts
    c68a:	0000      	.short	0x0000
    c68c:	00000000 	.long	0x00000000
    c690:	0000e478 	.long	0x0000e478
    c694:	0000e004 	.long	0x0000e004
    c698:	0000b88c 	.long	0x0000b88c
    c69c:	0000e360 	.long	0x0000e360
    c6a0:	0000dfbc 	.long	0x0000dfbc
    c6a4:	0000df84 	.long	0x0000df84
    c6a8:	0000e370 	.long	0x0000e370

0000c6ac <GV_IPCM_SendsyncMessage>:
	return ret;
}


    c6ac:	1423      	subi      	sp, sp, 12
    c6ae:	b880      	st.w      	r4, (sp, 0)
    c6b0:	dd0e2001 	st.w      	r8, (sp, 0x4)
    c6b4:	ddee2002 	st.w      	r15, (sp, 0x8)
    c6b8:	6e3b      	mov      	r8, sp
    c6ba:	152b      	subi      	sp, sp, 172
    c6bc:	e468109f 	subi      	r3, r8, 160
    c6c0:	b300      	st.w      	r0, (r3, 0)
    c6c2:	e46810a3 	subi      	r3, r8, 164
    c6c6:	b320      	st.w      	r1, (r3, 0)
    c6c8:	e46810a7 	subi      	r3, r8, 168
    c6cc:	b340      	st.w      	r2, (r3, 0)
GV_IPCM_RetValue_E GV_IPCM_SendsyncMessage(GV_IPCM_MSG_POOL_S *msg_pool,const GV_IPCM_MSG_S *pstMsg,GV_IPCM_MSG_S *pstMsgResp)
    c6ce:	e4681003 	subi      	r3, r8, 4
    c6d2:	3200      	movi      	r2, 0
    c6d4:	b340      	st.w      	r2, (r3, 0)
{
	int ret = 0;	
	int len;
	
	fd_set rfds;
    c6d6:	e468100b 	subi      	r3, r8, 12
    c6da:	3210      	movi      	r2, 16
    c6dc:	b340      	st.w      	r2, (r3, 0)
	struct timeval timeout;
	int msg_len = sizeof(struct ipcm_msg_body);
    c6de:	e468109f 	subi      	r3, r8, 160
    c6e2:	9360      	ld.w      	r3, (r3, 0)
    c6e4:	9300      	ld.w      	r0, (r3, 0)
    c6e6:	e46810a3 	subi      	r3, r8, 164
    c6ea:	9360      	ld.w      	r3, (r3, 0)
    c6ec:	9321      	ld.w      	r1, (r3, 0x4)
    c6ee:	e468100b 	subi      	r3, r8, 12
    c6f2:	9360      	ld.w      	r3, (r3, 0)
    c6f4:	e4881003 	subi      	r4, r8, 4
    c6f8:	6c8f      	mov      	r2, r3
    c6fa:	eae00094 	jsri      	0x0	// from address pool at 0xc948
    c6fe:	c4004820 	lsli      	r0, r0, 0
    c702:	b400      	st.w      	r0, (r4, 0)

    c704:	e4481003 	subi      	r2, r8, 4
    c708:	e468100b 	subi      	r3, r8, 12
    c70c:	9240      	ld.w      	r2, (r2, 0)
    c70e:	9360      	ld.w      	r3, (r3, 0)
    c710:	64ca      	cmpne      	r2, r3
    c712:	0c1f      	bf      	0xc750	// c750 <GV_IPCM_SendsyncMessage+0xa4>
	ret = write(msg_pool->IpcmFd,pstMsg->msg_body,msg_len);
    c714:	ea02012a 	movi      	r2, 298
    c718:	ea81008d 	lrw      	r1, 0xe490	// c94c <GV_IPCM_SendsyncMessage+0x2a0>
    c71c:	ea80008d 	lrw      	r0, 0xe004	// c950 <GV_IPCM_SendsyncMessage+0x2a4>
    c720:	e3fff8b6 	bsr      	0xb88c	// b88c <pr>
    c724:	c4004820 	lsli      	r0, r0, 0
    c728:	e4681003 	subi      	r3, r8, 4
    c72c:	9320      	ld.w      	r1, (r3, 0)
    c72e:	ea80008b 	lrw      	r0, 0xe388	// c958 <GV_IPCM_SendsyncMessage+0x2ac>
    c732:	e3fff8ad 	bsr      	0xb88c	// b88c <pr>
    c736:	c4004820 	lsli      	r0, r0, 0
    c73a:	ea800089 	lrw      	r0, 0xdfbc	// c95c <GV_IPCM_SendsyncMessage+0x2b0>
    c73e:	e3fff8a7 	bsr      	0xb88c	// b88c <pr>
    c742:	c4004820 	lsli      	r0, r0, 0
	if(ret != msg_len) {
    c746:	e4481003 	subi      	r2, r8, 4
    c74a:	3300      	movi      	r3, 0
    c74c:	2b04      	subi      	r3, 5
    c74e:	b260      	st.w      	r3, (r2, 0)
		ipcm_err("write error which return %d.",ret);
		ret = -GV_ERR_WRITE;
	}

	while(1) {
    c750:	e468109b 	subi      	r3, r8, 156
    c754:	3202      	movi      	r2, 2
    c756:	b340      	st.w      	r2, (r3, 0)
		
    c758:	e468109b 	subi      	r3, r8, 156
    c75c:	3200      	movi      	r2, 0
    c75e:	b341      	st.w      	r2, (r3, 0x4)
		timeout.tv_sec  = 2;
    c760:	e468100f 	subi      	r3, r8, 16
    c764:	e4481093 	subi      	r2, r8, 148
    c768:	b340      	st.w      	r2, (r3, 0)
    c76a:	e4681007 	subi      	r3, r8, 8
    c76e:	3200      	movi      	r2, 0
    c770:	b340      	st.w      	r2, (r3, 0)
    c772:	0411      	br      	0xc794	// c794 <GV_IPCM_SendsyncMessage+0xe8>
    c774:	e468100f 	subi      	r3, r8, 16
    c778:	9360      	ld.w      	r3, (r3, 0)
    c77a:	e4481007 	subi      	r2, r8, 8
    c77e:	9240      	ld.w      	r2, (r2, 0)
    c780:	3100      	movi      	r1, 0
    c782:	d4430881 	str.w      	r1, (r3, r2 << 2)
    c786:	e4681007 	subi      	r3, r8, 8
    c78a:	e4481007 	subi      	r2, r8, 8
    c78e:	9240      	ld.w      	r2, (r2, 0)
    c790:	2200      	addi      	r2, 1
    c792:	b340      	st.w      	r2, (r3, 0)
    c794:	e4681007 	subi      	r3, r8, 8
    c798:	9340      	ld.w      	r2, (r3, 0)
    c79a:	331f      	movi      	r3, 31
    c79c:	648c      	cmphs      	r3, r2
    c79e:	0beb      	bt      	0xc774	// c774 <GV_IPCM_SendsyncMessage+0xc8>
		timeout.tv_usec = 0;
    c7a0:	e468109f 	subi      	r3, r8, 160
    c7a4:	9360      	ld.w      	r3, (r3, 0)
    c7a6:	9360      	ld.w      	r3, (r3, 0)
    c7a8:	e9a30003 	bhsz      	r3, 0xc7ae	// c7ae <GV_IPCM_SendsyncMessage+0x102>
    c7ac:	231e      	addi      	r3, 31
    c7ae:	5365      	asri      	r3, r3, 5
    c7b0:	6c4f      	mov      	r1, r3
    c7b2:	e4681093 	subi      	r3, r8, 148
    c7b6:	d0230880 	ldr.w      	r0, (r3, r1 << 2)
    c7ba:	e468109f 	subi      	r3, r8, 160
    c7be:	9360      	ld.w      	r3, (r3, 0)
    c7c0:	9340      	ld.w      	r2, (r3, 0)
    c7c2:	c7c05023 	bmaski      	r3, 31
    c7c6:	2b1e      	subi      	r3, 31
    c7c8:	c4622043 	andn      	r3, r2, r3
    c7cc:	e9a30007 	bhsz      	r3, 0xc7da	// c7da <GV_IPCM_SendsyncMessage+0x12e>
    c7d0:	2b00      	subi      	r3, 1
    c7d2:	3200      	movi      	r2, 0
    c7d4:	2a1f      	subi      	r2, 32
    c7d6:	6cc8      	or      	r3, r2
    c7d8:	2300      	addi      	r3, 1
    c7da:	6c8f      	mov      	r2, r3
    c7dc:	3301      	movi      	r3, 1
    c7de:	70c8      	lsl      	r3, r2
    c7e0:	c4602422 	or      	r2, r0, r3
    c7e4:	e4681093 	subi      	r3, r8, 148
    c7e8:	d4230882 	str.w      	r2, (r3, r1 << 2)
		FD_ZERO(&rfds);
    c7ec:	e468109f 	subi      	r3, r8, 160
    c7f0:	9360      	ld.w      	r3, (r3, 0)
    c7f2:	9360      	ld.w      	r3, (r3, 0)
    c7f4:	5b02      	addi      	r0, r3, 1
    c7f6:	e4881003 	subi      	r4, r8, 4
    c7fa:	e4281093 	subi      	r1, r8, 148
    c7fe:	e468109b 	subi      	r3, r8, 156
    c802:	b860      	st.w      	r3, (sp, 0)
    c804:	3300      	movi      	r3, 0
    c806:	3200      	movi      	r2, 0
    c808:	eae00056 	jsri      	0x0	// from address pool at 0xc960
    c80c:	c4004820 	lsli      	r0, r0, 0
    c810:	b400      	st.w      	r0, (r4, 0)
		FD_SET(msg_pool->IpcmFd, &rfds);
		ret = select(msg_pool->IpcmFd + 1, &rfds, NULL, NULL, &timeout);
    c812:	e4681003 	subi      	r3, r8, 4
    c816:	9340      	ld.w      	r2, (r3, 0)
    c818:	3300      	movi      	r3, 0
    c81a:	2b00      	subi      	r3, 1
    c81c:	64ca      	cmpne      	r2, r3
    c81e:	0814      	bt      	0xc846	// c846 <GV_IPCM_SendsyncMessage+0x19a>

    c820:	ea020137 	movi      	r2, 311
    c824:	122a      	lrw      	r1, 0xe490	// c94c <GV_IPCM_SendsyncMessage+0x2a0>
    c826:	120b      	lrw      	r0, 0xe004	// c950 <GV_IPCM_SendsyncMessage+0x2a4>
    c828:	e3fff832 	bsr      	0xb88c	// b88c <pr>
    c82c:	c4004820 	lsli      	r0, r0, 0
    c830:	120d      	lrw      	r0, 0xe334	// c964 <GV_IPCM_SendsyncMessage+0x2b8>
    c832:	e3fff82d 	bsr      	0xb88c	// b88c <pr>
    c836:	c4004820 	lsli      	r0, r0, 0
    c83a:	1209      	lrw      	r0, 0xdfbc	// c95c <GV_IPCM_SendsyncMessage+0x2b0>
    c83c:	e3fff828 	bsr      	0xb88c	// b88c <pr>
    c840:	c4004820 	lsli      	r0, r0, 0
		if (-1 == ret) {
    c844:	04b5      	br      	0xc9ae	// c9ae <GV_IPCM_SendsyncMessage+0x302>
			ipcm_err("SELECT error");
    c846:	e4681003 	subi      	r3, r8, 4
    c84a:	9360      	ld.w      	r3, (r3, 0)
    c84c:	e9230028 	bnez      	r3, 0xc89c	// c89c <GV_IPCM_SendsyncMessage+0x1f0>
			break;
    c850:	e468109f 	subi      	r3, r8, 160
    c854:	9360      	ld.w      	r3, (r3, 0)
    c856:	9360      	ld.w      	r3, (r3, 0)
    c858:	3200      	movi      	r2, 0
    c85a:	1224      	lrw      	r1, 0x40044d03	// c968 <GV_IPCM_SendsyncMessage+0x2bc>
    c85c:	6c0f      	mov      	r0, r3
    c85e:	eae00044 	jsri      	0x0	// from address pool at 0xc96c
    c862:	c4004820 	lsli      	r0, r0, 0
    c866:	6cc3      	mov      	r3, r0
    c868:	3b42      	cmpnei      	r3, 2
    c86a:	0c19      	bf      	0xc89c	// c89c <GV_IPCM_SendsyncMessage+0x1f0>
		} else if (!ret) {
    c86c:	ea02013b 	movi      	r2, 315
    c870:	1137      	lrw      	r1, 0xe490	// c94c <GV_IPCM_SendsyncMessage+0x2a0>
    c872:	1118      	lrw      	r0, 0xe004	// c950 <GV_IPCM_SendsyncMessage+0x2a4>
    c874:	e3fff80c 	bsr      	0xb88c	// b88c <pr>
    c878:	c4004820 	lsli      	r0, r0, 0
    c87c:	111d      	lrw      	r0, 0xe3a8	// c970 <GV_IPCM_SendsyncMessage+0x2c4>
    c87e:	e3fff807 	bsr      	0xb88c	// b88c <pr>
    c882:	c4004820 	lsli      	r0, r0, 0
    c886:	1116      	lrw      	r0, 0xdfbc	// c95c <GV_IPCM_SendsyncMessage+0x2b0>
    c888:	e3fff802 	bsr      	0xb88c	// b88c <pr>
    c88c:	c4004820 	lsli      	r0, r0, 0
			if(HANDLE_CONNECTED != ioctl(msg_pool->IpcmFd, GV_IPCM_IOC_CHECK, NULL)) {
    c890:	e4481003 	subi      	r2, r8, 4
    c894:	3300      	movi      	r3, 0
    c896:	2b00      	subi      	r3, 1
    c898:	b260      	st.w      	r3, (r2, 0)
				ipcm_err("Disconnected by remote,exit.");				
    c89a:	048a      	br      	0xc9ae	// c9ae <GV_IPCM_SendsyncMessage+0x302>
				ret = -GV_FAILED;
				break;
			}
		}
    c89c:	e468109f 	subi      	r3, r8, 160
    c8a0:	9360      	ld.w      	r3, (r3, 0)
    c8a2:	9360      	ld.w      	r3, (r3, 0)
    c8a4:	e9a30003 	bhsz      	r3, 0xc8aa	// c8aa <GV_IPCM_SendsyncMessage+0x1fe>
    c8a8:	231e      	addi      	r3, 31
    c8aa:	5365      	asri      	r3, r3, 5
    c8ac:	6c8f      	mov      	r2, r3
    c8ae:	e4681093 	subi      	r3, r8, 148
    c8b2:	d0430881 	ldr.w      	r1, (r3, r2 << 2)
    c8b6:	e468109f 	subi      	r3, r8, 160
    c8ba:	9360      	ld.w      	r3, (r3, 0)
    c8bc:	9340      	ld.w      	r2, (r3, 0)
    c8be:	c7c05023 	bmaski      	r3, 31
    c8c2:	2b1e      	subi      	r3, 31
    c8c4:	c4622043 	andn      	r3, r2, r3
    c8c8:	e9a30007 	bhsz      	r3, 0xc8d6	// c8d6 <GV_IPCM_SendsyncMessage+0x22a>
    c8cc:	2b00      	subi      	r3, 1
    c8ce:	3200      	movi      	r2, 0
    c8d0:	2a1f      	subi      	r2, 32
    c8d2:	6cc8      	or      	r3, r2
    c8d4:	2300      	addi      	r3, 1
    c8d6:	6c8f      	mov      	r2, r3
    c8d8:	3301      	movi      	r3, 1
    c8da:	70c8      	lsl      	r3, r2
    c8dc:	68c4      	and      	r3, r1
    c8de:	e903ff39 	bez      	r3, 0xc750	// c750 <GV_IPCM_SendsyncMessage+0xa4>
		
    c8e2:	e468109f 	subi      	r3, r8, 160
    c8e6:	9360      	ld.w      	r3, (r3, 0)
    c8e8:	9300      	ld.w      	r0, (r3, 0)
    c8ea:	e46810a7 	subi      	r3, r8, 168
    c8ee:	9360      	ld.w      	r3, (r3, 0)
    c8f0:	9361      	ld.w      	r3, (r3, 0x4)
    c8f2:	e4881013 	subi      	r4, r8, 20
    c8f6:	ea0207e0 	movi      	r2, 2016
    c8fa:	6c4f      	mov      	r1, r3
    c8fc:	eae0001e 	jsri      	0x0	// from address pool at 0xc974
    c900:	c4004820 	lsli      	r0, r0, 0
    c904:	b400      	st.w      	r0, (r4, 0)
		if (FD_ISSET(msg_pool->IpcmFd, &rfds)) {
    c906:	e4681013 	subi      	r3, r8, 20
    c90a:	9360      	ld.w      	r3, (r3, 0)
    c90c:	e9a30038 	bhsz      	r3, 0xc97c	// c97c <GV_IPCM_SendsyncMessage+0x2d0>
			len = read(msg_pool->IpcmFd,(void *)pstMsgResp->msg_body,MAX_SEND_LEN);
    c910:	ea020144 	movi      	r2, 324
    c914:	102e      	lrw      	r1, 0xe490	// c94c <GV_IPCM_SendsyncMessage+0x2a0>
    c916:	100f      	lrw      	r0, 0xe004	// c950 <GV_IPCM_SendsyncMessage+0x2a4>
    c918:	e3fff7ba 	bsr      	0xb88c	// b88c <pr>
    c91c:	c4004820 	lsli      	r0, r0, 0
    c920:	e4681003 	subi      	r3, r8, 4
    c924:	9320      	ld.w      	r1, (r3, 0)
    c926:	1015      	lrw      	r0, 0xe360	// c978 <GV_IPCM_SendsyncMessage+0x2cc>
    c928:	e3fff7b2 	bsr      	0xb88c	// b88c <pr>
    c92c:	c4004820 	lsli      	r0, r0, 0
    c930:	100b      	lrw      	r0, 0xdfbc	// c95c <GV_IPCM_SendsyncMessage+0x2b0>
    c932:	e3fff7ad 	bsr      	0xb88c	// b88c <pr>
    c936:	c4004820 	lsli      	r0, r0, 0
			if(len < 0) {
    c93a:	e4481003 	subi      	r2, r8, 4
    c93e:	3300      	movi      	r3, 0
    c940:	2b00      	subi      	r3, 1
    c942:	b260      	st.w      	r3, (r2, 0)
				ipcm_err("read error %d.",ret);
    c944:	0435      	br      	0xc9ae	// c9ae <GV_IPCM_SendsyncMessage+0x302>
    c946:	0000      	.short	0x0000
    c948:	00000000 	.long	0x00000000
    c94c:	0000e490 	.long	0x0000e490
    c950:	0000e004 	.long	0x0000e004
    c954:	0000b88c 	.long	0x0000b88c
    c958:	0000e388 	.long	0x0000e388
    c95c:	0000dfbc 	.long	0x0000dfbc
    c960:	00000000 	.long	0x00000000
    c964:	0000e334 	.long	0x0000e334
    c968:	40044d03 	.long	0x40044d03
    c96c:	00000000 	.long	0x00000000
    c970:	0000e3a8 	.long	0x0000e3a8
    c974:	00000000 	.long	0x00000000
    c978:	0000e360 	.long	0x0000e360
				ret = -GV_FAILED;
				break;
			}
    c97c:	ea020149 	movi      	r2, 329
    c980:	1032      	lrw      	r1, 0xe490	// c9c8 <GV_IPCM_SendsyncMessage+0x31c>
    c982:	1013      	lrw      	r0, 0xdf84	// c9cc <GV_IPCM_SendsyncMessage+0x320>
    c984:	e3fff784 	bsr      	0xb88c	// b88c <pr>
    c988:	c4004820 	lsli      	r0, r0, 0
    c98c:	e4681013 	subi      	r3, r8, 20
    c990:	9320      	ld.w      	r1, (r3, 0)
    c992:	1011      	lrw      	r0, 0xe3c8	// c9d4 <GV_IPCM_SendsyncMessage+0x328>
    c994:	e3fff77c 	bsr      	0xb88c	// b88c <pr>
    c998:	c4004820 	lsli      	r0, r0, 0
    c99c:	100f      	lrw      	r0, 0xdfbc	// c9d8 <GV_IPCM_SendsyncMessage+0x32c>
    c99e:	e3fff777 	bsr      	0xb88c	// b88c <pr>
    c9a2:	c4004820 	lsli      	r0, r0, 0
			/*read complete!*/
    c9a6:	e4681003 	subi      	r3, r8, 4
    c9aa:	3200      	movi      	r2, 0
    c9ac:	b340      	st.w      	r2, (r3, 0)
			ipcm_trace(TRACE_ZXF_DEBUG,"read sync message length %d.",len);
			ret = GV_SUCCESS;
			break;
		}
	}
    c9ae:	e4681003 	subi      	r3, r8, 4
    c9b2:	9360      	ld.w      	r3, (r3, 0)
	
    c9b4:	6c0f      	mov      	r0, r3
    c9b6:	6fa3      	mov      	sp, r8
    c9b8:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    c9bc:	d90e2001 	ld.w      	r8, (sp, 0x4)
    c9c0:	9880      	ld.w      	r4, (sp, 0)
    c9c2:	1403      	addi      	sp, sp, 12
    c9c4:	783c      	rts
    c9c6:	0000      	.short	0x0000
    c9c8:	0000e490 	.long	0x0000e490
    c9cc:	0000df84 	.long	0x0000df84
    c9d0:	0000b88c 	.long	0x0000b88c
    c9d4:	0000e3c8 	.long	0x0000e3c8
    c9d8:	0000dfbc 	.long	0x0000dfbc

0000c9dc <GV_IPCM_CheckConnected>:
	return ret;
}

/*
 * Check handle is connected or not
 */
    c9dc:	1423      	subi      	sp, sp, 12
    c9de:	b880      	st.w      	r4, (sp, 0)
    c9e0:	dd0e2001 	st.w      	r8, (sp, 0x4)
    c9e4:	ddee2002 	st.w      	r15, (sp, 0x8)
    c9e8:	6e3b      	mov      	r8, sp
    c9ea:	1422      	subi      	sp, sp, 8
    c9ec:	e4681007 	subi      	r3, r8, 8
    c9f0:	b300      	st.w      	r0, (r3, 0)
GV_BOOL GV_IPCM_CheckConnected(GV_IPCM_MSG_POOL_S *msg_pool)
{	
    c9f2:	e4681007 	subi      	r3, r8, 8
    c9f6:	9360      	ld.w      	r3, (r3, 0)
    c9f8:	9360      	ld.w      	r3, (r3, 0)
    c9fa:	e923001b 	bnez      	r3, 0xca30	// ca30 <GV_IPCM_CheckConnected+0x54>

	if(!msg_pool->IpcmFd)
    c9fe:	ea02015a 	movi      	r2, 346
    ca02:	103e      	lrw      	r1, 0xe4a8	// ca78 <GV_IPCM_CheckConnected+0x9c>
    ca04:	101e      	lrw      	r0, 0xe004	// ca7c <GV_IPCM_CheckConnected+0xa0>
    ca06:	e3fff743 	bsr      	0xb88c	// b88c <pr>
    ca0a:	c4004820 	lsli      	r0, r0, 0
    ca0e:	e4681007 	subi      	r3, r8, 8
    ca12:	9360      	ld.w      	r3, (r3, 0)
    ca14:	9360      	ld.w      	r3, (r3, 0)
    ca16:	6c4f      	mov      	r1, r3
    ca18:	101b      	lrw      	r0, 0xe3e8	// ca84 <GV_IPCM_CheckConnected+0xa8>
    ca1a:	e3fff739 	bsr      	0xb88c	// b88c <pr>
    ca1e:	c4004820 	lsli      	r0, r0, 0
    ca22:	101a      	lrw      	r0, 0xdfbc	// ca88 <GV_IPCM_CheckConnected+0xac>
    ca24:	e3fff734 	bsr      	0xb88c	// b88c <pr>
    ca28:	c4004820 	lsli      	r0, r0, 0
	{
    ca2c:	3300      	movi      	r3, 0
    ca2e:	041b      	br      	0xca64	// ca64 <GV_IPCM_CheckConnected+0x88>
		ipcm_err("file desc error %d.",msg_pool->IpcmFd);
		return GV_FALSE;
	}
    ca30:	e4681003 	subi      	r3, r8, 4
    ca34:	3200      	movi      	r2, 0
    ca36:	b340      	st.w      	r2, (r3, 0)

    ca38:	e4681007 	subi      	r3, r8, 8
    ca3c:	9360      	ld.w      	r3, (r3, 0)
    ca3e:	9360      	ld.w      	r3, (r3, 0)
    ca40:	e4881003 	subi      	r4, r8, 4
    ca44:	3200      	movi      	r2, 0
    ca46:	1032      	lrw      	r1, 0x40044d03	// ca8c <GV_IPCM_CheckConnected+0xb0>
    ca48:	6c0f      	mov      	r0, r3
    ca4a:	eae00012 	jsri      	0x0	// from address pool at 0xca90
    ca4e:	c4004820 	lsli      	r0, r0, 0
    ca52:	b400      	st.w      	r0, (r4, 0)
	int state = HANDLE_DISCONNECTED;
	state =	ioctl(msg_pool->IpcmFd,GV_IPCM_IOC_CHECK,NULL);
    ca54:	e4681003 	subi      	r3, r8, 4
    ca58:	9360      	ld.w      	r3, (r3, 0)
    ca5a:	3b42      	cmpnei      	r3, 2
    ca5c:	0803      	bt      	0xca62	// ca62 <GV_IPCM_CheckConnected+0x86>
	
    ca5e:	3301      	movi      	r3, 1
    ca60:	0402      	br      	0xca64	// ca64 <GV_IPCM_CheckConnected+0x88>
	if(HANDLE_CONNECTED == state)
		return GV_TRUE;
    ca62:	3300      	movi      	r3, 0
	else 
		return GV_FALSE;
    ca64:	6c0f      	mov      	r0, r3
    ca66:	6fa3      	mov      	sp, r8
    ca68:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    ca6c:	d90e2001 	ld.w      	r8, (sp, 0x4)
    ca70:	9880      	ld.w      	r4, (sp, 0)
    ca72:	1403      	addi      	sp, sp, 12
    ca74:	783c      	rts
    ca76:	0000      	.short	0x0000
    ca78:	0000e4a8 	.long	0x0000e4a8
    ca7c:	0000e004 	.long	0x0000e004
    ca80:	0000b88c 	.long	0x0000b88c
    ca84:	0000e3e8 	.long	0x0000e3e8
    ca88:	0000dfbc 	.long	0x0000dfbc
    ca8c:	40044d03 	.long	0x40044d03
    ca90:	00000000 	.long	0x00000000

0000ca94 <pr_debug>:

#ifdef DEBUG
#define pr_debug printf
#else
static inline void pr_debug(const char *fmt, ...)
{
    ca94:	1424      	subi      	sp, sp, 16
    ca96:	b863      	st.w      	r3, (sp, 0xc)
    ca98:	b842      	st.w      	r2, (sp, 0x8)
    ca9a:	b821      	st.w      	r1, (sp, 0x4)
    ca9c:	b800      	st.w      	r0, (sp, 0)
    ca9e:	1421      	subi      	sp, sp, 4
    caa0:	dd0e2000 	st.w      	r8, (sp, 0)
    caa4:	6e3b      	mov      	r8, sp
	(void)fmt;
}
    caa6:	6c00      	or      	r0, r0
    caa8:	6fa3      	mov      	sp, r8
    caaa:	d90e2000 	ld.w      	r8, (sp, 0)
    caae:	1405      	addi      	sp, sp, 20
    cab0:	783c      	rts
	...

0000cab4 <kzalloc>:
#endif

static void *kzalloc(size_t sz, int flags)
{
    cab4:	1422      	subi      	sp, sp, 8
    cab6:	dd0e2000 	st.w      	r8, (sp, 0)
    caba:	ddee2001 	st.w      	r15, (sp, 0x4)
    cabe:	6e3b      	mov      	r8, sp
    cac0:	1422      	subi      	sp, sp, 8
    cac2:	e4681003 	subi      	r3, r8, 4
    cac6:	b300      	st.w      	r0, (r3, 0)
    cac8:	e4681007 	subi      	r3, r8, 8
    cacc:	b320      	st.w      	r1, (r3, 0)
	(void)flags;
	return calloc(1, sz);
    cace:	e4681003 	subi      	r3, r8, 4
    cad2:	9320      	ld.w      	r1, (r3, 0)
    cad4:	3001      	movi      	r0, 1
    cad6:	eae00063 	jsri      	0x0	// from address pool at 0xcc60
    cada:	c4004820 	lsli      	r0, r0, 0
    cade:	6cc3      	mov      	r3, r0
}
    cae0:	6c0f      	mov      	r0, r3
    cae2:	6fa3      	mov      	sp, r8
    cae4:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    cae8:	d90e2000 	ld.w      	r8, (sp, 0)
    caec:	1402      	addi      	sp, sp, 8
    caee:	783c      	rts

0000caf0 <kfree>:

static void kfree(void *p)
{
    caf0:	1422      	subi      	sp, sp, 8
    caf2:	dd0e2000 	st.w      	r8, (sp, 0)
    caf6:	ddee2001 	st.w      	r15, (sp, 0x4)
    cafa:	6e3b      	mov      	r8, sp
    cafc:	1421      	subi      	sp, sp, 4
    cafe:	e4681003 	subi      	r3, r8, 4
    cb02:	b300      	st.w      	r0, (r3, 0)
	free(p);
    cb04:	e4681003 	subi      	r3, r8, 4
    cb08:	9300      	ld.w      	r0, (r3, 0)
    cb0a:	eae00057 	jsri      	0x0	// from address pool at 0xcc64
    cb0e:	c4004820 	lsli      	r0, r0, 0
}
    cb12:	6c00      	or      	r0, r0
    cb14:	6fa3      	mov      	sp, r8
    cb16:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    cb1a:	d90e2000 	ld.w      	r8, (sp, 0)
    cb1e:	1402      	addi      	sp, sp, 8
    cb20:	783c      	rts
	...

0000cb24 <xrp_pool_lock>:

static void xrp_pool_lock(struct xrp_allocation_pool *pool)
{
    cb24:	1421      	subi      	sp, sp, 4
    cb26:	dd0e2000 	st.w      	r8, (sp, 0)
    cb2a:	6e3b      	mov      	r8, sp
    cb2c:	1421      	subi      	sp, sp, 4
    cb2e:	e4681003 	subi      	r3, r8, 4
    cb32:	b300      	st.w      	r0, (r3, 0)
	//pthread_mutex_lock(pool->pool_mutex);

}
    cb34:	6c00      	or      	r0, r0
    cb36:	6fa3      	mov      	sp, r8
    cb38:	d90e2000 	ld.w      	r8, (sp, 0)
    cb3c:	1401      	addi      	sp, sp, 4
    cb3e:	783c      	rts

0000cb40 <xrp_pool_unlock>:

static void xrp_pool_unlock(struct xrp_allocation_pool *pool)
{
    cb40:	1421      	subi      	sp, sp, 4
    cb42:	dd0e2000 	st.w      	r8, (sp, 0)
    cb46:	6e3b      	mov      	r8, sp
    cb48:	1421      	subi      	sp, sp, 4
    cb4a:	e4681003 	subi      	r3, r8, 4
    cb4e:	b300      	st.w      	r0, (r3, 0)
	//pthread_mutex_unlock(pool->pool_mutex);	
}
    cb50:	6c00      	or      	r0, r0
    cb52:	6fa3      	mov      	sp, r8
    cb54:	d90e2000 	ld.w      	r8, (sp, 0)
    cb58:	1401      	addi      	sp, sp, 4
    cb5a:	783c      	rts

0000cb5c <xrp_allocation_get>:

static void xrp_allocation_get(struct xrp_allocation *allocation)
{
    cb5c:	1421      	subi      	sp, sp, 4
    cb5e:	dd0e2000 	st.w      	r8, (sp, 0)
    cb62:	6e3b      	mov      	r8, sp
    cb64:	1421      	subi      	sp, sp, 4
    cb66:	e4681003 	subi      	r3, r8, 4
    cb6a:	b300      	st.w      	r0, (r3, 0)
}
    cb6c:	6c00      	or      	r0, r0
    cb6e:	6fa3      	mov      	sp, r8
    cb70:	d90e2000 	ld.w      	r8, (sp, 0)
    cb74:	1401      	addi      	sp, sp, 4
    cb76:	783c      	rts

0000cb78 <atomic_set>:

static void atomic_set(atomic_t *p, uint32_t v)
{
    cb78:	1421      	subi      	sp, sp, 4
    cb7a:	dd0e2000 	st.w      	r8, (sp, 0)
    cb7e:	6e3b      	mov      	r8, sp
    cb80:	1422      	subi      	sp, sp, 8
    cb82:	e4681003 	subi      	r3, r8, 4
    cb86:	b300      	st.w      	r0, (r3, 0)
    cb88:	e4681007 	subi      	r3, r8, 8
    cb8c:	b320      	st.w      	r1, (r3, 0)
	*((volatile atomic_t *)p) = v;
    cb8e:	e4681003 	subi      	r3, r8, 4
    cb92:	9360      	ld.w      	r3, (r3, 0)
    cb94:	e4481007 	subi      	r2, r8, 8
    cb98:	9240      	ld.w      	r2, (r2, 0)
    cb9a:	b340      	st.w      	r2, (r3, 0)
}
    cb9c:	6c00      	or      	r0, r0
    cb9e:	6fa3      	mov      	sp, r8
    cba0:	d90e2000 	ld.w      	r8, (sp, 0)
    cba4:	1401      	addi      	sp, sp, 4
    cba6:	783c      	rts

0000cba8 <xrp_init_pool>:
* 		start - [in] 内存池的起始地址,输入物理地址,起始地址的确定?
*       size  - [in] 内存池的大小,size的确定?
* 返回值： 0 success
*/
long xrp_init_pool(struct xrp_allocation_pool *pool,phys_addr_t start, u32 size)
{
    cba8:	1423      	subi      	sp, sp, 12
    cbaa:	b880      	st.w      	r4, (sp, 0)
    cbac:	dd0e2001 	st.w      	r8, (sp, 0x4)
    cbb0:	ddee2002 	st.w      	r15, (sp, 0x8)
    cbb4:	6e3b      	mov      	r8, sp
    cbb6:	1424      	subi      	sp, sp, 16
    cbb8:	e4681007 	subi      	r3, r8, 8
    cbbc:	b300      	st.w      	r0, (r3, 0)
    cbbe:	e468100b 	subi      	r3, r8, 12
    cbc2:	b320      	st.w      	r1, (r3, 0)
    cbc4:	e468100f 	subi      	r3, r8, 16
    cbc8:	b340      	st.w      	r2, (r3, 0)
	struct xrp_allocation *allocation = malloc(sizeof(*allocation));
    cbca:	e4881003 	subi      	r4, r8, 4
    cbce:	3014      	movi      	r0, 20
    cbd0:	eae00026 	jsri      	0x0	// from address pool at 0xcc68
    cbd4:	c4004820 	lsli      	r0, r0, 0
    cbd8:	6cc3      	mov      	r3, r0
    cbda:	b460      	st.w      	r3, (r4, 0)

	*allocation = (struct xrp_allocation)
    cbdc:	e4681003 	subi      	r3, r8, 4
    cbe0:	9360      	ld.w      	r3, (r3, 0)
    cbe2:	3200      	movi      	r2, 0
    cbe4:	b340      	st.w      	r2, (r3, 0)
    cbe6:	3200      	movi      	r2, 0
    cbe8:	b341      	st.w      	r2, (r3, 0x4)
    cbea:	3200      	movi      	r2, 0
    cbec:	b342      	st.w      	r2, (r3, 0x8)
    cbee:	3200      	movi      	r2, 0
    cbf0:	b343      	st.w      	r2, (r3, 0xc)
    cbf2:	3200      	movi      	r2, 0
    cbf4:	b344      	st.w      	r2, (r3, 0x10)
    cbf6:	e4681003 	subi      	r3, r8, 4
    cbfa:	9360      	ld.w      	r3, (r3, 0)
    cbfc:	e448100b 	subi      	r2, r8, 12
    cc00:	9240      	ld.w      	r2, (r2, 0)
    cc02:	b340      	st.w      	r2, (r3, 0)
    cc04:	e4681003 	subi      	r3, r8, 4
    cc08:	9360      	ld.w      	r3, (r3, 0)
    cc0a:	e448100f 	subi      	r2, r8, 16
    cc0e:	9240      	ld.w      	r2, (r2, 0)
    cc10:	b341      	st.w      	r2, (r3, 0x4)
    cc12:	e4681003 	subi      	r3, r8, 4
    cc16:	9360      	ld.w      	r3, (r3, 0)
    cc18:	e4481007 	subi      	r2, r8, 8
    cc1c:	9240      	ld.w      	r2, (r2, 0)
    cc1e:	b344      	st.w      	r2, (r3, 0x10)
	{
		.start = start,
		.size = size,
		.pool = pool,
	};
	*pool = (struct xrp_allocation_pool)
    cc20:	e4681007 	subi      	r3, r8, 8
    cc24:	9360      	ld.w      	r3, (r3, 0)
    cc26:	e448100b 	subi      	r2, r8, 12
    cc2a:	9240      	ld.w      	r2, (r2, 0)
    cc2c:	b340      	st.w      	r2, (r3, 0)
    cc2e:	e4681007 	subi      	r3, r8, 8
    cc32:	9360      	ld.w      	r3, (r3, 0)
    cc34:	e448100f 	subi      	r2, r8, 16
    cc38:	9240      	ld.w      	r2, (r2, 0)
    cc3a:	b341      	st.w      	r2, (r3, 0x4)
    cc3c:	e4681007 	subi      	r3, r8, 8
    cc40:	9360      	ld.w      	r3, (r3, 0)
    cc42:	e4481003 	subi      	r2, r8, 4
    cc46:	9240      	ld.w      	r2, (r2, 0)
    cc48:	b342      	st.w      	r2, (r3, 0x8)
	{
		.start = start,
		.size = size,
		.free_list = allocation,
	};
	return 0;
    cc4a:	3300      	movi      	r3, 0
}
    cc4c:	6c0f      	mov      	r0, r3
    cc4e:	6fa3      	mov      	sp, r8
    cc50:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    cc54:	d90e2001 	ld.w      	r8, (sp, 0x4)
    cc58:	9880      	ld.w      	r4, (sp, 0)
    cc5a:	1403      	addi      	sp, sp, 12
    cc5c:	783c      	rts
	...

0000cc6c <xrp_free>:

void xrp_free(struct xrp_allocation *xrp_allocation)
{
    cc6c:	1422      	subi      	sp, sp, 8
    cc6e:	dd0e2000 	st.w      	r8, (sp, 0)
    cc72:	ddee2001 	st.w      	r15, (sp, 0x4)
    cc76:	6e3b      	mov      	r8, sp
    cc78:	1425      	subi      	sp, sp, 20
    cc7a:	e4681013 	subi      	r3, r8, 20
    cc7e:	b300      	st.w      	r0, (r3, 0)
	struct xrp_allocation_pool *pool = xrp_allocation->pool;
    cc80:	e4681007 	subi      	r3, r8, 8
    cc84:	e4481013 	subi      	r2, r8, 20
    cc88:	9240      	ld.w      	r2, (r2, 0)
    cc8a:	9244      	ld.w      	r2, (r2, 0x10)
    cc8c:	b340      	st.w      	r2, (r3, 0)
	struct xrp_allocation **pcur;

	pr_debug("%s: %pap x %d\n", __func__,
    cc8e:	e4681013 	subi      	r3, r8, 20
    cc92:	9340      	ld.w      	r2, (r3, 0)
    cc94:	e4681013 	subi      	r3, r8, 20
    cc98:	9360      	ld.w      	r3, (r3, 0)
    cc9a:	9361      	ld.w      	r3, (r3, 0x4)
    cc9c:	ea810086 	lrw      	r1, 0xe670	// ceb4 <xrp_free+0x248>
    cca0:	ea800086 	lrw      	r0, 0xe4c0	// ceb8 <xrp_free+0x24c>
    cca4:	e3fffef8 	bsr      	0xca94	// ca94 <pr_debug>
    cca8:	c4004820 	lsli      	r0, r0, 0
		 &xrp_allocation->start, xrp_allocation->size);

	xrp_pool_lock(pool);
    ccac:	e4681007 	subi      	r3, r8, 8
    ccb0:	9300      	ld.w      	r0, (r3, 0)
    ccb2:	e3ffff39 	bsr      	0xcb24	// cb24 <xrp_pool_lock>
    ccb6:	c4004820 	lsli      	r0, r0, 0
	
	for (pcur = &pool->free_list; ; pcur = &(*pcur)->next) {
    ccba:	e4681003 	subi      	r3, r8, 4
    ccbe:	e4481007 	subi      	r2, r8, 8
    ccc2:	9240      	ld.w      	r2, (r2, 0)
    ccc4:	2207      	addi      	r2, 8
    ccc6:	b340      	st.w      	r2, (r3, 0)
		struct xrp_allocation *cur = *pcur;
    ccc8:	e468100b 	subi      	r3, r8, 12
    cccc:	e4481003 	subi      	r2, r8, 4
    ccd0:	9240      	ld.w      	r2, (r2, 0)
    ccd2:	9240      	ld.w      	r2, (r2, 0)
    ccd4:	b340      	st.w      	r2, (r3, 0)

		/*如果当前内存申请指针*/
		if (cur && cur->start + cur->size == xrp_allocation->start) {
    ccd6:	e468100b 	subi      	r3, r8, 12
    ccda:	9360      	ld.w      	r3, (r3, 0)
    ccdc:	e9030091 	bez      	r3, 0xcdfe	// cdfe <xrp_free+0x192>
    cce0:	e468100b 	subi      	r3, r8, 12
    cce4:	9360      	ld.w      	r3, (r3, 0)
    cce6:	9340      	ld.w      	r2, (r3, 0)
    cce8:	e468100b 	subi      	r3, r8, 12
    ccec:	9360      	ld.w      	r3, (r3, 0)
    ccee:	9361      	ld.w      	r3, (r3, 0x4)
    ccf0:	608c      	addu      	r2, r3
    ccf2:	e4681013 	subi      	r3, r8, 20
    ccf6:	9360      	ld.w      	r3, (r3, 0)
    ccf8:	9360      	ld.w      	r3, (r3, 0)
    ccfa:	64ca      	cmpne      	r2, r3
    ccfc:	0881      	bt      	0xcdfe	// cdfe <xrp_free+0x192>
			struct xrp_allocation *next = cur->next;
    ccfe:	e468100f 	subi      	r3, r8, 16
    cd02:	e448100b 	subi      	r2, r8, 12
    cd06:	9240      	ld.w      	r2, (r2, 0)
    cd08:	9243      	ld.w      	r2, (r2, 0xc)
    cd0a:	b340      	st.w      	r2, (r3, 0)

			pr_debug("merging block tail: %pap x 0x%x ->\n",
    cd0c:	e468100b 	subi      	r3, r8, 12
    cd10:	9320      	ld.w      	r1, (r3, 0)
    cd12:	e468100b 	subi      	r3, r8, 12
    cd16:	9360      	ld.w      	r3, (r3, 0)
    cd18:	9361      	ld.w      	r3, (r3, 0x4)
    cd1a:	6c8f      	mov      	r2, r3
    cd1c:	130a      	lrw      	r0, 0xe4d0	// cec4 <xrp_free+0x258>
    cd1e:	e3fffebb 	bsr      	0xca94	// ca94 <pr_debug>
    cd22:	c4004820 	lsli      	r0, r0, 0
				 &cur->start, cur->size);
			cur->size += xrp_allocation->size;
    cd26:	e468100b 	subi      	r3, r8, 12
    cd2a:	9360      	ld.w      	r3, (r3, 0)
    cd2c:	9341      	ld.w      	r2, (r3, 0x4)
    cd2e:	e4681013 	subi      	r3, r8, 20
    cd32:	9360      	ld.w      	r3, (r3, 0)
    cd34:	9361      	ld.w      	r3, (r3, 0x4)
    cd36:	608c      	addu      	r2, r3
    cd38:	e468100b 	subi      	r3, r8, 12
    cd3c:	9360      	ld.w      	r3, (r3, 0)
    cd3e:	b341      	st.w      	r2, (r3, 0x4)
			pr_debug("... -> %pap x 0x%x\n",
    cd40:	e468100b 	subi      	r3, r8, 12
    cd44:	9320      	ld.w      	r1, (r3, 0)
    cd46:	e468100b 	subi      	r3, r8, 12
    cd4a:	9360      	ld.w      	r3, (r3, 0)
    cd4c:	9361      	ld.w      	r3, (r3, 0x4)
    cd4e:	6c8f      	mov      	r2, r3
    cd50:	121e      	lrw      	r0, 0xe4f4	// cec8 <xrp_free+0x25c>
    cd52:	e3fffea1 	bsr      	0xca94	// ca94 <pr_debug>
    cd56:	c4004820 	lsli      	r0, r0, 0
				 &cur->start, cur->size);
			kfree(xrp_allocation);
    cd5a:	e4681013 	subi      	r3, r8, 20
    cd5e:	9300      	ld.w      	r0, (r3, 0)
    cd60:	e3fffec8 	bsr      	0xcaf0	// caf0 <kfree>
    cd64:	c4004820 	lsli      	r0, r0, 0

			if (next && cur->start + cur->size == next->start) {
    cd68:	e468100f 	subi      	r3, r8, 16
    cd6c:	9360      	ld.w      	r3, (r3, 0)
    cd6e:	e90300d2 	bez      	r3, 0xcf12	// cf12 <xrp_free+0x2a6>
    cd72:	e468100b 	subi      	r3, r8, 12
    cd76:	9360      	ld.w      	r3, (r3, 0)
    cd78:	9340      	ld.w      	r2, (r3, 0)
    cd7a:	e468100b 	subi      	r3, r8, 12
    cd7e:	9360      	ld.w      	r3, (r3, 0)
    cd80:	9361      	ld.w      	r3, (r3, 0x4)
    cd82:	608c      	addu      	r2, r3
    cd84:	e468100f 	subi      	r3, r8, 16
    cd88:	9360      	ld.w      	r3, (r3, 0)
    cd8a:	9360      	ld.w      	r3, (r3, 0)
    cd8c:	64ca      	cmpne      	r2, r3
    cd8e:	08c2      	bt      	0xcf12	// cf12 <xrp_free+0x2a6>
				pr_debug("merging with next block: %pap x 0x%x ->\n",
    cd90:	e468100b 	subi      	r3, r8, 12
    cd94:	9320      	ld.w      	r1, (r3, 0)
    cd96:	e468100b 	subi      	r3, r8, 12
    cd9a:	9360      	ld.w      	r3, (r3, 0)
    cd9c:	9361      	ld.w      	r3, (r3, 0x4)
    cd9e:	6c8f      	mov      	r2, r3
    cda0:	120c      	lrw      	r0, 0xe508	// ced0 <xrp_free+0x264>
    cda2:	e3fffe79 	bsr      	0xca94	// ca94 <pr_debug>
    cda6:	c4004820 	lsli      	r0, r0, 0
					 &cur->start, cur->size);
				cur->size += next->size;
    cdaa:	e468100b 	subi      	r3, r8, 12
    cdae:	9360      	ld.w      	r3, (r3, 0)
    cdb0:	9341      	ld.w      	r2, (r3, 0x4)
    cdb2:	e468100f 	subi      	r3, r8, 16
    cdb6:	9360      	ld.w      	r3, (r3, 0)
    cdb8:	9361      	ld.w      	r3, (r3, 0x4)
    cdba:	608c      	addu      	r2, r3
    cdbc:	e468100b 	subi      	r3, r8, 12
    cdc0:	9360      	ld.w      	r3, (r3, 0)
    cdc2:	b341      	st.w      	r2, (r3, 0x4)
				cur->next = next->next;
    cdc4:	e468100f 	subi      	r3, r8, 16
    cdc8:	9360      	ld.w      	r3, (r3, 0)
    cdca:	9343      	ld.w      	r2, (r3, 0xc)
    cdcc:	e468100b 	subi      	r3, r8, 12
    cdd0:	9360      	ld.w      	r3, (r3, 0)
    cdd2:	b343      	st.w      	r2, (r3, 0xc)
				pr_debug("... -> %pap x 0x%x\n",
    cdd4:	e468100b 	subi      	r3, r8, 12
    cdd8:	9320      	ld.w      	r1, (r3, 0)
    cdda:	e468100b 	subi      	r3, r8, 12
    cdde:	9360      	ld.w      	r3, (r3, 0)
    cde0:	9361      	ld.w      	r3, (r3, 0x4)
    cde2:	6c8f      	mov      	r2, r3
    cde4:	1119      	lrw      	r0, 0xe4f4	// cec8 <xrp_free+0x25c>
    cde6:	e3fffe57 	bsr      	0xca94	// ca94 <pr_debug>
    cdea:	c4004820 	lsli      	r0, r0, 0
					 &cur->start, cur->size);
				kfree(next);
    cdee:	e468100f 	subi      	r3, r8, 16
    cdf2:	9300      	ld.w      	r0, (r3, 0)
    cdf4:	e3fffe7e 	bsr      	0xcaf0	// caf0 <kfree>
    cdf8:	c4004820 	lsli      	r0, r0, 0
			}
			break;
    cdfc:	048b      	br      	0xcf12	// cf12 <xrp_free+0x2a6>
		}

		if (!cur || xrp_allocation->start < cur->start) {
    cdfe:	e468100b 	subi      	r3, r8, 12
    ce02:	9360      	ld.w      	r3, (r3, 0)
    ce04:	e903000c 	bez      	r3, 0xce1c	// ce1c <xrp_free+0x1b0>
    ce08:	e4681013 	subi      	r3, r8, 20
    ce0c:	9360      	ld.w      	r3, (r3, 0)
    ce0e:	9340      	ld.w      	r2, (r3, 0)
    ce10:	e468100b 	subi      	r3, r8, 12
    ce14:	9360      	ld.w      	r3, (r3, 0)
    ce16:	9360      	ld.w      	r3, (r3, 0)
    ce18:	64c8      	cmphs      	r2, r3
    ce1a:	0873      	bt      	0xcf00	// cf00 <xrp_free+0x294>
			if (cur && xrp_allocation->start + xrp_allocation->size == cur->start) {
    ce1c:	e468100b 	subi      	r3, r8, 12
    ce20:	9360      	ld.w      	r3, (r3, 0)
    ce22:	e903005b 	bez      	r3, 0xced8	// ced8 <xrp_free+0x26c>
    ce26:	e4681013 	subi      	r3, r8, 20
    ce2a:	9360      	ld.w      	r3, (r3, 0)
    ce2c:	9340      	ld.w      	r2, (r3, 0)
    ce2e:	e4681013 	subi      	r3, r8, 20
    ce32:	9360      	ld.w      	r3, (r3, 0)
    ce34:	9361      	ld.w      	r3, (r3, 0x4)
    ce36:	608c      	addu      	r2, r3
    ce38:	e468100b 	subi      	r3, r8, 12
    ce3c:	9360      	ld.w      	r3, (r3, 0)
    ce3e:	9360      	ld.w      	r3, (r3, 0)
    ce40:	64ca      	cmpne      	r2, r3
    ce42:	084b      	bt      	0xced8	// ced8 <xrp_free+0x26c>
				pr_debug("merging block head: %pap x 0x%x ->\n",
    ce44:	e468100b 	subi      	r3, r8, 12
    ce48:	9320      	ld.w      	r1, (r3, 0)
    ce4a:	e468100b 	subi      	r3, r8, 12
    ce4e:	9360      	ld.w      	r3, (r3, 0)
    ce50:	9361      	ld.w      	r3, (r3, 0x4)
    ce52:	6c8f      	mov      	r2, r3
    ce54:	1100      	lrw      	r0, 0xe534	// ced4 <xrp_free+0x268>
    ce56:	e3fffe1f 	bsr      	0xca94	// ca94 <pr_debug>
    ce5a:	c4004820 	lsli      	r0, r0, 0
					 &cur->start, cur->size);
				cur->size += xrp_allocation->size;
    ce5e:	e468100b 	subi      	r3, r8, 12
    ce62:	9360      	ld.w      	r3, (r3, 0)
    ce64:	9341      	ld.w      	r2, (r3, 0x4)
    ce66:	e4681013 	subi      	r3, r8, 20
    ce6a:	9360      	ld.w      	r3, (r3, 0)
    ce6c:	9361      	ld.w      	r3, (r3, 0x4)
    ce6e:	608c      	addu      	r2, r3
    ce70:	e468100b 	subi      	r3, r8, 12
    ce74:	9360      	ld.w      	r3, (r3, 0)
    ce76:	b341      	st.w      	r2, (r3, 0x4)
				cur->start = xrp_allocation->start;
    ce78:	e4681013 	subi      	r3, r8, 20
    ce7c:	9360      	ld.w      	r3, (r3, 0)
    ce7e:	9340      	ld.w      	r2, (r3, 0)
    ce80:	e468100b 	subi      	r3, r8, 12
    ce84:	9360      	ld.w      	r3, (r3, 0)
    ce86:	b340      	st.w      	r2, (r3, 0)
				pr_debug("... -> %pap x 0x%x\n",
    ce88:	e468100b 	subi      	r3, r8, 12
    ce8c:	9320      	ld.w      	r1, (r3, 0)
    ce8e:	e468100b 	subi      	r3, r8, 12
    ce92:	9360      	ld.w      	r3, (r3, 0)
    ce94:	9361      	ld.w      	r3, (r3, 0x4)
    ce96:	6c8f      	mov      	r2, r3
    ce98:	100c      	lrw      	r0, 0xe4f4	// cec8 <xrp_free+0x25c>
    ce9a:	e3fffdfd 	bsr      	0xca94	// ca94 <pr_debug>
    ce9e:	c4004820 	lsli      	r0, r0, 0
					 &cur->start, cur->size);
				kfree(xrp_allocation);
    cea2:	e4681013 	subi      	r3, r8, 20
    cea6:	9300      	ld.w      	r0, (r3, 0)
    cea8:	e3fffe24 	bsr      	0xcaf0	// caf0 <kfree>
    ceac:	c4004820 	lsli      	r0, r0, 0
			} else {
				pr_debug("inserting new free block\n");
				xrp_allocation->next = cur;
				*pcur = xrp_allocation;
			}
			break;
    ceb0:	0432      	br      	0xcf14	// cf14 <xrp_free+0x2a8>
    ceb2:	0000      	.short	0x0000
    ceb4:	0000e670 	.long	0x0000e670
    ceb8:	0000e4c0 	.long	0x0000e4c0
    cebc:	0000ca94 	.long	0x0000ca94
    cec0:	0000cb24 	.long	0x0000cb24
    cec4:	0000e4d0 	.long	0x0000e4d0
    cec8:	0000e4f4 	.long	0x0000e4f4
    cecc:	0000caf0 	.long	0x0000caf0
    ced0:	0000e508 	.long	0x0000e508
    ced4:	0000e534 	.long	0x0000e534
				pr_debug("inserting new free block\n");
    ced8:	1017      	lrw      	r0, 0xe558	// cf34 <xrp_free+0x2c8>
    ceda:	e3fffddd 	bsr      	0xca94	// ca94 <pr_debug>
    cede:	c4004820 	lsli      	r0, r0, 0
				xrp_allocation->next = cur;
    cee2:	e4681013 	subi      	r3, r8, 20
    cee6:	9360      	ld.w      	r3, (r3, 0)
    cee8:	e448100b 	subi      	r2, r8, 12
    ceec:	9240      	ld.w      	r2, (r2, 0)
    ceee:	b343      	st.w      	r2, (r3, 0xc)
				*pcur = xrp_allocation;
    cef0:	e4681003 	subi      	r3, r8, 4
    cef4:	9360      	ld.w      	r3, (r3, 0)
    cef6:	e4481013 	subi      	r2, r8, 20
    cefa:	9240      	ld.w      	r2, (r2, 0)
    cefc:	b340      	st.w      	r2, (r3, 0)
			break;
    cefe:	040b      	br      	0xcf14	// cf14 <xrp_free+0x2a8>
	for (pcur = &pool->free_list; ; pcur = &(*pcur)->next) {
    cf00:	e4681003 	subi      	r3, r8, 4
    cf04:	9360      	ld.w      	r3, (r3, 0)
    cf06:	9340      	ld.w      	r2, (r3, 0)
    cf08:	e4681003 	subi      	r3, r8, 4
    cf0c:	220b      	addi      	r2, 12
    cf0e:	b340      	st.w      	r2, (r3, 0)
    cf10:	06dc      	br      	0xccc8	// ccc8 <xrp_free+0x5c>
			break;
    cf12:	6c00      	or      	r0, r0
		}
	}

	xrp_pool_unlock(pool);
    cf14:	e4681007 	subi      	r3, r8, 8
    cf18:	9300      	ld.w      	r0, (r3, 0)
    cf1a:	e3fffe13 	bsr      	0xcb40	// cb40 <xrp_pool_unlock>
    cf1e:	c4004820 	lsli      	r0, r0, 0
}
    cf22:	6c00      	or      	r0, r0
    cf24:	6fa3      	mov      	sp, r8
    cf26:	d9ee2001 	ld.w      	r15, (sp, 0x4)
    cf2a:	d90e2000 	ld.w      	r8, (sp, 0)
    cf2e:	1402      	addi      	sp, sp, 8
    cf30:	783c      	rts
    cf32:	0000      	.short	0x0000
    cf34:	0000e558 	.long	0x0000e558
    cf38:	0000ca94 	.long	0x0000ca94
    cf3c:	0000cb40 	.long	0x0000cb40

0000cf40 <xrp_allocate>:
* 		size 需要申请内存大小
*       align 按多少字节对齐
*       ** alloc [OUT]返回 申请内存的结构体地址的地址
*/
long xrp_allocate(struct xrp_allocation_pool *pool,u32 size, u32 align, struct xrp_allocation **alloc)
{
    cf40:	1423      	subi      	sp, sp, 12
    cf42:	b880      	st.w      	r4, (sp, 0)
    cf44:	dd0e2001 	st.w      	r8, (sp, 0x4)
    cf48:	ddee2002 	st.w      	r15, (sp, 0x8)
    cf4c:	6e3b      	mov      	r8, sp
    cf4e:	142a      	subi      	sp, sp, 40
    cf50:	e5881017 	subi      	r12, r8, 24
    cf54:	dc0c2000 	st.w      	r0, (r12, 0)
    cf58:	e408101b 	subi      	r0, r8, 28
    cf5c:	b020      	st.w      	r1, (r0, 0)
    cf5e:	e428101f 	subi      	r1, r8, 32
    cf62:	b140      	st.w      	r2, (r1, 0)
    cf64:	e4481023 	subi      	r2, r8, 36
    cf68:	b260      	st.w      	r3, (r2, 0)
	struct xrp_allocation **pcur;
	struct xrp_allocation *cur = NULL;
    cf6a:	e4681007 	subi      	r3, r8, 8
    cf6e:	3200      	movi      	r2, 0
    cf70:	b340      	st.w      	r2, (r3, 0)
	struct xrp_allocation *new;
	phys_addr_t aligned_start = 0;//起始物理地址
    cf72:	e4681013 	subi      	r3, r8, 20
    cf76:	3200      	movi      	r2, 0
    cf78:	b340      	st.w      	r2, (r3, 0)
	bool found = false;
    cf7a:	e468100f 	subi      	r3, r8, 16
    cf7e:	3200      	movi      	r2, 0
    cf80:	b340      	st.w      	r2, (r3, 0)

	pr_debug("entry xrp_allocate func!\n");
    cf82:	131d      	lrw      	r0, 0xe574	// d174 <xrp_allocate+0x234>
    cf84:	e3fffd88 	bsr      	0xca94	// ca94 <pr_debug>
    cf88:	c4004820 	lsli      	r0, r0, 0
	if (!size || (align & (align - 1)))
    cf8c:	e468101b 	subi      	r3, r8, 28
    cf90:	9360      	ld.w      	r3, (r3, 0)
    cf92:	e903000c 	bez      	r3, 0xcfaa	// cfaa <xrp_allocate+0x6a>
    cf96:	e468101f 	subi      	r3, r8, 32
    cf9a:	9360      	ld.w      	r3, (r3, 0)
    cf9c:	5b43      	subi      	r2, r3, 1
    cf9e:	e468101f 	subi      	r3, r8, 32
    cfa2:	9360      	ld.w      	r3, (r3, 0)
    cfa4:	68c8      	and      	r3, r2
    cfa6:	e9030006 	bez      	r3, 0xcfb2	// cfb2 <xrp_allocate+0x72>
		return -EINVAL;
    cfaa:	3300      	movi      	r3, 0
    cfac:	2b15      	subi      	r3, 22
    cfae:	e800023d 	br      	0xd428	// d428 <xrp_allocate+0x4e8>
	if (!align)
    cfb2:	e468101f 	subi      	r3, r8, 32
    cfb6:	9360      	ld.w      	r3, (r3, 0)
    cfb8:	e9230006 	bnez      	r3, 0xcfc4	// cfc4 <xrp_allocate+0x84>
		align = 1;
    cfbc:	e468101f 	subi      	r3, r8, 32
    cfc0:	3201      	movi      	r2, 1
    cfc2:	b340      	st.w      	r2, (r3, 0)

	/* 作为临时保存返回申请内存的地址 */
	new = kzalloc(sizeof(struct xrp_allocation), GFP_KERNEL);
    cfc4:	e488100b 	subi      	r4, r8, 12
    cfc8:	3100      	movi      	r1, 0
    cfca:	3014      	movi      	r0, 20
    cfcc:	e3fffd74 	bsr      	0xcab4	// cab4 <kzalloc>
    cfd0:	c4004820 	lsli      	r0, r0, 0
    cfd4:	b400      	st.w      	r0, (r4, 0)
	if (!new)
    cfd6:	e468100b 	subi      	r3, r8, 12
    cfda:	9360      	ld.w      	r3, (r3, 0)
    cfdc:	e9230006 	bnez      	r3, 0xcfe8	// cfe8 <xrp_allocate+0xa8>
		return -ENOMEM;
    cfe0:	3300      	movi      	r3, 0
    cfe2:	2b0b      	subi      	r3, 12
    cfe4:	e8000222 	br      	0xd428	// d428 <xrp_allocate+0x4e8>

	align = ALIGN(align, XRP_PAGE_SIZE);//页UP对齐
    cfe8:	e468101f 	subi      	r3, r8, 32
    cfec:	9360      	ld.w      	r3, (r3, 0)
    cfee:	5b4a      	addi      	r2, r3, 3
    cff0:	e468101f 	subi      	r3, r8, 32
    cff4:	e4423003 	andni      	r2, r2, 3
    cff8:	b340      	st.w      	r2, (r3, 0)
	size = ALIGN(size, XRP_PAGE_SIZE);
    cffa:	e468101b 	subi      	r3, r8, 28
    cffe:	9360      	ld.w      	r3, (r3, 0)
    d000:	5b4a      	addi      	r2, r3, 3
    d002:	e468101b 	subi      	r3, r8, 28
    d006:	e4423003 	andni      	r2, r2, 3
    d00a:	b340      	st.w      	r2, (r3, 0)

	xrp_pool_lock(pool);
    d00c:	e4681017 	subi      	r3, r8, 24
    d010:	9300      	ld.w      	r0, (r3, 0)
    d012:	e3fffd89 	bsr      	0xcb24	// cb24 <xrp_pool_lock>
    d016:	c4004820 	lsli      	r0, r0, 0

	/* on exit free list is fixed */
	for (pcur = &pool->free_list; *pcur; pcur = &(*pcur)->next) {
    d01a:	e4681003 	subi      	r3, r8, 4
    d01e:	e4481017 	subi      	r2, r8, 24
    d022:	9240      	ld.w      	r2, (r2, 0)
    d024:	2207      	addi      	r2, 8
    d026:	b340      	st.w      	r2, (r3, 0)
    d028:	0564      	br      	0xd2f0	// d2f0 <xrp_allocate+0x3b0>
		cur = *pcur;
    d02a:	e4681007 	subi      	r3, r8, 8
    d02e:	e4481003 	subi      	r2, r8, 4
    d032:	9240      	ld.w      	r2, (r2, 0)
    d034:	9240      	ld.w      	r2, (r2, 0)
    d036:	b340      	st.w      	r2, (r3, 0)
		aligned_start = ALIGN(cur->start, align);
    d038:	e4681007 	subi      	r3, r8, 8
    d03c:	9360      	ld.w      	r3, (r3, 0)
    d03e:	9340      	ld.w      	r2, (r3, 0)
    d040:	e468101f 	subi      	r3, r8, 32
    d044:	9360      	ld.w      	r3, (r3, 0)
    d046:	60c8      	addu      	r3, r2
    d048:	5b43      	subi      	r2, r3, 1
    d04a:	e468101f 	subi      	r3, r8, 32
    d04e:	3100      	movi      	r1, 0
    d050:	9360      	ld.w      	r3, (r3, 0)
    d052:	596d      	subu      	r3, r1, r3
    d054:	688c      	and      	r2, r3
    d056:	e4681013 	subi      	r3, r8, 20
    d05a:	b340      	st.w      	r2, (r3, 0)

		if (aligned_start >= cur->start &&
    d05c:	e4681007 	subi      	r3, r8, 8
    d060:	9360      	ld.w      	r3, (r3, 0)
    d062:	9340      	ld.w      	r2, (r3, 0)
    d064:	e4681013 	subi      	r3, r8, 20
    d068:	9360      	ld.w      	r3, (r3, 0)
    d06a:	648c      	cmphs      	r3, r2
    d06c:	0d36      	bf      	0xd2d8	// d2d8 <xrp_allocate+0x398>
		    aligned_start - cur->start + size <= cur->size) {// 内存池的内存,比要申请的内存多时
    d06e:	e4681013 	subi      	r3, r8, 20
    d072:	9340      	ld.w      	r2, (r3, 0)
    d074:	e4681007 	subi      	r3, r8, 8
    d078:	9360      	ld.w      	r3, (r3, 0)
    d07a:	9360      	ld.w      	r3, (r3, 0)
    d07c:	608e      	subu      	r2, r3
    d07e:	e468101b 	subi      	r3, r8, 28
    d082:	9360      	ld.w      	r3, (r3, 0)
    d084:	608c      	addu      	r2, r3
    d086:	e4681007 	subi      	r3, r8, 8
    d08a:	9360      	ld.w      	r3, (r3, 0)
    d08c:	9361      	ld.w      	r3, (r3, 0x4)
		if (aligned_start >= cur->start &&
    d08e:	648c      	cmphs      	r3, r2
    d090:	0d24      	bf      	0xd2d8	// d2d8 <xrp_allocate+0x398>
			if (aligned_start == cur->start) {
    d092:	e4681007 	subi      	r3, r8, 8
    d096:	9360      	ld.w      	r3, (r3, 0)
    d098:	9340      	ld.w      	r2, (r3, 0)
    d09a:	e4681013 	subi      	r3, r8, 20
    d09e:	9360      	ld.w      	r3, (r3, 0)
    d0a0:	64ca      	cmpne      	r2, r3
    d0a2:	0877      	bt      	0xd190	// d190 <xrp_allocate+0x250>
				if (aligned_start + size == cur->start + cur->size) {//size == cur->size 申请使用所有的块
    d0a4:	e4681013 	subi      	r3, r8, 20
    d0a8:	9340      	ld.w      	r2, (r3, 0)
    d0aa:	e468101b 	subi      	r3, r8, 28
    d0ae:	9360      	ld.w      	r3, (r3, 0)
    d0b0:	608c      	addu      	r2, r3
    d0b2:	e4681007 	subi      	r3, r8, 8
    d0b6:	9360      	ld.w      	r3, (r3, 0)
    d0b8:	9320      	ld.w      	r1, (r3, 0)
    d0ba:	e4681007 	subi      	r3, r8, 8
    d0be:	9360      	ld.w      	r3, (r3, 0)
    d0c0:	9361      	ld.w      	r3, (r3, 0x4)
    d0c2:	60c4      	addu      	r3, r1
    d0c4:	64ca      	cmpne      	r2, r3
    d0c6:	0817      	bt      	0xd0f4	// d0f4 <xrp_allocate+0x1b4>
					pr_debug("reusing complete block: %pap x %x\n", &cur->start, cur->size);
    d0c8:	e4681007 	subi      	r3, r8, 8
    d0cc:	9320      	ld.w      	r1, (r3, 0)
    d0ce:	e4681007 	subi      	r3, r8, 8
    d0d2:	9360      	ld.w      	r3, (r3, 0)
    d0d4:	9361      	ld.w      	r3, (r3, 0x4)
    d0d6:	6c8f      	mov      	r2, r3
    d0d8:	110b      	lrw      	r0, 0xe590	// d184 <xrp_allocate+0x244>
    d0da:	e3fffcdd 	bsr      	0xca94	// ca94 <pr_debug>
    d0de:	c4004820 	lsli      	r0, r0, 0
					*pcur = cur->next;
    d0e2:	e4681007 	subi      	r3, r8, 8
    d0e6:	9360      	ld.w      	r3, (r3, 0)
    d0e8:	9343      	ld.w      	r2, (r3, 0xc)
    d0ea:	e4681003 	subi      	r3, r8, 4
    d0ee:	9360      	ld.w      	r3, (r3, 0)
    d0f0:	b340      	st.w      	r2, (r3, 0)
    d0f2:	04ee      	br      	0xd2ce	// d2ce <xrp_allocate+0x38e>
				} else {
					pr_debug("cutting block head: %pap x %x ->\n", &cur->start, cur->size);
    d0f4:	e4681007 	subi      	r3, r8, 8
    d0f8:	9320      	ld.w      	r1, (r3, 0)
    d0fa:	e4681007 	subi      	r3, r8, 8
    d0fe:	9360      	ld.w      	r3, (r3, 0)
    d100:	9361      	ld.w      	r3, (r3, 0x4)
    d102:	6c8f      	mov      	r2, r3
    d104:	1101      	lrw      	r0, 0xe5b4	// d188 <xrp_allocate+0x248>
    d106:	e3fffcc7 	bsr      	0xca94	// ca94 <pr_debug>
    d10a:	c4004820 	lsli      	r0, r0, 0
					cur->size -= aligned_start + size - cur->start;//cur->size 代表内存池剩余内存大小,aligned_start-cur->start代表对齐消耗
    d10e:	e4681007 	subi      	r3, r8, 8
    d112:	9360      	ld.w      	r3, (r3, 0)
    d114:	9341      	ld.w      	r2, (r3, 0x4)
    d116:	e4681007 	subi      	r3, r8, 8
    d11a:	9360      	ld.w      	r3, (r3, 0)
    d11c:	9320      	ld.w      	r1, (r3, 0)
    d11e:	e4681013 	subi      	r3, r8, 20
    d122:	9300      	ld.w      	r0, (r3, 0)
    d124:	e468101b 	subi      	r3, r8, 28
    d128:	9360      	ld.w      	r3, (r3, 0)
    d12a:	60c0      	addu      	r3, r0
    d12c:	596d      	subu      	r3, r1, r3
    d12e:	608c      	addu      	r2, r3
    d130:	e4681007 	subi      	r3, r8, 8
    d134:	9360      	ld.w      	r3, (r3, 0)
    d136:	b341      	st.w      	r2, (r3, 0x4)
					cur->start = aligned_start + size;//cur->start 代表内存池剩余内存起始地址
    d138:	e4681013 	subi      	r3, r8, 20
    d13c:	9340      	ld.w      	r2, (r3, 0)
    d13e:	e468101b 	subi      	r3, r8, 28
    d142:	9360      	ld.w      	r3, (r3, 0)
    d144:	608c      	addu      	r2, r3
    d146:	e4681007 	subi      	r3, r8, 8
    d14a:	9360      	ld.w      	r3, (r3, 0)
    d14c:	b340      	st.w      	r2, (r3, 0)
					pr_debug("... -> %pap x %x\n", &cur->start, cur->size);
    d14e:	e4681007 	subi      	r3, r8, 8
    d152:	9320      	ld.w      	r1, (r3, 0)
    d154:	e4681007 	subi      	r3, r8, 8
    d158:	9360      	ld.w      	r3, (r3, 0)
    d15a:	9361      	ld.w      	r3, (r3, 0x4)
    d15c:	6c8f      	mov      	r2, r3
    d15e:	100c      	lrw      	r0, 0xe5d8	// d18c <xrp_allocate+0x24c>
    d160:	e3fffc9a 	bsr      	0xca94	// ca94 <pr_debug>
    d164:	c4004820 	lsli      	r0, r0, 0
					cur = NULL;
    d168:	e4681007 	subi      	r3, r8, 8
    d16c:	3200      	movi      	r2, 0
    d16e:	b340      	st.w      	r2, (r3, 0)
    d170:	04af      	br      	0xd2ce	// d2ce <xrp_allocate+0x38e>
    d172:	0000      	.short	0x0000
    d174:	0000e574 	.long	0x0000e574
    d178:	0000ca94 	.long	0x0000ca94
    d17c:	0000cab4 	.long	0x0000cab4
    d180:	0000cb24 	.long	0x0000cb24
    d184:	0000e590 	.long	0x0000e590
    d188:	0000e5b4 	.long	0x0000e5b4
    d18c:	0000e5d8 	.long	0x0000e5d8
				}
			} else {
				if (aligned_start + size == cur->start + cur->size) {
    d190:	e4681013 	subi      	r3, r8, 20
    d194:	9340      	ld.w      	r2, (r3, 0)
    d196:	e468101b 	subi      	r3, r8, 28
    d19a:	9360      	ld.w      	r3, (r3, 0)
    d19c:	608c      	addu      	r2, r3
    d19e:	e4681007 	subi      	r3, r8, 8
    d1a2:	9360      	ld.w      	r3, (r3, 0)
    d1a4:	9320      	ld.w      	r1, (r3, 0)
    d1a6:	e4681007 	subi      	r3, r8, 8
    d1aa:	9360      	ld.w      	r3, (r3, 0)
    d1ac:	9361      	ld.w      	r3, (r3, 0x4)
    d1ae:	60c4      	addu      	r3, r1
    d1b0:	64ca      	cmpne      	r2, r3
    d1b2:	082c      	bt      	0xd20a	// d20a <xrp_allocate+0x2ca>
					pr_debug("cutting block tail: %pap x %x ->\n", &cur->start, cur->size);
    d1b4:	e4681007 	subi      	r3, r8, 8
    d1b8:	9320      	ld.w      	r1, (r3, 0)
    d1ba:	e4681007 	subi      	r3, r8, 8
    d1be:	9360      	ld.w      	r3, (r3, 0)
    d1c0:	9361      	ld.w      	r3, (r3, 0x4)
    d1c2:	6c8f      	mov      	r2, r3
    d1c4:	130f      	lrw      	r0, 0xe5ec	// d380 <xrp_allocate+0x440>
    d1c6:	e3fffc67 	bsr      	0xca94	// ca94 <pr_debug>
    d1ca:	c4004820 	lsli      	r0, r0, 0
					cur->size = aligned_start - cur->start;
    d1ce:	e4681013 	subi      	r3, r8, 20
    d1d2:	9340      	ld.w      	r2, (r3, 0)
    d1d4:	e4681007 	subi      	r3, r8, 8
    d1d8:	9360      	ld.w      	r3, (r3, 0)
    d1da:	9360      	ld.w      	r3, (r3, 0)
    d1dc:	608e      	subu      	r2, r3
    d1de:	e4681007 	subi      	r3, r8, 8
    d1e2:	9360      	ld.w      	r3, (r3, 0)
    d1e4:	b341      	st.w      	r2, (r3, 0x4)
					pr_debug("... -> %pap x %x\n", &cur->start, cur->size);
    d1e6:	e4681007 	subi      	r3, r8, 8
    d1ea:	9320      	ld.w      	r1, (r3, 0)
    d1ec:	e4681007 	subi      	r3, r8, 8
    d1f0:	9360      	ld.w      	r3, (r3, 0)
    d1f2:	9361      	ld.w      	r3, (r3, 0x4)
    d1f4:	6c8f      	mov      	r2, r3
    d1f6:	1305      	lrw      	r0, 0xe5d8	// d388 <xrp_allocate+0x448>
    d1f8:	e3fffc4e 	bsr      	0xca94	// ca94 <pr_debug>
    d1fc:	c4004820 	lsli      	r0, r0, 0
					cur = NULL;
    d200:	e4681007 	subi      	r3, r8, 8
    d204:	3200      	movi      	r2, 0
    d206:	b340      	st.w      	r2, (r3, 0)
    d208:	0463      	br      	0xd2ce	// d2ce <xrp_allocate+0x38e>
				} else {
					pr_debug("splitting block into two: %pap x %x ->\n", &cur->start, cur->size);
    d20a:	e4681007 	subi      	r3, r8, 8
    d20e:	9320      	ld.w      	r1, (r3, 0)
    d210:	e4681007 	subi      	r3, r8, 8
    d214:	9360      	ld.w      	r3, (r3, 0)
    d216:	9361      	ld.w      	r3, (r3, 0x4)
    d218:	6c8f      	mov      	r2, r3
    d21a:	121d      	lrw      	r0, 0xe610	// d38c <xrp_allocate+0x44c>
    d21c:	e3fffc3c 	bsr      	0xca94	// ca94 <pr_debug>
    d220:	c4004820 	lsli      	r0, r0, 0
					new->start = aligned_start + size;
    d224:	e4681013 	subi      	r3, r8, 20
    d228:	9340      	ld.w      	r2, (r3, 0)
    d22a:	e468101b 	subi      	r3, r8, 28
    d22e:	9360      	ld.w      	r3, (r3, 0)
    d230:	608c      	addu      	r2, r3
    d232:	e468100b 	subi      	r3, r8, 12
    d236:	9360      	ld.w      	r3, (r3, 0)
    d238:	b340      	st.w      	r2, (r3, 0)
					new->size = cur->start + cur->size - new->start;
    d23a:	e4681007 	subi      	r3, r8, 8
    d23e:	9360      	ld.w      	r3, (r3, 0)
    d240:	9340      	ld.w      	r2, (r3, 0)
    d242:	e4681007 	subi      	r3, r8, 8
    d246:	9360      	ld.w      	r3, (r3, 0)
    d248:	9361      	ld.w      	r3, (r3, 0x4)
    d24a:	608c      	addu      	r2, r3
    d24c:	e468100b 	subi      	r3, r8, 12
    d250:	9360      	ld.w      	r3, (r3, 0)
    d252:	9360      	ld.w      	r3, (r3, 0)
    d254:	608e      	subu      	r2, r3
    d256:	e468100b 	subi      	r3, r8, 12
    d25a:	9360      	ld.w      	r3, (r3, 0)
    d25c:	b341      	st.w      	r2, (r3, 0x4)

					cur->size = aligned_start - cur->start;
    d25e:	e4681013 	subi      	r3, r8, 20
    d262:	9340      	ld.w      	r2, (r3, 0)
    d264:	e4681007 	subi      	r3, r8, 8
    d268:	9360      	ld.w      	r3, (r3, 0)
    d26a:	9360      	ld.w      	r3, (r3, 0)
    d26c:	608e      	subu      	r2, r3
    d26e:	e4681007 	subi      	r3, r8, 8
    d272:	9360      	ld.w      	r3, (r3, 0)
    d274:	b341      	st.w      	r2, (r3, 0x4)

					new->next = cur->next;
    d276:	e4681007 	subi      	r3, r8, 8
    d27a:	9360      	ld.w      	r3, (r3, 0)
    d27c:	9343      	ld.w      	r2, (r3, 0xc)
    d27e:	e468100b 	subi      	r3, r8, 12
    d282:	9360      	ld.w      	r3, (r3, 0)
    d284:	b343      	st.w      	r2, (r3, 0xc)
					cur->next = new;
    d286:	e4681007 	subi      	r3, r8, 8
    d28a:	9360      	ld.w      	r3, (r3, 0)
    d28c:	e448100b 	subi      	r2, r8, 12
    d290:	9240      	ld.w      	r2, (r2, 0)
    d292:	b343      	st.w      	r2, (r3, 0xc)
					pr_debug("... -> %pap x %x + %pap x %x\n", &cur->start, cur->size, &new->start, new->size);
    d294:	e4681007 	subi      	r3, r8, 8
    d298:	9320      	ld.w      	r1, (r3, 0)
    d29a:	e4681007 	subi      	r3, r8, 8
    d29e:	9360      	ld.w      	r3, (r3, 0)
    d2a0:	9341      	ld.w      	r2, (r3, 0x4)
    d2a2:	e468100b 	subi      	r3, r8, 12
    d2a6:	9300      	ld.w      	r0, (r3, 0)
    d2a8:	e468100b 	subi      	r3, r8, 12
    d2ac:	9360      	ld.w      	r3, (r3, 0)
    d2ae:	9361      	ld.w      	r3, (r3, 0x4)
    d2b0:	b860      	st.w      	r3, (sp, 0)
    d2b2:	6cc3      	mov      	r3, r0
    d2b4:	1117      	lrw      	r0, 0xe638	// d390 <xrp_allocate+0x450>
    d2b6:	e3fffbef 	bsr      	0xca94	// ca94 <pr_debug>
    d2ba:	c4004820 	lsli      	r0, r0, 0

					cur = NULL;
    d2be:	e4681007 	subi      	r3, r8, 8
    d2c2:	3200      	movi      	r2, 0
    d2c4:	b340      	st.w      	r2, (r3, 0)
					new = NULL;
    d2c6:	e468100b 	subi      	r3, r8, 12
    d2ca:	3200      	movi      	r2, 0
    d2cc:	b340      	st.w      	r2, (r3, 0)
				}
			}
			found = true;
    d2ce:	e468100f 	subi      	r3, r8, 16
    d2d2:	3201      	movi      	r2, 1
    d2d4:	b340      	st.w      	r2, (r3, 0)
			break;
    d2d6:	0413      	br      	0xd2fc	// d2fc <xrp_allocate+0x3bc>
		} else {
			cur = NULL;
    d2d8:	e4681007 	subi      	r3, r8, 8
    d2dc:	3200      	movi      	r2, 0
    d2de:	b340      	st.w      	r2, (r3, 0)
	for (pcur = &pool->free_list; *pcur; pcur = &(*pcur)->next) {
    d2e0:	e4681003 	subi      	r3, r8, 4
    d2e4:	9360      	ld.w      	r3, (r3, 0)
    d2e6:	9340      	ld.w      	r2, (r3, 0)
    d2e8:	e4681003 	subi      	r3, r8, 4
    d2ec:	220b      	addi      	r2, 12
    d2ee:	b340      	st.w      	r2, (r3, 0)
    d2f0:	e4681003 	subi      	r3, r8, 4
    d2f4:	9360      	ld.w      	r3, (r3, 0)
    d2f6:	9360      	ld.w      	r3, (r3, 0)
    d2f8:	e923fe99 	bnez      	r3, 0xd02a	// d02a <xrp_allocate+0xea>
		}
	}

	xrp_pool_unlock(pool);
    d2fc:	e4681017 	subi      	r3, r8, 24
    d300:	9300      	ld.w      	r0, (r3, 0)
    d302:	e3fffc1f 	bsr      	0xcb40	// cb40 <xrp_pool_unlock>
    d306:	c4004820 	lsli      	r0, r0, 0

	if (!found) {
    d30a:	e468100f 	subi      	r3, r8, 16
    d30e:	9360      	ld.w      	r3, (r3, 0)
    d310:	e9230013 	bnez      	r3, 0xd336	// d336 <xrp_allocate+0x3f6>
		kfree(cur);
    d314:	e4681007 	subi      	r3, r8, 8
    d318:	9300      	ld.w      	r0, (r3, 0)
    d31a:	e3fffbeb 	bsr      	0xcaf0	// caf0 <kfree>
    d31e:	c4004820 	lsli      	r0, r0, 0
		kfree(new);
    d322:	e468100b 	subi      	r3, r8, 12
    d326:	9300      	ld.w      	r0, (r3, 0)
    d328:	e3fffbe4 	bsr      	0xcaf0	// caf0 <kfree>
    d32c:	c4004820 	lsli      	r0, r0, 0
		return -ENOMEM;
    d330:	3300      	movi      	r3, 0
    d332:	2b0b      	subi      	r3, 12
    d334:	047a      	br      	0xd428	// d428 <xrp_allocate+0x4e8>
	}

	if (!cur) {
    d336:	e4681007 	subi      	r3, r8, 8
    d33a:	9360      	ld.w      	r3, (r3, 0)
    d33c:	e923000c 	bnez      	r3, 0xd354	// d354 <xrp_allocate+0x414>
		cur = new;
    d340:	e4681007 	subi      	r3, r8, 8
    d344:	e448100b 	subi      	r2, r8, 12
    d348:	9240      	ld.w      	r2, (r2, 0)
    d34a:	b340      	st.w      	r2, (r3, 0)
		new = NULL;
    d34c:	e468100b 	subi      	r3, r8, 12
    d350:	3200      	movi      	r2, 0
    d352:	b340      	st.w      	r2, (r3, 0)
	}
	if (!cur) {
    d354:	e4681007 	subi      	r3, r8, 8
    d358:	9360      	ld.w      	r3, (r3, 0)
    d35a:	e9230023 	bnez      	r3, 0xd3a0	// d3a0 <xrp_allocate+0x460>
		cur = kzalloc(sizeof(struct xrp_allocation), GFP_KERNEL);
    d35e:	e4881007 	subi      	r4, r8, 8
    d362:	3100      	movi      	r1, 0
    d364:	3014      	movi      	r0, 20
    d366:	e3fffba7 	bsr      	0xcab4	// cab4 <kzalloc>
    d36a:	c4004820 	lsli      	r0, r0, 0
    d36e:	b400      	st.w      	r0, (r4, 0)
		if (!cur)
    d370:	e4681007 	subi      	r3, r8, 8
    d374:	9360      	ld.w      	r3, (r3, 0)
    d376:	e9230015 	bnez      	r3, 0xd3a0	// d3a0 <xrp_allocate+0x460>
			return -ENOMEM;
    d37a:	3300      	movi      	r3, 0
    d37c:	2b0b      	subi      	r3, 12
    d37e:	0455      	br      	0xd428	// d428 <xrp_allocate+0x4e8>
    d380:	0000e5ec 	.long	0x0000e5ec
    d384:	0000ca94 	.long	0x0000ca94
    d388:	0000e5d8 	.long	0x0000e5d8
    d38c:	0000e610 	.long	0x0000e610
    d390:	0000e638 	.long	0x0000e638
    d394:	0000cb40 	.long	0x0000cb40
    d398:	0000caf0 	.long	0x0000caf0
    d39c:	0000cab4 	.long	0x0000cab4
	}
	if (new)
    d3a0:	e468100b 	subi      	r3, r8, 12
    d3a4:	9360      	ld.w      	r3, (r3, 0)
    d3a6:	e9030009 	bez      	r3, 0xd3b8	// d3b8 <xrp_allocate+0x478>
		kfree(new);
    d3aa:	e468100b 	subi      	r3, r8, 12
    d3ae:	9300      	ld.w      	r0, (r3, 0)
    d3b0:	e3fffba0 	bsr      	0xcaf0	// caf0 <kfree>
    d3b4:	c4004820 	lsli      	r0, r0, 0

	pr_debug("returning: %pap x %x\n", &aligned_start, size);
    d3b8:	e468101b 	subi      	r3, r8, 28
    d3bc:	e4281013 	subi      	r1, r8, 20
    d3c0:	9340      	ld.w      	r2, (r3, 0)
    d3c2:	110c      	lrw      	r0, 0xe658	// d470 <xrp_allocation_offset+0x34>
    d3c4:	e3fffb68 	bsr      	0xca94	// ca94 <pr_debug>
    d3c8:	c4004820 	lsli      	r0, r0, 0
	/* 将输入的物理地址,转换成虚拟地址 */
	cur->start = aligned_start;
    d3cc:	e4681013 	subi      	r3, r8, 20
    d3d0:	9340      	ld.w      	r2, (r3, 0)
    d3d2:	e4681007 	subi      	r3, r8, 8
    d3d6:	9360      	ld.w      	r3, (r3, 0)
    d3d8:	b340      	st.w      	r2, (r3, 0)
	cur->size = size;
    d3da:	e4681007 	subi      	r3, r8, 8
    d3de:	9360      	ld.w      	r3, (r3, 0)
    d3e0:	e448101b 	subi      	r2, r8, 28
    d3e4:	9240      	ld.w      	r2, (r2, 0)
    d3e6:	b341      	st.w      	r2, (r3, 0x4)
	cur->pool = pool;
    d3e8:	e4681007 	subi      	r3, r8, 8
    d3ec:	9360      	ld.w      	r3, (r3, 0)
    d3ee:	e4481017 	subi      	r2, r8, 24
    d3f2:	9240      	ld.w      	r2, (r2, 0)
    d3f4:	b344      	st.w      	r2, (r3, 0x10)
	atomic_set(&cur->ref, 0);
    d3f6:	e4681007 	subi      	r3, r8, 8
    d3fa:	9360      	ld.w      	r3, (r3, 0)
    d3fc:	2307      	addi      	r3, 8
    d3fe:	3100      	movi      	r1, 0
    d400:	6c0f      	mov      	r0, r3
    d402:	e3fffbbb 	bsr      	0xcb78	// cb78 <atomic_set>
    d406:	c4004820 	lsli      	r0, r0, 0
	xrp_allocation_get(cur);
    d40a:	e4681007 	subi      	r3, r8, 8
    d40e:	9300      	ld.w      	r0, (r3, 0)
    d410:	e3fffba6 	bsr      	0xcb5c	// cb5c <xrp_allocation_get>
    d414:	c4004820 	lsli      	r0, r0, 0
	*alloc = cur;// 返回物理地址.
    d418:	e4681023 	subi      	r3, r8, 36
    d41c:	9360      	ld.w      	r3, (r3, 0)
    d41e:	e4481007 	subi      	r2, r8, 8
    d422:	9240      	ld.w      	r2, (r2, 0)
    d424:	b340      	st.w      	r2, (r3, 0)

	return 0;
    d426:	3300      	movi      	r3, 0
}
    d428:	6c0f      	mov      	r0, r3
    d42a:	6fa3      	mov      	sp, r8
    d42c:	d9ee2002 	ld.w      	r15, (sp, 0x8)
    d430:	d90e2001 	ld.w      	r8, (sp, 0x4)
    d434:	9880      	ld.w      	r4, (sp, 0)
    d436:	1403      	addi      	sp, sp, 12
    d438:	783c      	rts
	...

0000d43c <xrp_allocation_offset>:

phys_addr_t xrp_allocation_offset(const struct xrp_allocation *allocation)
{
    d43c:	1421      	subi      	sp, sp, 4
    d43e:	dd0e2000 	st.w      	r8, (sp, 0)
    d442:	6e3b      	mov      	r8, sp
    d444:	1421      	subi      	sp, sp, 4
    d446:	e4681003 	subi      	r3, r8, 4
    d44a:	b300      	st.w      	r0, (r3, 0)
	return allocation->start - allocation->pool->start;
    d44c:	e4681003 	subi      	r3, r8, 4
    d450:	9360      	ld.w      	r3, (r3, 0)
    d452:	9340      	ld.w      	r2, (r3, 0)
    d454:	e4681003 	subi      	r3, r8, 4
    d458:	9360      	ld.w      	r3, (r3, 0)
    d45a:	9364      	ld.w      	r3, (r3, 0x10)
    d45c:	9360      	ld.w      	r3, (r3, 0)
    d45e:	5a6d      	subu      	r3, r2, r3
}
    d460:	6c0f      	mov      	r0, r3
    d462:	6fa3      	mov      	sp, r8
    d464:	d90e2000 	ld.w      	r8, (sp, 0)
    d468:	1401      	addi      	sp, sp, 4
    d46a:	783c      	rts
    d46c:	0000caf0 	.long	0x0000caf0
    d470:	0000e658 	.long	0x0000e658
    d474:	0000ca94 	.long	0x0000ca94
    d478:	0000cb78 	.long	0x0000cb78
    d47c:	0000cb5c 	.long	0x0000cb5c

0000d480 <__libc_csu_init>:
    d480:	ebe00116 	push      	r4-r9, r15, r28
    d484:	ea8d0012 	lrw      	r13, 0x2b74	// d4cc <__libc_csu_fini+0x4>
    d488:	cf8c0002 	grs      	r28, 0xd48c	// d48c <__libc_csu_init+0xc>
    d48c:	c5bc003c 	addu      	r28, r28, r13
    d490:	1070      	lrw      	r3, 0xc	// d4d0 <__libc_csu_fini+0x8>
    d492:	d07c0823 	ldr.w      	r3, (r28, r3 << 0)
    d496:	6dc3      	mov      	r7, r0
    d498:	6e07      	mov      	r8, r1
    d49a:	6e4b      	mov      	r9, r2
    d49c:	10ae      	lrw      	r5, 0xffffff0c	// d4d4 <__libc_csu_fini+0xc>
    d49e:	7bcd      	jsr      	r3
    d4a0:	106e      	lrw      	r3, 0xffffff0c	// d4d8 <__libc_csu_fini+0x10>
    d4a2:	614e      	subu      	r5, r3
    d4a4:	55a2      	asri      	r5, r5, 2
    d4a6:	c7830026 	addu      	r6, r3, r28
    d4aa:	e905000c 	bez      	r5, 0xd4c2	// d4c2 <__libc_csu_init+0x42>
    d4ae:	3400      	movi      	r4, 0
    d4b0:	d0860883 	ldr.w      	r3, (r6, r4 << 2)
    d4b4:	6ca7      	mov      	r2, r9
    d4b6:	6c63      	mov      	r1, r8
    d4b8:	6c1f      	mov      	r0, r7
    d4ba:	2400      	addi      	r4, 1
    d4bc:	7bcd      	jsr      	r3
    d4be:	6516      	cmpne      	r5, r4
    d4c0:	0bf8      	bt      	0xd4b0	// d4b0 <__libc_csu_init+0x30>
    d4c2:	ebc00116 	pop      	r4-r9, r15, r28
	...

0000d4c8 <__libc_csu_fini>:
    d4c8:	783c      	rts
    d4ca:	0000      	.short	0x0000
    d4cc:	00002b74 	.long	0x00002b74
    d4d0:	0000000c 	.long	0x0000000c
    d4d4:	ffffff0c 	.long	0xffffff0c
    d4d8:	ffffff0c 	.long	0xffffff0c

0000d4dc <__do_global_ctors_aux>:
    d4dc:	14d2      	push      	r4-r5, r15
    d4de:	1088      	lrw      	r4, 0xff0c	// d4fc <call___do_global_ctors_aux+0x4>
    d4e0:	3500      	movi      	r5, 0
    d4e2:	9460      	ld.w      	r3, (r4, 0)
    d4e4:	2d00      	subi      	r5, 1
    d4e6:	654e      	cmpne      	r3, r5
    d4e8:	0c06      	bf      	0xd4f4	// d4f4 <__do_global_ctors_aux+0x18>
    d4ea:	2c03      	subi      	r4, 4
    d4ec:	7bcd      	jsr      	r3
    d4ee:	9460      	ld.w      	r3, (r4, 0)
    d4f0:	654e      	cmpne      	r3, r5
    d4f2:	0bfc      	bt      	0xd4ea	// d4ea <__do_global_ctors_aux+0xe>
    d4f4:	1492      	pop      	r4-r5, r15
	...

0000d4f8 <call___do_global_ctors_aux>:
    d4f8:	14d0      	push      	r15
    d4fa:	0000      	.short	0x0000
    d4fc:	0000ff0c 	.long	0x0000ff0c
    d500:	1490      	pop      	r15

Disassembly of section .fini:

0000d510 <_fini>:
    d510:	1422      	subi      	sp, sp, 8
    d512:	ddee2000 	st.w      	r15, (sp, 0)
    d516:	0405      	br      	0xd520	// d520 <_fini+0x10>
	...
    d520:	e3ffe332 	bsr      	0x9b84	// 9b84 <__do_global_dtors_aux>
    d524:	c4004820 	lsli      	r0, r0, 0
    d528:	0404      	br      	0xd530	// d530 <_fini+0x20>
    d52a:	0000      	.short	0x0000
    d52c:	00009b84 	.long	0x00009b84
    d530:	d9ee2000 	ld.w      	r15, (sp, 0)
    d534:	1402      	addi      	sp, sp, 8
    d536:	783c      	rts
